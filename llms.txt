Project Structure:
📁 playwrightauthor
├── 📁 .github
│   └── 📁 workflows
│       ├── 📄 accessibility-check.yml
│       ├── 📄 ci.yml
│       ├── 📄 docs-build.yml
│       ├── 📄 docs.yml
│       └── 📄 link-check.yml
├── 📁 docs
│   ├── 📁 architecture
│   │   ├── 📄 browser-lifecycle.md
│   │   ├── 📄 components.md
│   │   ├── 📄 error-handling.md
│   │   └── 📄 index.md
│   ├── 📁 auth
│   │   ├── 📄 github.md
│   │   ├── 📄 gmail.md
│   │   ├── 📄 index.md
│   │   ├── 📄 linkedin.md
│   │   └── 📄 troubleshooting.md
│   ├── 📁 performance
│   │   ├── 📄 connection-pooling.md
│   │   ├── 📄 index.md
│   │   ├── 📄 memory-management.md
│   │   └── 📄 monitoring.md
│   ├── 📁 platforms
│   │   ├── 📄 index.md
│   │   ├── 📄 linux.md
│   │   ├── 📄 macos.md
│   │   └── 📄 windows.md
│   └── 📄 index.md
├── 📁 examples
│   ├── 📁 fastapi
│   │   └── 📄 README.md
│   ├── 📁 pytest
│   │   ├── 📄 conftest.py
│   │   ├── 📄 README.md
│   │   ├── 📄 test_async.py
│   │   ├── 📄 test_authentication.py
│   │   └── 📄 test_basic.py
│   ├── 📄 README.md
│   ├── 📄 scrape_github_notifications.py
│   └── 📄 scrape_linkedin_feed.py
├── 📁 issues
├── 📁 scripts
│   ├── 📄 check_accessibility.py
│   └── 📄 check_links.py
├── 📁 src
│   └── 📁 playwrightauthor
│       ├── 📁 browser
│       │   ├── 📄 __init__.py
│       │   ├── 📄 finder.py
│       │   ├── 📄 installer.py
│       │   ├── 📄 launcher.py
│       │   └── 📄 process.py
│       ├── 📁 repl
│       │   ├── 📄 __init__.py
│       │   ├── 📄 completion.py
│       │   └── 📄 engine.py
│       ├── 📁 templates
│       │   └── 📄 onboarding.html
│       ├── 📁 utils
│       │   ├── 📄 logger.py
│       │   └── 📄 paths.py
│       ├── 📄 __init__.py
│       ├── 📄 __main__.py
│       ├── 📄 author.py
│       ├── 📄 browser_manager.py
│       ├── 📄 cli.py
│       ├── 📄 config.py
│       ├── 📄 connection.py
│       ├── 📄 exceptions.py
│       ├── 📄 lazy_imports.py
│       ├── 📄 monitoring.py
│       ├── 📄 onboarding.py
│       ├── 📄 state_manager.py
│       └── 📄 typing.py
├── 📁 src_docs
│   ├── 📁 md
│   │   ├── 📄 advanced-features.md
│   │   ├── 📄 api-reference.md
│   │   ├── 📄 authentication.md
│   │   ├── 📄 basic-usage.md
│   │   ├── 📄 browser-management.md
│   │   ├── 📄 configuration.md
│   │   ├── 📄 contributing.md
│   │   ├── 📄 getting-started.md
│   │   ├── 📄 index.md
│   │   └── 📄 troubleshooting.md
│   └── 📄 mkdocs.yml
├── 📁 tests
│   ├── 📄 test_author.py
│   ├── 📄 test_benchmark.py
│   ├── 📄 test_doctests.py
│   ├── 📄 test_integration.py
│   ├── 📄 test_platform_specific.py
│   └── 📄 test_utils.py
├── 📄 .gitignore
├── 📄 accessibility-report.md
├── 📄 AGENTS.md
├── 📄 CHANGELOG.md
├── 📄 CLAUDE.md
├── 📄 CLAUDE.poml
├── 📄 GEMINI.md
├── 📄 LICENSE
├── 📄 PLAN.md
├── 📄 publish.sh
├── 📄 pyproject.toml
├── 📄 README.md
├── 📄 TODO.md
└── 📄 WORK.md


<documents>
<document index="1">
<source>.cursorrules</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

PlaywrightAuthor is a convenience package for Microsoft Playwright that handles browser automation setup. It automatically manages Chrome for Testing installation, authentication with user profiles, and provides ready-to-use Browser objects through simple context managers.

## 2. Key Architecture

**Core Design Pattern**: The library follows a context manager pattern with `Browser()` and `AsyncBrowser()` classes that return authenticated Playwright browser objects.

**Main Components** (planned structure):
- `playwrightauthor/author.py` - Core Browser/AsyncBrowser classes (main API)
- `playwrightauthor/browser_manager.py` - Chrome installation/process management 
- `playwrightauthor/onboarding.py` - User guidance for authentication
- `playwrightauthor/cli.py` - Fire-powered CLI interface
- `playwrightauthor/utils/` - Logger and cross-platform path utilities

**Current State**: The project is in early development. The main implementation exists as a legacy scraper in `old/google_docs_scraper_simple.py` that demonstrates the core concept of connecting to an existing Chrome debug session.

## 3. Development Commands

### 3.1. Environment Setup
```bash
# Initial setup with uv
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add playwright rich fire loguru platformdirs requests psutil
```

### 3.2. Code Quality Pipeline
After any Python changes, run:
```bash
fd -e py -x uvx autoflake -i {}; \
fd -e py -x uvx pyupgrade --py312-plus {}; \
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
python -m pytest
```

### 3.3. Testing
- Run tests: `python -m pytest`
- Tests are located in `tests/` directory
- Current tests may be integration tests requiring live Chrome instance

### 3.4. CLI Usage
Once implemented:
```bash
python -m playwrightauthor status  # Check browser status
```

## 4. Code Standards

- **File headers**: Every Python file should include a `this_file:` comment with the relative path
- **Dependencies**: Use uv script headers with `# /// script` blocks
- **Type hints**: Use modern Python type hints (list, dict, | for unions)
- **Logging**: Use loguru with verbose flag support
- **CLI**: Use Fire for command-line interfaces with Rich for output

## 5. Browser Management Strategy

The core technical challenge is reliably managing Chrome for Testing:

1. **Detection**: Check if Chrome is running with `--remote-debugging-port=9222`
2. **Installation**: Prefer `npx puppeteer browsers install`, fallback to LKGV JSON downloads
3. **Process Management**: Kill non-debug instances, launch with persistent user-data-dir
4. **Connection**: Use Playwright's `connect_over_cdp()` to attach to debug session

## 6. Project Workflow

The project follows a documentation-driven development approach:
1. Read `WORK.md` and `PLAN.md` before making changes
2. Update documentation files after implementation
3. Use "Wait, but" reflection methodology for code review
4. Maintain minimal, self-contained commits

## 7. Dependencies

Core runtime dependencies:
- `playwright` - Browser automation
- `rich` - Terminal output formatting  
- `fire` - CLI generation
- `loguru` - Logging
- `platformdirs` - Cross-platform paths
- `requests` - HTTP client for downloads
- `psutil` - Process management

# Software Development Rules

## 8. Pre-Work Preparation

### 8.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 8.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 9. General Coding Principles

### 9.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 9.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 10. Tool Usage (When Available)

### 10.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 11. File Management

### 11.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 12. Python-Specific Guidelines

### 12.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 12.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 12.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 12.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 13. Post-Work Activities

### 13.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 13.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 14. Work Methodology

### 14.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 14.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 15. Special Commands

### 15.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 15.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 15.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 16. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 17. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate

**TL;DR for PlaywrightAuthor Codebase**

**1. Core Purpose & Value Proposition:**
PlaywrightAuthor is a Python convenience library built on top of Microsoft Playwright. Its primary goal is to eliminate the boilerplate setup for browser automation. It automatically finds or installs a "Chrome for Testing" instance, manages its process (ensuring it runs in debug mode), handles user authentication by reusing a persistent profile, and provides a ready-to-use, authenticated Playwright `Browser` object within a simple context manager (`with Browser() as browser:`).

**2. Key Architectural Components:**
*   **Main API (`author.py`):** Exposes the core `Browser()` and `AsyncBrowser()` context managers, which are the main entry points for the user.
*   **Browser Management (`browser/` & `browser_manager.py`):** This is the technical core of the library. It's a modular system responsible for:
    *   `finder.py`: Robustly discovering the Chrome executable across macOS, Windows, and Linux, checking over 20 standard and non-standard locations per platform.
    *   `installer.py`: Downloading the correct Chrome for Testing build using official JSON endpoints, with progress bars and SHA256 validation.
    *   `launcher.py`: Launching the Chrome process with the remote debugging port (`--remote-debugging-port=9222`).
    *   `process.py`: Managing the Chrome process, including gracefully killing existing non-debug instances and verifying the new process is ready.
*   **User Experience (`onboarding.py`, `cli.py`):**
    *   `onboarding.py`: If the user is not logged into necessary services, it serves a local HTML page (`templates/onboarding.html`) to guide them through the login process.
    *   `cli.py`: A `fire`-powered command-line interface for status checks (`status`) and cache clearing (`clear-cache`), with `rich` for formatted output.
*   **Configuration & State (`config.py`, `state_manager.py`):** Handles library configuration (e.g., timeouts, paths) and persists the state of the browser (e.g., installation path, version) to avoid redundant work.
*   **Utilities (`utils/`):** Cross-platform path management (`paths.py`) and `loguru`-based logging (`logger.py`).

**3. Development & Quality:**
*   **Workflow:** The project is documentation-driven, using `PLAN.md`, `TODO.md`, and `WORK.md` to guide development. It emphasizes iterative, minimal commits.
*   **Tooling:** Uses `uv` for environment and dependency management. The build system is `hatch` with `hatch-vcs` for versioning based on git tags.
*   **CI/CD (`.github/workflows/ci.yml`):** A comprehensive GitHub Actions pipeline tests the library on Ubuntu, Windows, and macOS. It runs linting (`ruff`), type checking (`mypy`), and a full `pytest` suite with coverage reporting to Codecov.
*   **Code Quality:** The codebase is fully type-hinted. A strict quality pipeline (`ruff`, `autoflake`, `pyupgrade`) is enforced and documented. Every file includes a `this_file:` comment for easy path reference.

**4. Current Status & Roadmap:**
The project has completed its initial phases focused on robustness, error handling, and cross-platform compatibility. It is now in the "Elegance and Performance" phase, which involves refactoring the architecture (e.g., separating state and config management), optimizing performance (e.g., lazy loading), and adding advanced features like browser profile management. Future phases will focus on improving the CLI, documentation, and user experience.

</document_content>
</document>

<document index="2">
<source>.github/workflows/accessibility-check.yml</source>
<document_content>
name: Documentation Accessibility Check

on:
  push:
    branches: [ main ]
    paths: [ 'docs/**', 'README.md', 'CHANGELOG.md' ]
  pull_request:
    branches: [ main ]
    paths: [ 'docs/**', 'README.md', 'CHANGELOG.md' ]
  schedule:
    # Run weekly on Saturdays at 07:00 UTC to monitor accessibility compliance
    - cron: '0 7 * * 6'
  workflow_dispatch:
    inputs:
      severity_threshold:
        description: 'Minimum severity level to fail the workflow'
        required: false
        default: 'error'
        type: choice
        options:
          - 'error'
          - 'warning'
          - 'info'
      fail_on_issues:
        description: 'Fail the workflow if accessibility issues are found'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  accessibility-check:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Make accessibility checker executable
      run: chmod +x scripts/check_accessibility.py
    
    - name: Run accessibility checker
      id: accessibility_check
      run: |
        # Set parameters from workflow input or defaults
        SEVERITY_THRESHOLD="${{ github.event.inputs.severity_threshold || 'error' }}"
        FAIL_ON_ISSUES="${{ github.event.inputs.fail_on_issues || 'false' }}"
        
        # For scheduled runs, always fail on error-level issues
        if [ "${{ github.event_name }}" = "schedule" ]; then
          FAIL_ON_ISSUES="true"
          SEVERITY_THRESHOLD="error"
        fi
        
        echo "Running accessibility checker with severity_threshold=${SEVERITY_THRESHOLD}, fail_on_issues=${FAIL_ON_ISSUES}"
        
        if [ "${FAIL_ON_ISSUES}" = "true" ]; then
          python scripts/check_accessibility.py docs --output accessibility-report.md --fail-on-error --severity-threshold "${SEVERITY_THRESHOLD}"
        else
          python scripts/check_accessibility.py docs --output accessibility-report.md --severity-threshold "${SEVERITY_THRESHOLD}" || true
        fi
    
    - name: Upload accessibility report
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: accessibility-report
        path: accessibility-report.md
        retention-days: 30
    
    - name: Comment PR with accessibility results
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Read the accessibility report
          let reportContent;
          try {
            reportContent = fs.readFileSync('accessibility-report.md', 'utf8');
          } catch (error) {
            console.log('No report file found');
            return;
          }
          
          // Extract key metrics from report
          const summaryMatch = reportContent.match(/## Summary\n([\s\S]*?)\n\n/);
          const errorsMatch = reportContent.match(/- \*\*Errors\*\*: (\d+)/);
          const warningsMatch = reportContent.match(/- \*\*Warnings\*\*: (\d+)/);
          const totalMatch = reportContent.match(/- \*\*Total Issues\*\*: (\d+)/);
          
          const errors = errorsMatch ? parseInt(errorsMatch[1]) : 0;
          const warnings = warningsMatch ? parseInt(warningsMatch[1]) : 0;
          const totalIssues = totalMatch ? parseInt(totalMatch[1]) : 0;
          
          const emoji = totalIssues === 0 ? '✅' : errors > 0 ? '❌' : '⚠️';
          
          const comment = `## ${emoji} Documentation Accessibility Check Results
          
          ${summaryMatch ? summaryMatch[1] : 'Summary not available'}
          
          ${totalIssues > 0 ? 
            `### 🔍 Issues Found
            
            Found ${totalIssues} accessibility issues (${errors} errors, ${warnings} warnings). Please review the [full report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.
            
            ### 🛠️ Common Fixes
            
            **Heading Structure Issues**: Most issues are likely heading hierarchy problems:
            - Ensure headings follow logical order (H1 → H2 → H3, don't skip levels)
            - Use only one H1 per document
            - Make heading text descriptive and unique
            
            **Image Accessibility**: 
            - Add descriptive alt text to all images
            - Avoid generic alt text like "image" or "screenshot"
            
            **Link Quality**:
            - Use descriptive link text instead of "click here" or "read more"
            - Ensure link text explains the destination
            
            **Table Accessibility**:
            - Add header rows to all tables
            - Use proper table structure with column headers
            
            ### 📚 Resources
            - [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
            - [Markdown Accessibility Best Practices](https://www.markdownguide.org/basic-syntax/)` :
            `### 🎉 No Accessibility Issues Found!
            
            The documentation meets accessibility standards. Great work! 🎉`
          }
          
          <details>
          <summary>View Sample Issues</summary>
          
          \`\`\`
          ${reportContent.slice(0, 3000)}${reportContent.length > 3000 ? '\n... (truncated, see full report in artifacts)' : ''}
          \`\`\`
          
          </details>
          `;
          
          // Find existing comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const existingComment = comments.find(comment => 
            comment.body.includes('Documentation Accessibility Check Results')
          );
          
          if (existingComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: comment
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }
    
    - name: Create issue for accessibility problems (scheduled run)
      if: github.event_name == 'schedule' && failure()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          let reportContent;
          try {
            reportContent = fs.readFileSync('accessibility-report.md', 'utf8');
          } catch (error) {
            console.log('No report file found');
            return;
          }
          
          const title = `♿ Accessibility Issues Found in Documentation - ${new Date().toISOString().split('T')[0]}`;
          
          const body = `## 📋 Weekly Accessibility Check Report
          
          The scheduled accessibility check has found issues in the documentation that need attention.
          
          ${reportContent}
          
          ### 🔧 Action Required
          
          Please review and fix the accessibility issues listed above. Priority areas:
          
          #### 🎯 High Priority (Errors)
          - **Heading Structure**: Fix heading hierarchy violations (H1 → H2 → H3)
          - **Missing Alt Text**: Add descriptive alt text to all images
          - **Table Headers**: Add proper headers to all tables
          
          #### ⚠️ Medium Priority (Warnings)
          - **Link Text Quality**: Improve non-descriptive link text
          - **Language Clarity**: Review potentially unclear language
          
          ### 📚 Resources
          - [Web Content Accessibility Guidelines (WCAG) 2.1](https://www.w3.org/WAI/WCAG21/quickref/)
          - [Markdown Accessibility Best Practices](https://www.markdownguide.org/basic-syntax/)
          - [Section 508 Compliance](https://www.section508.gov/)
          
          ### 🤖 Automation
          
          This issue was automatically created by the weekly accessibility check workflow.
          Run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          `;
          
          // Check if there's already an open issue for accessibility
          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'documentation,accessibility'
          });
          
          if (issues.length === 0) {
            // Create new issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['documentation', 'accessibility', 'automated', 'a11y']
            });
          } else {
            // Update existing issue
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issues[0].number,
              title: title,
              body: body
            });
          }
</document_content>
</document>

<document index="3">
<source>.github/workflows/ci.yml</source>
<document_content>
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  UV_CACHE_DIR: /tmp/.uv-cache

jobs:
  test:
    name: Test on ${{ matrix.os }} (Python ${{ matrix.python-version }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ["3.12"]
        include:
          # Test on older macOS with x64 architecture
          - os: macos-13
            python-version: "3.12"

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for git-based versioning

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install uv
      uses: astral-sh/setup-uv@v4
      with:
        enable-cache: true
        cache-dependency-glob: |
          **/pyproject.toml
          **/requirements*.txt

    - name: Cache uv dependencies
      uses: actions/cache@v4
      with:
        path: ${{ env.UV_CACHE_DIR }}
        key: uv-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/pyproject.toml') }}
        restore-keys: |
          uv-${{ runner.os }}-${{ matrix.python-version }}-

    - name: Install dependencies
      run: |
        uv venv
        uv pip install -e ".[dev]"
        uv pip install pytest pytest-cov pytest-timeout pytest-xdist

    - name: Install Playwright browsers
      run: |
        uv run playwright install chromium
        uv run playwright install-deps chromium

    - name: Run linting
      run: |
        uv run ruff check src tests
        uv run ruff format --check src tests

    - name: Run type checking
      if: matrix.os == 'ubuntu-latest'  # Only run on one platform to save time
      run: |
        uv pip install mypy types-requests
        uv run mypy src --ignore-missing-imports

    - name: Run tests with coverage
      run: |
        uv run pytest tests/ -v --cov=src/playwrightauthor --cov-report=xml --cov-report=term --timeout=120
      env:
        PYTHONPATH: ${{ github.workspace }}/src

    - name: Test Chrome finding functionality
      run: |
        uv run python -c "from playwrightauthor.browser.finder import find_chrome_executable; from playwrightauthor.utils.logger import configure; logger = configure(True); path = find_chrome_executable(logger); print(f'Chrome found: {path}')"

    - name: Upload coverage to Codecov
      if: matrix.os == 'ubuntu-latest' && matrix.python-version == '3.12'
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

  integration-test:
    name: Integration Test on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Install uv
      uses: astral-sh/setup-uv@v4
      with:
        enable-cache: true

    - name: Install package
      run: |
        uv venv
        uv pip install -e .

    - name: Test CLI commands
      run: |
        uv run playwrightauthor --help
        uv run playwrightauthor status --verbose

    - name: Test browser installation
      run: |
        uv run python -m playwrightauthor.browser_manager --verbose
      continue-on-error: true  # Browser might already be installed

  build:
    name: Build distribution
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build hatch hatchling hatch-vcs

    - name: Build package
      run: python -m build

    - name: Check package
      run: |
        pip install twine
        twine check dist/*

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: dist
        path: dist/

  release:
    name: Release
    needs: [test, integration-test, build]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - uses: actions/checkout@v4

    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        name: dist
        path: dist/

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        files: dist/*
        generate_release_notes: true
        draft: false
        prerelease: ${{ contains(github.ref, 'rc') || contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}

    - name: Publish to PyPI
      if: "!contains(github.ref, 'rc') && !contains(github.ref, 'beta') && !contains(github.ref, 'alpha')"
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
      run: |
        pip install twine
        twine upload dist/*

</document_content>
</document>

<document index="4">
<source>.github/workflows/docs-build.yml</source>
<document_content>
name: Build Documentation to docs/

on:
  push:
    branches: [ main ]
    paths:
      - 'src_docs/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'src_docs/**'

jobs:
  build-docs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install uv
        uses: astral-sh/setup-uv@v2
        with:
          version: "latest"

      - name: Install dependencies
        run: |
          uv venv
          source .venv/bin/activate
          uv pip install mkdocs mkdocs-material mkdocstrings[python]

      - name: Build documentation
        run: |
          source .venv/bin/activate
          cd src_docs
          mkdocs build --verbose --clean

      - name: Check for changes
        id: verify-changed-files
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit documentation changes
        if: steps.verify-changed-files.outputs.changed == 'true' && github.event_name == 'push'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add docs/
          git commit -m "docs: auto-build documentation from src_docs

          🤖 Generated with [Claude Code](https://claude.ai/code)

          Co-Authored-By: Claude <noreply@anthropic.com>" || exit 0

      - name: Push changes
        if: steps.verify-changed-files.outputs.changed == 'true' && github.event_name == 'push'
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.ref }}
</document_content>
</document>

<document index="5">
<source>.github/workflows/docs.yml</source>
<document_content>
name: Build and Deploy Documentation

on:
  push:
    branches: [ main ]
    paths:
      - 'src_docs/**'
      - '.github/workflows/docs.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'src_docs/**'
      - '.github/workflows/docs.yml'
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper git info

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install uv
        uses: astral-sh/setup-uv@v2
        with:
          version: "latest"

      - name: Install dependencies
        run: |
          uv venv
          source .venv/bin/activate
          uv pip install mkdocs mkdocs-material mkdocstrings[python]

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Build documentation
        run: |
          source .venv/bin/activate
          cd src_docs
          mkdocs build --verbose --clean

      - name: Setup Pages
        if: github.ref == 'refs/heads/main'
        uses: actions/configure-pages@v4

      - name: Upload artifact
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-pages-artifact@v3
        with:
          path: './docs'

  deploy:
    if: github.ref == 'refs/heads/main'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
</document_content>
</document>

<document index="6">
<source>.github/workflows/link-check.yml</source>
<document_content>
name: Documentation Link Check

on:
  push:
    branches: [ main ]
    paths: [ 'docs/**', 'README.md', 'CHANGELOG.md' ]
  pull_request:
    branches: [ main ]
    paths: [ 'docs/**', 'README.md', 'CHANGELOG.md' ]
  schedule:
    # Run weekly on Sundays at 06:00 UTC to catch external link rot
    - cron: '0 6 * * 0'
  workflow_dispatch:
    inputs:
      fail_on_error:
        description: 'Fail the workflow if broken links are found'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  link-check:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests
    
    - name: Make link checker executable
      run: chmod +x scripts/check_links.py
    
    - name: Run link checker
      id: link_check
      run: |
        # Set fail_on_error from workflow input or default to false for PR/push
        FAIL_ON_ERROR="${{ github.event.inputs.fail_on_error || 'false' }}"
        
        # For scheduled runs, always fail on error to catch link rot
        if [ "${{ github.event_name }}" = "schedule" ]; then
          FAIL_ON_ERROR="true"
        fi
        
        echo "Running link checker with fail_on_error=${FAIL_ON_ERROR}"
        
        if [ "${FAIL_ON_ERROR}" = "true" ]; then
          python scripts/check_links.py docs --timeout 10 --max-workers 10 --fail-on-error --output link-check-report.md
        else
          python scripts/check_links.py docs --timeout 10 --max-workers 10 --output link-check-report.md || true
        fi
    
    - name: Upload link check report
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: link-check-report
        path: link-check-report.md
        retention-days: 30
    
    - name: Comment PR with link check results
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Read the link check report
          let reportContent;
          try {
            reportContent = fs.readFileSync('link-check-report.md', 'utf8');
          } catch (error) {
            console.log('No report file found');
            return;
          }
          
          // Extract summary from report
          const summaryMatch = reportContent.match(/## Summary\n([\s\S]*?)\n\n/);
          const brokenLinksMatch = reportContent.match(/- \*\*Broken Links\*\*: (\d+)/);
          
          const brokenLinks = brokenLinksMatch ? parseInt(brokenLinksMatch[1]) : 0;
          const emoji = brokenLinks > 0 ? '❌' : '✅';
          
          const comment = `## ${emoji} Documentation Link Check Results
          
          ${summaryMatch ? summaryMatch[1] : 'Summary not available'}
          
          ${brokenLinks > 0 ? 
            `### 🔍 Issues Found
            
            Found ${brokenLinks} broken links. Please review the [full report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.
            
            Common fixes:
            - Update internal links to point to existing files
            - Fix malformed links (check for code snippets being interpreted as URLs)
            - Update external URLs that have moved or been removed
            - Add missing section anchors in target files` :
            `### 🎉 All Links Valid!
            
            No broken links found in the documentation.`
          }
          
          <details>
          <summary>View Full Report</summary>
          
          \`\`\`
          ${reportContent.slice(0, 8000)}${reportContent.length > 8000 ? '\n... (truncated, see full report in artifacts)' : ''}
          \`\`\`
          
          </details>
          `;
          
          // Find existing comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const existingComment = comments.find(comment => 
            comment.body.includes('Documentation Link Check Results')
          );
          
          if (existingComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: comment
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }
    
    - name: Create issue for broken links (scheduled run)
      if: github.event_name == 'schedule' && failure()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          let reportContent;
          try {
            reportContent = fs.readFileSync('link-check-report.md', 'utf8');
          } catch (error) {
            console.log('No report file found');
            return;
          }
          
          const title = `🔗 Broken Links Found in Documentation - ${new Date().toISOString().split('T')[0]}`;
          
          const body = `## 📋 Weekly Link Check Report
          
          The scheduled link check has found broken links in the documentation.
          
          ${reportContent}
          
          ### 🔧 Action Required
          
          Please review and fix the broken links listed above. Common fixes include:
          
          - Update internal links to point to existing files
          - Fix malformed links (check for code snippets being interpreted as URLs)
          - Update external URLs that have moved or been removed
          - Add missing section anchors in target files
          
          ### 🤖 Automation
          
          This issue was automatically created by the weekly link check workflow.
          Run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          `;
          
          // Check if there's already an open issue for broken links
          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'documentation,broken-links'
          });
          
          if (issues.length === 0) {
            // Create new issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['documentation', 'broken-links', 'automated']
            });
          } else {
            // Update existing issue
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issues[0].number,
              title: title,
              body: body
            });
          }
</document_content>
</document>

<document index="7">
<source>.gitignore</source>
<document_content>

__marimo__/
__pycache__/
__pypackages__/
.abstra/
.cache
.coverage
.coverage.*
.cursorignore
.cursorindexingignore
.dmypy.json
.DS_Store
.eggs/
.env
.envrc
.hypothesis/
.installed.cfg
.ipynb_checkpoints
.mypy_cache/
.nox/
.pdm-build/
.pdm-python
.pixi
.pybuilder/
.pypirc
.pyre/
.pytest_cache/
.Python
.pytype/
.ropeproject
.ruff_cache/
.scrapy
.spyderproject
.spyproject
.tox/
.venv
.webassets-cache
*.cover
*.egg
*.egg-info/
*.log
*.manifest
*.mo
*.pot
*.py.cover
*.py[codz]
*.sage.py
*.so
*.spec
*$py.class
/site
uv.lock
build/
celerybeat-schedule
celerybeat.pid
cover/
coverage.xml
cython_debug/
db.sqlite3
db.sqlite3-journal
develop-eggs/
dist/
dmypy.json
docs/_build/
downloads/
eggs/
env.bak/
env/
ENV/
htmlcov/
instance/
ipython_config.py
lib/
lib64/
local_settings.py
MANIFEST
marimo/_lsp/
marimo/_static/
nosetests.xml
parts/
pip-delete-this-directory.txt
pip-log.txt
profile_default/
sdist/
share/python-wheels/
src/playwrightauthor/_version.py
target/
var/
venv.bak/
venv/
wheels/
</document_content>
</document>

<document index="8">
<source>AGENTS.md</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

PlaywrightAuthor is a convenience package for Microsoft Playwright that handles browser automation setup. It automatically manages Chrome for Testing installation, authentication with user profiles, and provides ready-to-use Browser objects through simple context managers.

## 2. Key Architecture

**Core Design Pattern**: The library follows a context manager pattern with `Browser()` and `AsyncBrowser()` classes that return authenticated Playwright browser objects.

**Main Components** (planned structure):
- `playwrightauthor/author.py` - Core Browser/AsyncBrowser classes (main API)
- `playwrightauthor/browser_manager.py` - Chrome installation/process management 
- `playwrightauthor/onboarding.py` - User guidance for authentication
- `playwrightauthor/cli.py` - Fire-powered CLI interface
- `playwrightauthor/utils/` - Logger and cross-platform path utilities

**Current State**: The project is in early development. The main implementation exists as a legacy scraper in `old/google_docs_scraper_simple.py` that demonstrates the core concept of connecting to an existing Chrome debug session.

## 3. Development Commands

### 3.1. Environment Setup
```bash
# Initial setup with uv
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add playwright rich fire loguru platformdirs requests psutil
```

### 3.2. Code Quality Pipeline
After any Python changes, run:
```bash
fd -e py -x uvx autoflake -i {}; \
fd -e py -x uvx pyupgrade --py312-plus {}; \
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
python -m pytest
```

### 3.3. Testing
- Run tests: `python -m pytest`
- Tests are located in `tests/` directory
- Current tests may be integration tests requiring live Chrome instance

### 3.4. CLI Usage
Once implemented:
```bash
python -m playwrightauthor status  # Check browser status
```

## 4. Code Standards

- **File headers**: Every Python file should include a `this_file:` comment with the relative path
- **Dependencies**: Use uv script headers with `# /// script` blocks
- **Type hints**: Use modern Python type hints (list, dict, | for unions)
- **Logging**: Use loguru with verbose flag support
- **CLI**: Use Fire for command-line interfaces with Rich for output

## 5. Browser Management Strategy

The core technical challenge is reliably managing Chrome for Testing:

1. **Detection**: Check if Chrome is running with `--remote-debugging-port=9222`
2. **Installation**: Prefer `npx puppeteer browsers install`, fallback to LKGV JSON downloads
3. **Process Management**: Kill non-debug instances, launch with persistent user-data-dir
4. **Connection**: Use Playwright's `connect_over_cdp()` to attach to debug session

## 6. Project Workflow

The project follows a documentation-driven development approach:
1. Read `WORK.md` and `PLAN.md` before making changes
2. Update documentation files after implementation
3. Use "Wait, but" reflection methodology for code review
4. Maintain minimal, self-contained commits

## 7. Dependencies

Core runtime dependencies:
- `playwright` - Browser automation
- `rich` - Terminal output formatting  
- `fire` - CLI generation
- `loguru` - Logging
- `platformdirs` - Cross-platform paths
- `requests` - HTTP client for downloads
- `psutil` - Process management

# Software Development Rules

## 8. Pre-Work Preparation

### 8.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 8.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 9. General Coding Principles

### 9.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 9.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 10. Tool Usage (When Available)

### 10.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 11. File Management

### 11.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 12. Python-Specific Guidelines

### 12.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 12.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 12.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 12.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 13. Post-Work Activities

### 13.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 13.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 14. Work Methodology

### 14.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 14.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 15. Special Commands

### 15.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 15.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 15.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 16. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 17. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate

**TL;DR for PlaywrightAuthor Codebase**

**1. Core Purpose & Value Proposition:**
PlaywrightAuthor is a Python convenience library built on top of Microsoft Playwright. Its primary goal is to eliminate the boilerplate setup for browser automation. It automatically finds or installs a "Chrome for Testing" instance, manages its process (ensuring it runs in debug mode), handles user authentication by reusing a persistent profile, and provides a ready-to-use, authenticated Playwright `Browser` object within a simple context manager (`with Browser() as browser:`).

**2. Key Architectural Components:**
*   **Main API (`author.py`):** Exposes the core `Browser()` and `AsyncBrowser()` context managers, which are the main entry points for the user.
*   **Browser Management (`browser/` & `browser_manager.py`):** This is the technical core of the library. It's a modular system responsible for:
    *   `finder.py`: Robustly discovering the Chrome executable across macOS, Windows, and Linux, checking over 20 standard and non-standard locations per platform.
    *   `installer.py`: Downloading the correct Chrome for Testing build using official JSON endpoints, with progress bars and SHA256 validation.
    *   `launcher.py`: Launching the Chrome process with the remote debugging port (`--remote-debugging-port=9222`).
    *   `process.py`: Managing the Chrome process, including gracefully killing existing non-debug instances and verifying the new process is ready.
*   **User Experience (`onboarding.py`, `cli.py`):**
    *   `onboarding.py`: If the user is not logged into necessary services, it serves a local HTML page (`templates/onboarding.html`) to guide them through the login process.
    *   `cli.py`: A `fire`-powered command-line interface for status checks (`status`) and cache clearing (`clear-cache`), with `rich` for formatted output.
*   **Configuration & State (`config.py`, `state_manager.py`):** Handles library configuration (e.g., timeouts, paths) and persists the state of the browser (e.g., installation path, version) to avoid redundant work.
*   **Utilities (`utils/`):** Cross-platform path management (`paths.py`) and `loguru`-based logging (`logger.py`).

**3. Development & Quality:**
*   **Workflow:** The project is documentation-driven, using `PLAN.md`, `TODO.md`, and `WORK.md` to guide development. It emphasizes iterative, minimal commits.
*   **Tooling:** Uses `uv` for environment and dependency management. The build system is `hatch` with `hatch-vcs` for versioning based on git tags.
*   **CI/CD (`.github/workflows/ci.yml`):** A comprehensive GitHub Actions pipeline tests the library on Ubuntu, Windows, and macOS. It runs linting (`ruff`), type checking (`mypy`), and a full `pytest` suite with coverage reporting to Codecov.
*   **Code Quality:** The codebase is fully type-hinted. A strict quality pipeline (`ruff`, `autoflake`, `pyupgrade`) is enforced and documented. Every file includes a `this_file:` comment for easy path reference.

**4. Current Status & Roadmap:**
The project has completed its initial phases focused on robustness, error handling, and cross-platform compatibility. It is now in the "Elegance and Performance" phase, which involves refactoring the architecture (e.g., separating state and config management), optimizing performance (e.g., lazy loading), and adding advanced features like browser profile management. Future phases will focus on improving the CLI, documentation, and user experience.

</document_content>
</document>

<document index="9">
<source>CHANGELOG.md</source>
<document_content>
# Changelog

All notable changes to this project will be documented in this file.

## [Unreleased]

### Added

#### 🚀 Chrome for Testing Exclusivity & Session Reuse ✅ MAJOR ENHANCEMENT

- **Exclusive Chrome for Testing Support**:
  - PlaywrightAuthor now exclusively uses Chrome for Testing (not regular Chrome)
  - Google has disabled CDP automation with user profiles in regular Chrome
  - Chrome for Testing is the official Google build designed for automation
  - Updated all browser discovery, installation, and launch logic to reject regular Chrome
  - Clear error messages explain why Chrome for Testing is required
  - Comprehensive permission fixes for Chrome for Testing on macOS (all helper executables)

- **Session Reuse Workflow**:
  - New `get_page()` method on Browser/AsyncBrowser classes for session reuse
  - Reuses existing browser contexts and pages instead of creating new ones
  - Maintains authenticated sessions across script runs without re-login
  - Intelligent page selection (skips extension pages, reuses existing tabs)
  - Perfect for workflows that require persistent authentication state

- **Developer Workflow Enhancement**:
  - New `playwrightauthor browse` CLI command launches Chrome for Testing in CDP mode
  - Browser stays running after command exits for other scripts to connect
  - Detects if Chrome is already running to avoid multiple instances
  - Enables manual login once, then automated scripts can reuse the session
  - Example workflow:
    1. Run `playwrightauthor browse` to launch browser
    2. Manually log into services (Gmail, GitHub, LinkedIn, etc.)
    3. Run automation scripts that use `browser.get_page()` to reuse sessions

### Fixed

- **Chrome Process Management** (2025-08-06):
  - Now automatically kills Chrome for Testing processes running without debug port and relaunches them
  - Removed the requirement for users to manually close Chrome when it's running without debugging
  - `ensure_browser()` now properly launches Chrome after killing non-debug instances
  - Fixed `launch_chrome()` and `launch_chrome_with_retry()` to properly return the Chrome process
  - This ensures automation always works without manual intervention and browser status can be verified

- **Chrome for Testing Installation**:
  - Fixed critical issue where Chrome for Testing lacked execute permissions after download
  - Added comprehensive permission setting for all executables in Chrome.app bundle
  - Fixed helper executables (chrome_crashpad_handler, etc.) permission issues
  - Resolved "GPU process isn't usable" crashes on macOS

### Changed

- **Browser Discovery**: Removed all regular Chrome paths from finder.py
- **Process Management**: Only accepts Chrome for Testing processes, rejects regular Chrome
- **Error Messages**: Updated throughout to explain Chrome for Testing requirement
- **Examples**: Updated to use `browser.get_page()` for session reuse

#### 📚 Documentation Quality Assurance ✅ COMPLETED

- **Doctest Integration**:
  - Complete doctest system for all code examples in docstrings
  - 29 passing doctests across author.py (6), config.py (23), cli.py (0), and repl modules
  - Safe, non-executing examples for browser automation code using code-block format
  - Automated example verification integrated with pytest test suite
  - Proper separation of executable tests vs documentation examples
  - Created dedicated `tests/test_doctests.py` with pytest integration
  - Configured doctest with proper flags for reliable example verification
  - Smart example management distinguishing executable tests from documentation

#### 🎯 Visual Documentation & Architecture Excellence ✅ COMPLETED

- **Comprehensive Authentication Guides**:
  - Step-by-step authentication guides for Gmail, GitHub, LinkedIn with detailed code examples
  - Service-specific troubleshooting with common issues and solutions
  - Interactive troubleshooting flowcharts using Mermaid diagrams
  - Security best practices and monitoring guidance for each service

- **Complete Architecture Documentation**:
  - Detailed browser lifecycle management flow diagrams with Mermaid
  - Component interaction architecture visualization with sequence diagrams
  - Error handling and recovery workflow charts
  - Complete visual documentation in `docs/architecture/` with enterprise-level detail

#### 🖥️ Platform-Specific Documentation Excellence ✅ COMPLETED

- **macOS Platform Guide**:
  - Complete M1/Intel architecture differences with detection and optimization
  - Comprehensive security permissions guide (Accessibility, Screen Recording, Full Disk Access)
  - Homebrew integration for both Intel and Apple Silicon architectures
  - Gatekeeper and code signing solutions with programmatic handling
  - Performance optimization with macOS-specific Chrome flags

- **Windows Platform Guide**:
  - UAC considerations with programmatic elevation and admin privilege checking
  - Comprehensive antivirus whitelisting (Windows Defender exclusions management)
  - PowerShell execution policies with script integration and policy management
  - Multi-monitor and high DPI support with Windows-specific optimizations
  - Corporate proxy configuration and Windows services integration

- **Linux Platform Guide**:
  - Distribution-specific Chrome installation for Ubuntu/Debian, Fedora/CentOS/RHEL, Arch, Alpine
  - Comprehensive Docker configuration with multi-stage builds and Kubernetes deployment
  - Display server configuration (X11, Wayland, Xvfb) with virtual display management
  - Security configuration (SELinux, AppArmor) with custom policies
  - Performance optimization with Linux-specific Chrome flags and resource management

#### ⚡ Performance Optimization Documentation ✅ COMPLETED

- **Comprehensive Performance Guide**:
  - Browser resource optimization strategies with memory, CPU, and network optimization
  - Advanced memory management with leak detection and monitoring systems
  - Connection pooling with browser pools and page recycling strategies
  - Real-time performance monitoring with dashboards and profiling tools
  - Performance debugging with memory leak detection and bottleneck analysis

#### 🔗 Documentation Link Checking System ✅ COMPLETED

- **Automated Link Validation**:
  - Comprehensive link checker script (`scripts/check_links.py`) with full markdown support
  - Validates both internal links (files and sections) and external URLs
  - Concurrent processing with configurable workers and timeout settings
  - Detailed reporting with line numbers and specific error messages
  - Found and catalogued 51 broken links across 18 documentation files

- **CI/CD Integration**:
  - GitHub Actions workflow (`.github/workflows/link-check.yml`) for automated checking
  - PR integration with intelligent commenting and result summaries
  - Weekly scheduled runs to catch external link rot
  - Automatic issue creation for broken links with actionable guidance
  - Artifact storage and professional reporting with truncation handling

- **Professional Features**:
  - HTTP retry logic with proper User-Agent headers
  - Caching system to avoid duplicate external URL checks
  - JSON output support for programmatic integration
  - Configurable failure behavior for different CI scenarios
  - Comprehensive error categorization and fix suggestions

#### ♿ Documentation Accessibility Testing System ✅ COMPLETED

- **Comprehensive Accessibility Validation**:
  - Advanced accessibility checker script (`scripts/check_accessibility.py`) with WCAG 2.1 compliance
  - Multi-category analysis: heading structure, image alt text, link quality, table accessibility
  - Language clarity checking and list structure validation
  - Professional reporting with specific WCAG guideline references
  - Found and catalogued 118 accessibility violations across 18 documentation files

- **WCAG 2.1 & Section 508 Compliance**:
  - Heading hierarchy validation (H1→H2→H3 structure enforcement)
  - Image alt text quality assessment with generic text detection
  - Link text accessibility validation (eliminates "click here" patterns)
  - Table header structure validation for screen reader compatibility
  - Language clarity analysis for cognitive accessibility

- **Enterprise CI/CD Integration**:
  - GitHub Actions workflow (`.github/workflows/accessibility-check.yml`) for automated testing
  - PR integration with detailed accessibility violation reports and remediation guidance
  - Weekly scheduled compliance monitoring with automatic issue creation
  - Configurable severity thresholds (error/warning/info levels)
  - Professional reporting with WCAG 2.1 Success Criteria mapping

- **Professional Quality Assurance**:
  - 6 major accessibility categories validated automatically
  - Severity-based issue classification with actionable recommendations
  - CI/CD artifact storage with 30-day retention
  - JSON output support for programmatic accessibility monitoring
  - Comprehensive remediation guidance with specific fix instructions

### Planned Features
- Enhanced documentation with visual guides and workflow diagrams
- Plugin architecture for extensibility
- Advanced browser profile management with encryption
- Visual documentation and platform-specific guides

## [1.0.10] - 2025-08-04

### Added

#### 🔍 Production Monitoring & Automatic Recovery ✅ MAJOR MILESTONE

- **Browser Health Monitoring System**:
  - Continuous health monitoring with configurable check intervals (5-300 seconds)
  - Chrome DevTools Protocol (CDP) connection health checks
  - Browser process lifecycle monitoring with crash detection
  - Performance metrics collection (CPU, memory, response times)
  - Background monitoring threads for sync and async browser instances

- **Automatic Crash Recovery**:
  - Smart browser restart logic with configurable retry limits
  - Exponential backoff for restart attempts
  - Graceful connection cleanup before restart
  - Process-aware recovery that detects zombie processes
  - Maintains profile and authentication state across restarts

- **Comprehensive Monitoring Configuration**:
  - New `MonitoringConfig` class with full control over monitoring behavior
  - Enable/disable monitoring, crash recovery, and metrics collection
  - Configurable check intervals and restart limits
  - Environment variable support for all monitoring settings
  - Integration with existing configuration management system

- **Production Metrics & Diagnostics**:
  - Real-time performance metrics (memory usage, CPU usage, page count)
  - CDP response time tracking for connection health
  - Detailed crash and restart statistics
  - Metrics retention with configurable history limits
  - Session-end metrics summary in logs

### Changed

- **Enhanced Browser Classes**: Both `Browser` and `AsyncBrowser` now include automatic monitoring
- **Resource Management**: Improved cleanup during crash recovery scenarios
- **Configuration System**: Extended to support comprehensive monitoring settings

### Technical Improvements

- **Enterprise-Grade Reliability**: Automatic browser crash detection and recovery
- **Performance Observability**: Real-time metrics for production environments
- **Zero-Overhead Design**: Monitoring can be disabled for low-resource scenarios
- **Thread-Safe Architecture**: Proper threading and asyncio integration

## [1.0.9] - 2025-08-04

### Added

#### 🎯 Smart Error Recovery & User Guidance

- **Enhanced Exception System**:
  - Base `PlaywrightAuthorError` class now includes "Did you mean...?" suggestions
  - All exceptions provide actionable solutions with specific commands to run
  - Context-aware error messages with pattern matching for common issues
  - Help links to relevant documentation sections
  - Professional error formatting with emojis for better readability

- **New Exception Types**:
  - `ConnectionError` - Specific guidance for Chrome connection failures
  - `ProfileError` - Clear messages for profile management issues
  - `CLIError` - Command-line errors with fuzzy-matched suggestions

- **Improved Error Handling**:
  - `browser_manager.py` - Enhanced error messages with full context and suggestions
  - `connection.py` - Replaced generic errors with specific `ConnectionError` exceptions
  - Pattern-based error detection provides targeted troubleshooting guidance
  - Exponential backoff retry logic with detailed failure reporting

- **Enhanced CLI Interface**:
  - **Smart Command Suggestions**: Fuzzy matching for mistyped commands with "Did you mean...?" suggestions
  - **Health Check Command**: Comprehensive `health` command validates entire setup
    - Chrome installation verification
    - Connection health testing with response time monitoring
    - Profile setup validation
    - Browser automation capability testing
    - System compatibility checks
    - Actionable feedback with specific fix commands
  - **Interactive Setup Wizard**: New `setup` command provides guided first-time user setup
    - Step-by-step browser validation and configuration
    - Platform-specific setup recommendations (macOS, Windows, Linux)
    - Service-specific authentication guidance (Google, GitHub, LinkedIn, etc.)
    - Real-time issue detection and troubleshooting
    - Authentication completion validation with success indicators
  - **Professional Error Handling**: CLI errors use consistent formatting with helpful guidance

- **Enhanced Onboarding System**:
  - **Intelligent Issue Detection**: Auto-detects common authentication and setup problems
    - JavaScript errors that block authentication flows
    - Cookie restrictions and browser permission issues
    - Popup blockers interfering with OAuth processes
    - Network connectivity and third-party cookie problems
    - Platform-specific permission requirements
  - **Service-Specific Guidance**: Contextual help for popular authentication services
    - Gmail/Google with 2FA setup instructions
    - GitHub with personal access token recommendations
    - LinkedIn, Microsoft Office 365, Facebook, Twitter/X
    - Real-time service detection based on current page URL
  - **Enhanced Monitoring**: Proactive setup guidance with periodic health checks
    - Real-time authentication activity detection
    - Contextual troubleshooting based on detected issues
    - Service-specific guidance when users navigate to login pages
    - Comprehensive setup reports with actionable recommendations

### Changed

- **Error Message Quality**: Transformed from technical errors to user-friendly guidance
- **Connection Handling**: All connection failures now provide specific troubleshooting steps
- **Developer Experience**: Error messages guide users to exact commands for resolution
- **CLI Usability**: Enhanced command-line interface with intelligent error recovery and comprehensive health validation

## [1.0.8] - 2025-08-04

### Added

#### 📚 Comprehensive Documentation Excellence ✅ MAJOR MILESTONE

- **World-Class API Documentation**:
  - Complete `Browser` class documentation (3,000+ chars) with comprehensive usage examples
  - Realistic authentication workflows showing login persistence across script runs
  - Common issues troubleshooting section with macOS permissions and connection problems
  - Context manager behavior documentation with resource cleanup explanations
  - Multiple profile management examples for work/personal account separation

- **Complete `AsyncBrowser` Documentation**:
  - Detailed async patterns documentation (3,800+ chars) with concurrent automation examples
  - Performance considerations and best practices for high-throughput scenarios
  - FastAPI integration example for web scraping services
  - Async vs sync decision guide with use case recommendations
  - Concurrent profile management for multiple account automation

- **Professional CLI Documentation**:
  - Enhanced CLI class with comprehensive usage overview and command examples
  - Detailed `status()` command documentation with troubleshooting output examples
  - Complete `clear_cache()` documentation with safety warnings and use cases
  - Comprehensive `profile()` command documentation with table/JSON output examples
  - Example outputs for all commands showing success and error scenarios

#### 🎯 Essential Usage Patterns & User Experience

- **"Common Patterns" Section in README**:
  - Authentication workflow demonstrating persistent login sessions
  - Production-ready error handling with exponential backoff retry patterns
  - Multi-account profile management with practical email checking example
  - Interactive REPL development workflow with live debugging examples
  - High-performance async automation with concurrent page processing
  - Comprehensive quick reference guide with most common commands and patterns

- **Real-World Integration Examples**:
  - Authentication persistence across script runs (first-time setup vs subsequent runs)
  - Robust error handling for production automation with timeout management
  - Multiple account management with profile isolation
  - Concurrent scraping with rate limiting and resource management
  - CLI command integration within REPL for seamless development

### Changed

- **Documentation Quality**: Transformed from basic API references to comprehensive user guides
- **Developer Experience**: Added practical examples for every major use case and common issue
- **Onboarding**: New users can now master PlaywrightAuthor in minutes with guided examples
- **Error Resolution**: Clear troubleshooting guidance integrated throughout documentation

### Technical Improvements

- **Self-Documenting Code**: All public APIs now include realistic usage examples
- **User-Centric Design**: Documentation focuses on practical use cases rather than technical details
- **Production Readiness**: Error handling patterns and best practices prominently featured
- **Interactive Development**: REPL usage patterns clearly documented for rapid prototyping

## [1.0.7] - 2025-08-04

### Added

#### 🚀 Interactive REPL System ✅ MAJOR MILESTONE
- **Complete REPL Workbench Implementation**:
  - Interactive REPL mode accessible via `playwrightauthor repl` command
  - Advanced tab completion for Playwright APIs, CLI commands, and Python keywords
  - Persistent command history across sessions stored in user config directory
  - Rich syntax highlighting and error handling with traceback display
  - Seamless CLI command integration within REPL using `!` prefix
  - Real-time Python code evaluation with browser context management
  - Professional welcome banner and contextual help system

- **Technical Architecture**:
  - Complete `src/playwrightauthor/repl/` module with production-ready code
  - `engine.py`: Core REPL loop with prompt_toolkit integration (217 lines)
  - `completion.py`: Context-aware completion engine for Playwright objects
  - Integration with existing CLI infrastructure for seamless command execution
  - Support for both synchronous and asynchronous browser operations

### Changed
- **Dependencies**: Added `prompt_toolkit>=3.0.0` for advanced REPL functionality
- **CLI Interface**: Enhanced with interactive `repl` command for live browser automation
- **Type Annotations**: Improved forward reference handling in author.py for better compatibility

### Technical Improvements
- **Code Quality**: All REPL code passes ruff linting and formatting standards
- **Developer Experience**: Transformed PlaywrightAuthor into interactive development platform
- **Accessibility**: REPL provides immediate feedback and exploration capabilities for Playwright APIs

## [1.0.6] - 2025-08-04

### Added
- **Enhanced Documentation & User Experience**:
  - Modernized README.md with structured feature sections and emoji-based organization
  - Updated installation instructions with `pip install playwrightauthor` 
  - Comprehensive CLI documentation covering all available commands
  - Current package architecture overview with detailed module descriptions
  - Key components section explaining core API and browser management
  - Professional feature presentation showcasing performance and reliability

### Changed
- **Documentation Structure**: 
  - Replaced outdated file tree examples with current `src/` layout architecture
  - Streamlined README.md by removing extensive code examples in favor of practical key components
  - Updated PLAN.md and TODO.md with refined priorities for 100% package completion
  - Improved user-facing documentation for better adoption and onboarding

### Removed
- Detailed internal code examples from README.md (moved focus to practical usage)
- Outdated package layout documentation

## [1.0.5] - 2025-08-04

### Added

#### Phase 4: User Experience & CLI Enhancements ✅ COMPLETED
- **Enhanced CLI Interface**:
  - Complete profile management with `profile` command (list, show, create, delete, clear)
  - Configuration viewing and management with `config` command  
  - Comprehensive diagnostic checks with `diagnose` command including connection health
  - Version and system information with `version` command
  - Multiple output formats support (Rich tables, JSON)
  - Color-coded status messages and professional formatting

#### Phase 3: Elegance and Performance ✅ COMPLETED
- **Core Architecture Refactoring** (COMPLETED):
  - Complete state management system with `state_manager.py` and `BrowserState` TypedDict
  - JSON-based state persistence to user config directory with atomic writes
  - State validation and migration system for version compatibility
  - Comprehensive configuration management with `config.py` and dataclass-based structure
  - Environment variable support with `PLAYWRIGHTAUTHOR_*` prefix
  - Configuration validation with proper error handling
  - Browser module reorganization with proper `__all__` exports and typing
  
- **Performance Optimization** (COMPLETED):
  - Lazy loading system for Playwright imports with `lazy_imports.py`
  - Chrome executable path caching in state manager  
  - Lazy browser initialization patterns in context managers
  - Lazy loading for psutil and requests modules
  - Connection health checks with comprehensive CDP diagnostics
  - Connection retry logic with exponential backoff in Browser classes
  - Enhanced debugging info and error messages for connection issues
  - New `connection.py` module with `ConnectionHealthChecker` class

#### Phase 4: User Experience & CLI Enhancements ✅ MAJOR PROGRESS
- **Enhanced CLI Interface** (MOSTLY COMPLETED):
  - Complete profile management with `profile` command (list, show, create, delete, clear)
  - Configuration viewing and management with `config` command
  - Comprehensive diagnostic checks with `diagnose` command including connection health
  - Version and system information with `version` command
  - Multiple output formats support (Rich tables, JSON)
  - Color-coded status messages and professional formatting

#### Phase 1: Robustness and Error Handling ✅
- **Enhanced Exception System**: Added specialized exception classes (`BrowserInstallationError`, `BrowserLaunchError`, `ProcessKillError`, `NetworkError`, `TimeoutError`)
- **Retry Mechanisms**: Implemented configurable retry logic for network requests and browser operations
- **Process Management**: Enhanced process killing with graceful termination → force kill fallback
- **Launch Verification**: Added `wait_for_process_start()` to ensure Chrome debug port availability
- **Download Progress**: Real-time progress reporting with SHA256 integrity checking
- **Smart Login Detection**: Detects authentication via cookies, localStorage, and sessionStorage
- **Enhanced Onboarding UI**: Professional step-by-step interface with animated status indicators
- **Comprehensive Utils Tests**: 17 new test cases for paths and logging modules

#### Phase 2: Cross-Platform Compatibility ✅
- **Enhanced Chrome Finder**: Platform-specific Chrome discovery with 20+ locations per platform
  - Windows: 32/64-bit support, registry lookup, user installations
  - Linux: Snap, Flatpak, distribution-specific paths
  - macOS: ARM64/x64 support, Homebrew, user applications
- **CI/CD Pipeline**: GitHub Actions workflow for multi-platform testing
  - Matrix testing on Ubuntu, Windows, macOS (latest + macOS-13)
  - Automated linting, type checking, and coverage reporting
  - Build and release automation with PyPI publishing
- **Platform-Specific Tests**: 15+ test cases with mock system calls
- **Integration Tests**: 25+ comprehensive tests covering all major scenarios
- **Chrome Version Detection**: `get_chrome_version()` function for compatibility checks

### Changed

- **Project Structure**: Migrated to modern `src/` layout
- **Build System**: Switched from setuptools to hatch + hatch-vcs for git-tagged versioning
- **Error Handling**: All operations now have proper timeout and retry logic
- **Browser Management**: Refactored into separate modules (finder, installer, launcher, process)
- **Logging**: Enhanced debug logging throughout with detailed path checking

### Fixed

- **Process Management**: Fixed unreliable process killing across platforms
- **Network Operations**: Added proper timeout handling for all HTTP requests
- **Path Detection**: Fixed Chrome executable finding on all platforms
- **Error Messages**: Improved user-facing error messages with actionable guidance

### Technical Improvements

- **Code Quality**: Configured ruff for linting and formatting
- **Type Safety**: Added type hints throughout the codebase
- **Test Coverage**: Significantly improved with unit, integration, and platform tests
- **Performance**: Optimized Chrome discovery with lazy path generation
- **Documentation**: Updated all file path references for new structure

## [1.0.4] - 2025-08-04

### Added
- Enhanced project documentation with AI assistant integration guides
- Comprehensive codebase analysis tools (`llms.txt`, `llms_tldr.txt`)
- Multi-assistant development workflows (CLAUDE.md, GEMINI.md, AGENTS.md)

## [1.0.3] - 2025-08-04

### Added
- Production-ready browser management system
- Comprehensive test suite with platform-specific testing
- Enhanced error handling and retry mechanisms

## [1.0.2] - 2025-08-04

### Added
- State management and configuration systems
- Lazy loading optimizations for improved performance
- Connection health monitoring and diagnostics

## [1.0.1] - 2025-08-04

### Added
- Complete migration to `src/` project layout
- Enhanced browser module organization
- Cross-platform compatibility improvements

## [1.0.0] - 2025-08-04

### Added
- First stable release of PlaywrightAuthor
- Complete implementation of all planned Phase 1-3 features
- Production-ready browser automation with authentication

## [0.1.0] - 2025-08-03

### Added

- Initial implementation of the `playwrightauthor` library.
- `Browser` and `AsyncBrowser` context managers to provide authenticated Playwright browser instances.
- `browser_manager.py` to handle the automatic installation and launching of Chrome for Testing.
- `cli.py` with a `status` command to check the browser's state.
- `onboarding.py` and `templates/onboarding.html` for first-time user guidance.
- Utility modules for logging (`logger.py`) and path management (`paths.py`).
- `pyproject.toml` for project metadata and dependency management.
- Basic smoke tests for the `Browser` and `AsyncBrowser` classes.
- Comprehensive `PLAN.md` and `TODO.md` for development tracking.

</document_content>
</document>

<document index="10">
<source>CLAUDE.md</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

PlaywrightAuthor is a convenience package for Microsoft Playwright that handles browser automation setup. It automatically manages Chrome for Testing installation, authentication with user profiles, and provides ready-to-use Browser objects through simple context managers.

## 2. Key Architecture

**Core Design Pattern**: The library follows a context manager pattern with `Browser()` and `AsyncBrowser()` classes that return authenticated Playwright browser objects.

**Main Components** (planned structure):
- `playwrightauthor/author.py` - Core Browser/AsyncBrowser classes (main API)
- `playwrightauthor/browser_manager.py` - Chrome installation/process management 
- `playwrightauthor/onboarding.py` - User guidance for authentication
- `playwrightauthor/cli.py` - Fire-powered CLI interface
- `playwrightauthor/utils/` - Logger and cross-platform path utilities

**Current State**: The project is in early development. The main implementation exists as a legacy scraper in `old/google_docs_scraper_simple.py` that demonstrates the core concept of connecting to an existing Chrome debug session.

## 3. Development Commands

### 3.1. Environment Setup
```bash
# Initial setup with uv
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add playwright rich fire loguru platformdirs requests psutil
```

### 3.2. Code Quality Pipeline
After any Python changes, run:
```bash
fd -e py -x uvx autoflake -i {}; \
fd -e py -x uvx pyupgrade --py312-plus {}; \
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
python -m pytest
```

### 3.3. Testing
- Run tests: `python -m pytest`
- Tests are located in `tests/` directory
- Current tests may be integration tests requiring live Chrome instance

### 3.4. CLI Usage
Once implemented:
```bash
python -m playwrightauthor status  # Check browser status
```

## 4. Code Standards

- **File headers**: Every Python file should include a `this_file:` comment with the relative path
- **Dependencies**: Use uv script headers with `# /// script` blocks
- **Type hints**: Use modern Python type hints (list, dict, | for unions)
- **Logging**: Use loguru with verbose flag support
- **CLI**: Use Fire for command-line interfaces with Rich for output

## 5. Browser Management Strategy

The core technical challenge is reliably managing Chrome for Testing:

1. **Detection**: Check if Chrome is running with `--remote-debugging-port=9222`
2. **Installation**: Prefer `npx puppeteer browsers install`, fallback to LKGV JSON downloads
3. **Process Management**: Kill non-debug instances, launch with persistent user-data-dir
4. **Connection**: Use Playwright's `connect_over_cdp()` to attach to debug session

## 6. Project Workflow

The project follows a documentation-driven development approach:
1. Read `WORK.md` and `PLAN.md` before making changes
2. Update documentation files after implementation
3. Use "Wait, but" reflection methodology for code review
4. Maintain minimal, self-contained commits

## 7. Dependencies

Core runtime dependencies:
- `playwright` - Browser automation
- `rich` - Terminal output formatting  
- `fire` - CLI generation
- `loguru` - Logging
- `platformdirs` - Cross-platform paths
- `requests` - HTTP client for downloads
- `psutil` - Process management

# Software Development Rules

## 8. Pre-Work Preparation

### 8.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 8.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 9. General Coding Principles

### 9.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 9.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 10. Tool Usage (When Available)

### 10.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 11. File Management

### 11.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 12. Python-Specific Guidelines

### 12.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 12.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 12.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 12.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 13. Post-Work Activities

### 13.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 13.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 14. Work Methodology

### 14.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 14.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 15. Special Commands

### 15.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 15.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 15.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 16. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 17. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate

**TL;DR for PlaywrightAuthor Codebase**

**1. Core Purpose & Value Proposition:**
PlaywrightAuthor is a Python convenience library built on top of Microsoft Playwright. Its primary goal is to eliminate the boilerplate setup for browser automation. It automatically finds or installs a "Chrome for Testing" instance, manages its process (ensuring it runs in debug mode), handles user authentication by reusing a persistent profile, and provides a ready-to-use, authenticated Playwright `Browser` object within a simple context manager (`with Browser() as browser:`).

**2. Key Architectural Components:**
*   **Main API (`author.py`):** Exposes the core `Browser()` and `AsyncBrowser()` context managers, which are the main entry points for the user.
*   **Browser Management (`browser/` & `browser_manager.py`):** This is the technical core of the library. It's a modular system responsible for:
    *   `finder.py`: Robustly discovering the Chrome executable across macOS, Windows, and Linux, checking over 20 standard and non-standard locations per platform.
    *   `installer.py`: Downloading the correct Chrome for Testing build using official JSON endpoints, with progress bars and SHA256 validation.
    *   `launcher.py`: Launching the Chrome process with the remote debugging port (`--remote-debugging-port=9222`).
    *   `process.py`: Managing the Chrome process, including gracefully killing existing non-debug instances and verifying the new process is ready.
*   **User Experience (`onboarding.py`, `cli.py`):**
    *   `onboarding.py`: If the user is not logged into necessary services, it serves a local HTML page (`templates/onboarding.html`) to guide them through the login process.
    *   `cli.py`: A `fire`-powered command-line interface for status checks (`status`) and cache clearing (`clear-cache`), with `rich` for formatted output.
*   **Configuration & State (`config.py`, `state_manager.py`):** Handles library configuration (e.g., timeouts, paths) and persists the state of the browser (e.g., installation path, version) to avoid redundant work.
*   **Utilities (`utils/`):** Cross-platform path management (`paths.py`) and `loguru`-based logging (`logger.py`).

**3. Development & Quality:**
*   **Workflow:** The project is documentation-driven, using `PLAN.md`, `TODO.md`, and `WORK.md` to guide development. It emphasizes iterative, minimal commits.
*   **Tooling:** Uses `uv` for environment and dependency management. The build system is `hatch` with `hatch-vcs` for versioning based on git tags.
*   **CI/CD (`.github/workflows/ci.yml`):** A comprehensive GitHub Actions pipeline tests the library on Ubuntu, Windows, and macOS. It runs linting (`ruff`), type checking (`mypy`), and a full `pytest` suite with coverage reporting to Codecov.
*   **Code Quality:** The codebase is fully type-hinted. A strict quality pipeline (`ruff`, `autoflake`, `pyupgrade`) is enforced and documented. Every file includes a `this_file:` comment for easy path reference.

**4. Current Status & Roadmap:**
The project has completed its initial phases focused on robustness, error handling, and cross-platform compatibility. It is now in the "Elegance and Performance" phase, which involves refactoring the architecture (e.g., separating state and config management), optimizing performance (e.g., lazy loading), and adding advanced features like browser profile management. Future phases will focus on improving the CLI, documentation, and user experience.

</document_content>
</document>

<document index="11">
<source>CLAUDE.poml</source>
<document_content>
<poml>
  <role>Claude Code assistant for PlaywrightAuthor - a Python convenience package for Microsoft Playwright that handles browser automation setup</role>
  
  <h>PlaywrightAuthor Project Overview</h>
  
  <section>
    <h>1. Core Purpose & Architecture</h>
    
    <cp caption="Project Purpose">
      <p>PlaywrightAuthor is a convenience package for Microsoft Playwright that handles browser automation setup. It automatically manages Chrome for Testing installation, authentication with user profiles, and provides ready-to-use Browser objects through simple context managers.</p>
    </cp>
    
    <cp caption="Key Design Pattern">
      <p>The library follows a context manager pattern with <code inline="true">Browser()</code> and <code inline="true">AsyncBrowser()</code> classes that return authenticated Playwright browser objects.</p>
    </cp>
    
    <cp caption="Main Components (Planned Structure)">
      <list>
        <item><code inline="true">playwrightauthor/author.py</code> - Core Browser/AsyncBrowser classes (main API)</item>
        <item><code inline="true">playwrightauthor/browser_manager.py</code> - Chrome installation/process management</item>
        <item><code inline="true">playwrightauthor/onboarding.py</code> - User guidance for authentication</item>
        <item><code inline="true">playwrightauthor/cli.py</code> - Fire-powered CLI interface</item>
        <item><code inline="true">playwrightauthor/utils/</code> - Logger and cross-platform path utilities</item>
      </list>
    </cp>
    
    <cp caption="Current State">
      <p>The project is in early development. The main implementation exists as a legacy scraper in <code inline="true">old/google_docs_scraper_simple.py</code> that demonstrates the core concept of connecting to an existing Chrome debug session.</p>
    </cp>
  </section>
  
  <section>
    <h>2. Development Commands</h>
    
    <cp caption="Environment Setup">
      <code lang="bash">
# Initial setup with uv
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add playwright rich fire loguru platformdirs requests psutil
      </code>
    </cp>
    
    <cp caption="Code Quality Pipeline">
      <p>After any Python changes, run:</p>
      <code lang="bash">
fd -e py -x uvx autoflake -i {}; \
fd -e py -x uvx pyupgrade --py312-plus {}; \
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
python -m pytest
      </code>
    </cp>
    
    <cp caption="Testing">
      <list>
        <item>Run tests: <code inline="true">python -m pytest</code></item>
        <item>Tests are located in <code inline="true">tests/</code> directory</item>
        <item>Current tests may be integration tests requiring live Chrome instance</item>
      </list>
    </cp>
    
    <cp caption="CLI Usage">
      <p>Once implemented:</p>
      <code lang="bash">
python -m playwrightauthor status  # Check browser status
      </code>
    </cp>
  </section>
  
  <section>
    <h>3. Code Standards</h>
    
    <cp caption="File Management">
      <list>
        <item><b>File headers</b>: Every Python file should include a <code inline="true">this_file:</code> comment with the relative path</item>
        <item><b>Dependencies</b>: Use uv script headers with <code inline="true"># /// script</code> blocks</item>
        <item><b>Type hints</b>: Use modern Python type hints (list, dict, | for unions)</item>
        <item><b>Logging</b>: Use loguru with verbose flag support</item>
        <item><b>CLI</b>: Use Fire for command-line interfaces with Rich for output</item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>4. Browser Management Strategy</h>
    
    <cp caption="Core Technical Challenge">
      <p>The core technical challenge is reliably managing Chrome for Testing:</p>
      
      <list listStyle="decimal">
        <item><b>Detection</b>: Check if Chrome is running with <code inline="true">--remote-debugging-port=9222</code></item>
        <item><b>Installation</b>: Prefer <code inline="true">npx puppeteer browsers install</code>, fallback to LKGV JSON downloads</item>
        <item><b>Process Management</b>: Kill non-debug instances, launch with persistent user-data-dir</item>
        <item><b>Connection</b>: Use Playwright's <code inline="true">connect_over_cdp()</code> to attach to debug session</item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>5. Project Workflow</h>
    
    <cp caption="Documentation-Driven Development">
      <list listStyle="decimal">
        <item>Read <code inline="true">WORK.md</code> and <code inline="true">PLAN.md</code> before making changes</item>
        <item>Update documentation files after implementation</item>
        <item>Use "Wait, but" reflection methodology for code review</item>
        <item>Maintain minimal, self-contained commits</item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>6. Dependencies</h>
    
    <cp caption="Core Runtime Dependencies">
      <list>
        <item><code inline="true">playwright</code> - Browser automation</item>
        <item><code inline="true">rich</code> - Terminal output formatting</item>
        <item><code inline="true">fire</code> - CLI generation</item>
        <item><code inline="true">loguru</code> - Logging</item>
        <item><code inline="true">platformdirs</code> - Cross-platform paths</item>
        <item><code inline="true">requests</code> - HTTP client for downloads</item>
        <item><code inline="true">psutil</code> - Process management</item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>7. Software Development Rules</h>
    
    <cp caption="Pre-Work Preparation">
      <list>
        <item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project folder for work progress</item>
        <item>Read <code inline="true">README.md</code> to understand the project</item>
        <item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item>
        <item>Consider alternatives and carefully choose the best option</item>
        <item>Check for existing solutions in the codebase before starting</item>
      </list>
    </cp>
    
    <cp caption="Project Documentation to Maintain">
      <list>
        <item><code inline="true">README.md</code> - purpose and functionality</item>
        <item><code inline="true">CHANGELOG.md</code> - past change release notes (accumulative)</item>
        <item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that discusses specifics</item>
        <item><code inline="true">TODO.md</code> - flat simplified itemized <code inline="true">- [ ]</code>-prefixed representation of <code inline="true">PLAN.md</code></item>
        <item><code inline="true">WORK.md</code> - work progress updates</item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>8. General Coding Principles</h>
    
    <cp caption="Core Development Approach">
      <list>
        <item>Iterate gradually, avoiding major changes</item>
        <item>Focus on minimal viable increments and ship early</item>
        <item>Minimize confirmations and checks</item>
        <item>Preserve existing code/structure unless necessary</item>
        <item>Check often the coherence of the code you're writing with the rest of the code</item>
        <item>Analyze code line-by-line</item>
      </list>
    </cp>
    
    <cp caption="Code Quality Standards">
      <list>
        <item>Use constants over magic numbers</item>
        <item>Write explanatory docstrings/comments that explain what and WHY</item>
        <item>Explain where and how the code is used/referred to elsewhere</item>
        <item>Handle failures gracefully with retries, fallbacks, user guidance</item>
        <item>Address edge cases, validate assumptions, catch errors early</item>
        <item>Let the computer do the work, minimize user decisions</item>
        <item>Reduce cognitive load, beautify code</item>
        <item>Modularize repeated logic into concise, single-purpose functions</item>
        <item>Favor flat over nested structures</item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>9. Tool Usage (When Available)</h>
    
    <cp caption="Additional Tools">
      <list>
        <item>If we need a new Python project, run <code inline="true">curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync</code></item>
        <item>Use <code inline="true">tree</code> CLI app if available to verify file locations</item>
        <item>Check existing code with <code inline="true">.venv</code> folder to scan and consult dependency source code</item>
        <item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a condensed snapshot of the codebase into <code inline="true">llms.txt</code></item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>10. File Management</h>
    
    <cp caption="File Path Tracking">
      <list>
        <item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">this_file</code> record showing the path relative to project root</item>
        <item>Place <code inline="true">this_file</code> record near the top:
          <list>
            <item>As a comment after shebangs in code files</item>
            <item>In YAML frontmatter for Markdown files</item>
          </list>
        </item>
        <item>Update paths when moving files</item>
        <item>Omit leading <code inline="true">./</code></item>
        <item>Check <code inline="true">this_file</code> to confirm you're editing the right file</item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>11. Python-Specific Guidelines</h>
    
    <cp caption="PEP Standards">
      <list>
        <item>PEP 8: Use consistent formatting and naming, clear descriptive names</item>
        <item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item>
        <item>PEP 257: Write clear, imperative docstrings</item>
        <item>Use type hints in their simplest form (list, dict, | for unions)</item>
      </list>
    </cp>
    
    <cp caption="Modern Python Practices">
      <list>
        <item>Use f-strings and structural pattern matching where appropriate</item>
        <item>Write modern code with <code inline="true">pathlib</code></item>
        <item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item>
        <item>Use <code inline="true">uv add</code></item>
        <item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip install</code></item>
        <item>Prefix Python CLI tools with <code inline="true">python -m</code> (e.g., <code inline="true">python -m pytest</code>)</item>
      </list>
    </cp>
    
    <cp caption="CLI Scripts Setup">
      <p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">rich</code>, and start with:</p>
      <code lang="python">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
      </code>
    </cp>
    
    <cp caption="Post-Edit Python Commands">
      <code lang="bash">
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
      </code>
    </cp>
  </section>
  
  <section>
    <h>12. Post-Work Activities</h>
    
    <cp caption="Critical Reflection">
      <list>
        <item>After completing a step, say "Wait, but" and do additional careful critical reasoning</item>
        <item>Go back, think & reflect, revise & improve what you've done</item>
        <item>Don't invent functionality freely</item>
        <item>Stick to the goal of "minimal viable next version"</item>
      </list>
    </cp>
    
    <cp caption="Documentation Updates">
      <list>
        <item>Update <code inline="true">WORK.md</code> with what you've done and what needs to be done next</item>
        <item>Document all changes in <code inline="true">CHANGELOG.md</code></item>
        <item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code> accordingly</item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>13. Work Methodology</h>
    
    <cp caption="Virtual Team Approach">
      <p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p>
      <list>
        <item><b>"Ideot"</b> - for creative, unorthodox ideas</item>
        <item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced discussions</item>
      </list>
      <p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.</p>
    </cp>
    
    <cp caption="Continuous Work Mode">
      <list>
        <item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> as one huge TASK</item>
        <item>Work on implementing the next item</item>
        <item>Review, reflect, refine, revise your implementation</item>
        <item>Periodically check off completed issues</item>
        <item>Continue to the next item without interruption</item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>14. Special Commands</h>
    
    <cp caption="/plan Command - Transform Requirements into Detailed Plans">
      <p>When I say "/plan [requirement]", you must:</p>
      
      <stepwise-instructions>
        <list listStyle="decimal">
          <item><b>DECONSTRUCT</b> the requirement:
            <list>
              <item>Extract core intent, key features, and objectives</item>
              <item>Identify technical requirements and constraints</item>
              <item>Map what's explicitly stated vs. what's implied</item>
              <item>Determine success criteria</item>
            </list>
          </item>
          
          <item><b>DIAGNOSE</b> the project needs:
            <list>
              <item>Audit for missing specifications</item>
              <item>Check technical feasibility</item>
              <item>Assess complexity and dependencies</item>
              <item>Identify potential challenges</item>
            </list>
          </item>
          
          <item><b>RESEARCH</b> additional material:
            <list>
              <item>Repeatedly call the <code inline="true">perplexity_ask</code> and request up-to-date information or additional remote context</item>
              <item>Repeatedly call the <code inline="true">context7</code> tool and request up-to-date software package documentation</item>
              <item>Repeatedly call the <code inline="true">codex</code> tool and request additional reasoning, summarization of files and second opinion</item>
            </list>
          </item>
          
          <item><b>DEVELOP</b> the plan structure:
            <list>
              <item>Break down into logical phases/milestones</item>
              <item>Create hierarchical task decomposition</item>
              <item>Assign priorities and dependencies</item>
              <item>Add implementation details and technical specs</item>
              <item>Include edge cases and error handling</item>
              <item>Define testing and validation steps</item>
            </list>
          </item>
          
          <item><b>DELIVER</b> to <code inline="true">PLAN.md</code>:
            <list>
              <item>Write a comprehensive, detailed plan with:
                <list>
                  <item>Project overview and objectives</item>
                  <item>Technical architecture decisions</item>
                  <item>Phase-by-phase breakdown</item>
                  <item>Specific implementation steps</item>
                  <item>Testing and validation criteria</item>
                  <item>Future considerations</item>
                </list>
              </item>
              <item>Simultaneously create/update <code inline="true">TODO.md</code> with the flat itemized <code inline="true">- [ ]</code> representation</item>
            </list>
          </item>
        </list>
      </stepwise-instructions>
      
      <cp caption="Plan Optimization Techniques">
        <list>
          <item><b>Task Decomposition:</b> Break complex requirements into atomic, actionable tasks</item>
          <item><b>Dependency Mapping:</b> Identify and document task dependencies</item>
          <item><b>Risk Assessment:</b> Include potential blockers and mitigation strategies</item>
          <item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item>
          <item><b>Technical Specifications:</b> Include specific technologies, patterns, and approaches</item>
        </list>
      </cp>
    </cp>
    
    <cp caption="/report Command">
      <list listStyle="decimal">
        <item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files</item>
        <item>Analyze recent changes</item>
        <item>Document all changes in <code inline="true">./CHANGELOG.md</code></item>
        <item>Remove completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item>
        <item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans with specifics</item>
        <item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized representation</item>
      </list>
    </cp>
    
    <cp caption="/work Command">
      <list listStyle="decimal">
        <item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files and reflect</item>
        <item>Write down the immediate items in this iteration into <code inline="true">./WORK.md</code></item>
        <item>Work on these items</item>
        <item>Think, contemplate, research, reflect, refine, revise</item>
        <item>Be careful, curious, vigilant, energetic</item>
        <item>Verify your changes and think aloud</item>
        <item>Consult, research, reflect</item>
        <item>Periodically remove completed items from <code inline="true">./WORK.md</code></item>
        <item>Tick off completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item>
        <item>Update <code inline="true">./WORK.md</code> with improvement tasks</item>
        <item>Execute <code inline="true">/report</code></item>
        <item>Continue to the next item</item>
      </list>
    </cp>
  </section>
  
  <section>
    <h>15. Additional Guidelines</h>
    
    <list>
      <item>Ask before extending/refactoring existing code that may add complexity or break things</item>
      <item>Work tirelessly without constant updates when in continuous work mode</item>
      <item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> items</item>
    </list>
  </section>
  
  <section>
    <h>16. Command Summary</h>
    
    <list>
      <item><code inline="true">/plan [requirement]</code> - Transform vague requirements into detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item>
      <item><code inline="true">/report</code> - Update documentation and clean up completed tasks</item>
      <item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item>
      <item>You may use these commands autonomously when appropriate</item>
    </list>
  </section>
  
  <section>
    <h>17. TL;DR for PlaywrightAuthor Codebase</h>
    
    <cp caption="Core Purpose & Value Proposition">
      <p>PlaywrightAuthor is a Python convenience library built on top of Microsoft Playwright. Its primary goal is to eliminate the boilerplate setup for browser automation. It automatically finds or installs a "Chrome for Testing" instance, manages its process (ensuring it runs in debug mode), handles user authentication by reusing a persistent profile, and provides a ready-to-use, authenticated Playwright <code inline="true">Browser</code> object within a simple context manager (<code inline="true">with Browser() as browser:</code>).</p>
    </cp>
    
    <cp caption="Key Architectural Components">
      <list>
        <item><b>Main API (<code inline="true">author.py</code>):</b> Exposes the core <code inline="true">Browser()</code> and <code inline="true">AsyncBrowser()</code> context managers, which are the main entry points for the user.</item>
        <item><b>Browser Management (<code inline="true">browser/</code> & <code inline="true">browser_manager.py</code>):</b> This is the technical core of the library. It's a modular system responsible for:
          <list>
            <item><code inline="true">finder.py</code>: Robustly discovering the Chrome executable across macOS, Windows, and Linux, checking over 20 standard and non-standard locations per platform.</item>
            <item><code inline="true">installer.py</code>: Downloading the correct Chrome for Testing build using official JSON endpoints, with progress bars and SHA256 validation.</item>
            <item><code inline="true">launcher.py</code>: Launching the Chrome process with the remote debugging port (<code inline="true">--remote-debugging-port=9222</code>).</item>
            <item><code inline="true">process.py</code>: Managing the Chrome process, including gracefully killing existing non-debug instances and verifying the new process is ready.</item>
          </list>
        </item>
        <item><b>User Experience (<code inline="true">onboarding.py</code>, <code inline="true">cli.py</code>):</b>
          <list>
            <item><code inline="true">onboarding.py</code>: If the user is not logged into necessary services, it serves a local HTML page (<code inline="true">templates/onboarding.html</code>) to guide them through the login process.</item>
            <item><code inline="true">cli.py</code>: A <code inline="true">fire</code>-powered command-line interface for status checks (<code inline="true">status</code>) and cache clearing (<code inline="true">clear-cache</code>), with <code inline="true">rich</code> for formatted output.</item>
          </list>
        </item>
        <item><b>Configuration & State (<code inline="true">config.py</code>, <code inline="true">state_manager.py</code>):</b> Handles library configuration (e.g., timeouts, paths) and persists the state of the browser (e.g., installation path, version) to avoid redundant work.</item>
        <item><b>Utilities (<code inline="true">utils/</code>):</b> Cross-platform path management (<code inline="true">paths.py</code>) and <code inline="true">loguru</code>-based logging (<code inline="true">logger.py</code>).</item>
      </list>
    </cp>
    
    <cp caption="Development & Quality">
      <list>
        <item><b>Workflow:</b> The project is documentation-driven, using <code inline="true">PLAN.md</code>, <code inline="true">TODO.md</code>, and <code inline="true">WORK.md</code> to guide development. It emphasizes iterative, minimal commits.</item>
        <item><b>Tooling:</b> Uses <code inline="true">uv</code> for environment and dependency management. The build system is <code inline="true">hatch</code> with <code inline="true">hatch-vcs</code> for versioning based on git tags.</item>
        <item><b>CI/CD (<code inline="true">.github/workflows/ci.yml</code>):</b> A comprehensive GitHub Actions pipeline tests the library on Ubuntu, Windows, and macOS. It runs linting (<code inline="true">ruff</code>), type checking (<code inline="true">mypy</code>), and a full <code inline="true">pytest</code> suite with coverage reporting to Codecov.</item>
        <item><b>Code Quality:</b> The codebase is fully type-hinted. A strict quality pipeline (<code inline="true">ruff</code>, <code inline="true">autoflake</code>, <code inline="true">pyupgrade</code>) is enforced and documented. Every file includes a <code inline="true">this_file:</code> comment for easy path reference.</item>
      </list>
    </cp>
    
    <cp caption="Current Status & Roadmap">
      <p>The project has completed its initial phases focused on robustness, error handling, and cross-platform compatibility. It is now in the "Elegance and Performance" phase, which involves refactoring the architecture (e.g., separating state and config management), optimizing performance (e.g., lazy loading), and adding advanced features like browser profile management. Future phases will focus on improving the CLI, documentation, and user experience.</p>
    </cp>
  </section>
</poml>
</document_content>
</document>

<document index="12">
<source>GEMINI.md</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

PlaywrightAuthor is a convenience package for Microsoft Playwright that handles browser automation setup. It automatically manages Chrome for Testing installation, authentication with user profiles, and provides ready-to-use Browser objects through simple context managers.

## 2. Key Architecture

**Core Design Pattern**: The library follows a context manager pattern with `Browser()` and `AsyncBrowser()` classes that return authenticated Playwright browser objects.

**Main Components** (planned structure):
- `playwrightauthor/author.py` - Core Browser/AsyncBrowser classes (main API)
- `playwrightauthor/browser_manager.py` - Chrome installation/process management 
- `playwrightauthor/onboarding.py` - User guidance for authentication
- `playwrightauthor/cli.py` - Fire-powered CLI interface
- `playwrightauthor/utils/` - Logger and cross-platform path utilities

**Current State**: The project is in early development. The main implementation exists as a legacy scraper in `old/google_docs_scraper_simple.py` that demonstrates the core concept of connecting to an existing Chrome debug session.

## 3. Development Commands

### 3.1. Environment Setup
```bash
# Initial setup with uv
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add playwright rich fire loguru platformdirs requests psutil
```

### 3.2. Code Quality Pipeline
After any Python changes, run:
```bash
fd -e py -x uvx autoflake -i {}; \
fd -e py -x uvx pyupgrade --py312-plus {}; \
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
python -m pytest
```

### 3.3. Testing
- Run tests: `python -m pytest`
- Tests are located in `tests/` directory
- Current tests may be integration tests requiring live Chrome instance

### 3.4. CLI Usage
Once implemented:
```bash
python -m playwrightauthor status  # Check browser status
```

## 4. Code Standards

- **File headers**: Every Python file should include a `this_file:` comment with the relative path
- **Dependencies**: Use uv script headers with `# /// script` blocks
- **Type hints**: Use modern Python type hints (list, dict, | for unions)
- **Logging**: Use loguru with verbose flag support
- **CLI**: Use Fire for command-line interfaces with Rich for output

## 5. Browser Management Strategy

The core technical challenge is reliably managing Chrome for Testing:

1. **Detection**: Check if Chrome is running with `--remote-debugging-port=9222`
2. **Installation**: Prefer `npx puppeteer browsers install`, fallback to LKGV JSON downloads
3. **Process Management**: Kill non-debug instances, launch with persistent user-data-dir
4. **Connection**: Use Playwright's `connect_over_cdp()` to attach to debug session

## 6. Project Workflow

The project follows a documentation-driven development approach:
1. Read `WORK.md` and `PLAN.md` before making changes
2. Update documentation files after implementation
3. Use "Wait, but" reflection methodology for code review
4. Maintain minimal, self-contained commits

## 7. Dependencies

Core runtime dependencies:
- `playwright` - Browser automation
- `rich` - Terminal output formatting  
- `fire` - CLI generation
- `loguru` - Logging
- `platformdirs` - Cross-platform paths
- `requests` - HTTP client for downloads
- `psutil` - Process management

# Software Development Rules

## 8. Pre-Work Preparation

### 8.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 8.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 9. General Coding Principles

### 9.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 9.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 10. Tool Usage (When Available)

### 10.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 11. File Management

### 11.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 12. Python-Specific Guidelines

### 12.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 12.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 12.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 12.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 13. Post-Work Activities

### 13.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 13.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 14. Work Methodology

### 14.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 14.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 15. Special Commands

### 15.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 15.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 15.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 16. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 17. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate

**TL;DR for PlaywrightAuthor Codebase**

**1. Core Purpose & Value Proposition:**
PlaywrightAuthor is a Python convenience library built on top of Microsoft Playwright. Its primary goal is to eliminate the boilerplate setup for browser automation. It automatically finds or installs a "Chrome for Testing" instance, manages its process (ensuring it runs in debug mode), handles user authentication by reusing a persistent profile, and provides a ready-to-use, authenticated Playwright `Browser` object within a simple context manager (`with Browser() as browser:`).

**2. Key Architectural Components:**
*   **Main API (`author.py`):** Exposes the core `Browser()` and `AsyncBrowser()` context managers, which are the main entry points for the user.
*   **Browser Management (`browser/` & `browser_manager.py`):** This is the technical core of the library. It's a modular system responsible for:
    *   `finder.py`: Robustly discovering the Chrome executable across macOS, Windows, and Linux, checking over 20 standard and non-standard locations per platform.
    *   `installer.py`: Downloading the correct Chrome for Testing build using official JSON endpoints, with progress bars and SHA256 validation.
    *   `launcher.py`: Launching the Chrome process with the remote debugging port (`--remote-debugging-port=9222`).
    *   `process.py`: Managing the Chrome process, including gracefully killing existing non-debug instances and verifying the new process is ready.
*   **User Experience (`onboarding.py`, `cli.py`):**
    *   `onboarding.py`: If the user is not logged into necessary services, it serves a local HTML page (`templates/onboarding.html`) to guide them through the login process.
    *   `cli.py`: A `fire`-powered command-line interface for status checks (`status`) and cache clearing (`clear-cache`), with `rich` for formatted output.
*   **Configuration & State (`config.py`, `state_manager.py`):** Handles library configuration (e.g., timeouts, paths) and persists the state of the browser (e.g., installation path, version) to avoid redundant work.
*   **Utilities (`utils/`):** Cross-platform path management (`paths.py`) and `loguru`-based logging (`logger.py`).

**3. Development & Quality:**
*   **Workflow:** The project is documentation-driven, using `PLAN.md`, `TODO.md`, and `WORK.md` to guide development. It emphasizes iterative, minimal commits.
*   **Tooling:** Uses `uv` for environment and dependency management. The build system is `hatch` with `hatch-vcs` for versioning based on git tags.
*   **CI/CD (`.github/workflows/ci.yml`):** A comprehensive GitHub Actions pipeline tests the library on Ubuntu, Windows, and macOS. It runs linting (`ruff`), type checking (`mypy`), and a full `pytest` suite with coverage reporting to Codecov.
*   **Code Quality:** The codebase is fully type-hinted. A strict quality pipeline (`ruff`, `autoflake`, `pyupgrade`) is enforced and documented. Every file includes a `this_file:` comment for easy path reference.

**4. Current Status & Roadmap:**
The project has completed its initial phases focused on robustness, error handling, and cross-platform compatibility. It is now in the "Elegance and Performance" phase, which involves refactoring the architecture (e.g., separating state and config management), optimizing performance (e.g., lazy loading), and adding advanced features like browser profile management. Future phases will focus on improving the CLI, documentation, and user experience.

</document_content>
</document>

<document index="13">
<source>LICENSE</source>
<document_content>
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

</document_content>
</document>

<document index="14">
<source>PLAN.md</source>
<document_content>
# Development Plan for PlaywrightAuthor

## Chrome for Testing Exclusivity & Session Reuse ✅ COMPLETED (2025-08-05)

### Goal
Make PlaywrightAuthor exclusively use Chrome for Testing due to Google's CDP restrictions on regular Chrome, and implement session reuse workflow for better developer experience.

### Completed Tasks
- [x] Updated browser finder to only search for Chrome for Testing paths
- [x] Modified process management to reject regular Chrome processes  
- [x] Added launch validation to ensure only Chrome for Testing is used
- [x] Fixed Chrome for Testing executable permissions issue on macOS
- [x] Implemented `get_page()` method for session reuse
- [x] Added `playwrightauthor browse` CLI command for persistent browser
- [x] Updated all examples to use session reuse workflow
- [x] Documented pre-authorized sessions workflow as recommended approach

### Original Requirements Verification ✅ COMPLETED
- [x] **Browser Management**: Chrome for Testing discovery, installation, launch, connection
- [x] **Authentication & Onboarding**: Profile persistence, onboarding UI, session reuse
- [x] **Playwright Integration**: Context managers returning standard Browser objects
- [x] **User Experience**: Simple API, comprehensive CLI, helpful error messages

## Remaining Development Tasks

### Pre-commit Hooks
- [ ] Configure pre-commit framework with ruff, mypy, bandit
- [ ] Add security scanning with bandit for sensitive code patterns
- [ ] Integrate with CI/CD pipeline for automated checks

### Semantic Versioning
- [ ] Note: Already using hatch-vcs for git-based versioning
- [ ] Document release process and version tagging strategy

</document_content>
</document>

<document index="15">
<source>README.md</source>
<document_content>
# PlaywrightAuthor

Your personal, authenticated browser for Playwright, ready in one line of code.

PlaywrightAuthor is a convenience package for **Microsoft Playwright**. It handles browser automation setup: finding and launching Chrome for Testing, keeping it authenticated with your user profile, and connecting Playwright to it. Instantiate a class, get a ready-to-use `Browser` object, and focus on writing automation scripts instead of boilerplate.

**Note**: PlaywrightAuthor uses Chrome for Testing (not regular Chrome) because Google disabled CDP automation with user profiles in regular Chrome. Chrome for Testing is Google's official build designed for automation, ensuring persistent login sessions and reusable browser profiles.

The core idea:

```python
from playwrightauthor import Browser

with Browser() as browser:
    # Standard Playwright browser object
    # Already connected to logged-in browser
    page = browser.new_page()
    page.goto("https://github.com/me")
    print(f"Welcome, {page.locator('.user-profile-name').inner_text()}!")
```

## Contents

* [Features](#features)
* [Installation](#installation)
* [Quick start](#quick-start)
* [Common patterns](#common-patterns)
* [Best practices](#best-practices)
* [CLI](#command-line-interface)
* [Developer workflow](#developer-workflow)
* [Architecture](#package-architecture)
* [Troubleshooting](#troubleshooting)
* [Contributing](#contributing)
* [License](#license)

## Features

### Zero-Configuration Automation
- **Automatic Chrome Management**: Discovers, installs, and launches Chrome for Testing with remote debugging enabled
- **Persistent Authentication**: Maintains user sessions across script runs using persistent browser profiles
- **Cross-Platform Support**: Works on Windows, macOS, and Linux

### Performance & Reliability
- **Lazy Loading**: Optimized startup with on-demand imports
- **Connection Health Monitoring**: Diagnostics and automatic retry logic
- **State Management**: Caches browser paths for faster subsequent runs
- **Error Recovery**: Graceful handling of browser crashes

### Developer Experience
- **Simple API**: Clean `Browser()` and `AsyncBrowser()` context managers
- **CLI Tools**: Command-line interface for browser and profile management
- **Type Safety**: 100% type-hinted codebase
- **Testing**: Extensive test suite with CI/CD

### Advanced Management
- **Profile System**: Create and switch between multiple browser profiles
- **Configuration Management**: Environment variable support
- **Diagnostic Tools**: Built-in troubleshooting
- **JSON Output**: Machine-readable formats

## Installation

```bash
# Install PlaywrightAuthor
pip install playwrightauthor

# Install Playwright browsers
playwright install chromium
```

## Quick start

```bash
# Create script file
cat > example.py << 'EOF'
from playwrightauthor import Browser

with Browser() as browser:
    page = browser.new_page()
    page.goto("https://github.com")
    print(f"Page title: {page.title()}")
EOF

# Run script
python example.py
```

Example `myscript.py`:
```python
from playwrightauthor import Browser, AsyncBrowser
import asyncio

# Synchronous API
print("--- Running Sync Example ---")
with Browser(verbose=True) as browser:
    page = browser.new_page()
    page.goto("https://github.com")
    print(f"Page title: {page.title()}")

# Asynchronous API
async def main():
    print("\n--- Running Async Example ---")
    async with AsyncBrowser(verbose=True) as browser:
        page = await browser.new_page()
        await page.goto("https://duckduckgo.com")
        print(f"Page title: {await page.title()}")

if __name__ == "__main__":
    asyncio.run(main())
```

## Common patterns

### Pre-Authorized Sessions (Recommended)

PlaywrightAuthor reuses existing browser sessions. Recommended workflow:

```bash
# Step 1: Launch Chrome for Testing in CDP mode
playwrightauthor browse

# Step 2: Manually log into services
# Browser stays running after command exits

# Step 3: Run automation scripts
python your_script.py
```

Scripts should use `get_page()` to reuse contexts:

```python
from playwrightauthor import Browser

with Browser() as browser:
    # get_page() reuses existing contexts
    page = browser.get_page()
    page.goto("https://github.com/notifications")
    notifications = page.locator(".notification-list-item").count()
    print(f"You have {notifications} GitHub notifications")
```

Benefits:
- **One-time authentication**: Log in once, all scripts use session
- **Session persistence**: Authentication persists across runs
- **Development efficiency**: No login flows in automation code
- **Multi-service support**: Multiple services logged in simultaneously

### Authentication Workflow

For programmatic authentication:

```python
from playwrightauthor import Browser

# First run: Manual login required
with Browser(profile="work") as browser:
    page = browser.new_page()
    page.goto("https://mail.google.com")
    # Complete login manually
    print(f"Logged in as: {page.locator('[data-testid=user-email]').inner_text()}")

# Subsequent runs: Automatic authentication
with Browser(profile="work") as browser:
    page = browser.new_page() 
    page.goto("https://mail.google.com")
    inbox_count = page.locator('[data-testid=inbox-count]').inner_text()
    print(f"You have {inbox_count} unread emails")
```

### Error Handling

Production automation with retry logic:

```python
from playwrightauthor import Browser
from playwright.sync_api import TimeoutError
import time

def scrape_with_retry(url, max_retries=3):
    """Robust scraping with automatic retry."""
    
    for attempt in range(max_retries):
        try:
            with Browser(verbose=attempt > 0) as browser:
                page = browser.new_page()
                page.set_default_timeout(30000)
                page.goto(url)
                page.wait_for_selector('[data-testid=content]', timeout=10000)
                
                title = page.title()
                content = page.locator('[data-testid=content]').inner_text()
                return {"title": title, "content": content}
                
        except TimeoutError:
            print(f"Attempt {attempt + 1} timed out, retrying...")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)
            continue
            
        except Exception as e:
            print(f"Attempt {attempt + 1} failed: {e}")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)
            continue
    
    raise Exception(f"Failed to scrape {url} after {max_retries} attempts")

# Usage
try:
    data = scrape_with_retry("https://example.com")
    print(f"Successfully scraped: {data['title']}")
except Exception as e:
    print(f"Scraping failed: {e}")
```

### Profile Management

Multiple accounts or environments:

```python
from playwrightauthor import Browser

profiles = {
    "work": "work@company.com",
    "personal": "me@gmail.com", 
    "testing": "test@example.com"
}

def check_email_for_all_accounts():
    """Check email counts across accounts."""
    results = {}
    
    for profile_name, email in profiles.items():
        try:
            with Browser(profile=profile_name) as browser:
                page = browser.new_page()
                page.goto("https://mail.google.com")
                unread_count = page.locator('[aria-label="Inbox"]').get_attribute('data-count')
                results[email] = int(unread_count or 0)
                
        except Exception as e:
            print(f"Failed to check {email}: {e}")
            results[email] = None
    
    return results

email_counts = check_email_for_all_accounts()
for email, count in email_counts.items():
    if count is not None:
        print(f"{email}: {count} unread emails")
    else:
        print(f"{email}: Failed to check")
```

### Interactive Development

Use REPL for development:

```bash
# Start interactive REPL
python -m playwrightauthor repl

# In REPL:
>>> page = browser.new_page()
>>> page.goto("https://github.com")
>>> page.title()
'GitHub: Let's build from here · GitHub'

>>> page.locator('h1').inner_text()
'Let's build from here'

>>> !status
Browser is ready.
  - Path: /Users/user/.playwrightauthor/chrome/chrome
  - User Data: /Users/user/.playwrightauthor/profiles/default

>>> exit()
>>> browser = Browser(profile="work").__enter__()
>>> page = browser.new_page()
>>> page.goto("https://mail.google.com")
```

### Async Performance

High-performance concurrent operations:

```python
import asyncio
from playwrightauthor import AsyncBrowser

async def scrape_multiple_pages(urls):
    """Scrape pages concurrently."""
    
    async def scrape_single_page(url):
        async with AsyncBrowser() as browser:
            page = await browser.new_page()
            await page.goto(url)
            title = await page.title()
            return {"url": url, "title": title}
    
    semaphore = asyncio.Semaphore(5)
    
    async def limited_scrape(url):
        async with semaphore:
            return await scrape_single_page(url)
    
    tasks = [limited_scrape(url) for url in urls]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return results

urls = [
    "https://github.com",
    "https://stackoverflow.com", 
    "https://python.org"
]

async def main():
    results = await scrape_multiple_pages(urls)
    for result in results:
        if isinstance(result, dict):
            print(f"{result['url']}: {result['title']}")
        else:
            print(f"Error: {result}")

asyncio.run(main())
```

### Quick Reference

**Common commands:**
```bash
# Launch browser for manual login
python -m playwrightauthor browse

# Check status
python -m playwrightauthor status

# Start REPL
python -m playwrightauthor repl

# Diagnose issues
python -m playwrightauthor diagnose

# Clear cache
python -m playwrightauthor clear-cache
```

**Common patterns:**
```python
# Reuse existing session
with Browser() as browser:
    page = browser.get_page()
    page.goto("https://example.com")

# Create new page
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")

# Multiple accounts
with Browser(profile="work") as browser:
    page = browser.get_page()

# High performance
async with AsyncBrowser() as browser:
    page = await browser.get_page()
```

## Best practices

### Resource Management

Always use context managers:

```python
from playwrightauthor import Browser

# ✅ GOOD
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")

# ❌ BAD
browser = Browser().__enter__()
page = browser.new_page()
page.goto("https://example.com")
```

Page lifecycle management:
```python
with Browser() as browser:
    page1 = browser.new_page()
    page2 = browser.new_page()
    
    page1.close()
    page2.close()
    
    # Or use page context managers
    page = browser.new_page()
    try:
        page.goto("https://example.com")
    finally:
        page.close()
```

### Performance Optimization

Large-scale automation:
```python
from playwrightauthor import AsyncBrowser
import asyncio

async def optimize_for_performance():
    async with AsyncBrowser() as browser:
        context = await browser.new_context(
            viewport={"width": 1280, "height": 720}
        )
        
        semaphore = asyncio.Semaphore(5)
        
        async def process_url(url):
            async with semaphore:
                page = await context.new_page()
                try:
                    await page.goto(url, wait_until="domcontentloaded")
                    title = await page.title()
                    return {"url": url, "title": title}
                finally:
                    await page.close()
        
        urls = ["https://example1.com", "https://example2.com"]
        results = await asyncio.gather(*[process_url(url) for url in urls])
        
        await context.close()
        return results

results = asyncio.run(optimize_for_performance())
```

Memory management:
```python
from playwrightauthor import Browser

def memory_efficient_scraping(urls):
    results = []
    with Browser() as browser:
        batch_size = 10
        for i in range(0, len(urls), batch_size):
            batch = urls[i:i + batch_size]
            
            for url in batch:
                page = browser.new_page()
                try:
                    page.goto(url, timeout=30000)
                    results.append({
                        "url": url,
                        "title": page.title(),
                        "status": "success"
                    })
                except Exception as e:
                    results.append({
                        "url": url, 
                        "error": str(e),
                        "status": "failed"
                    })
                finally:
                    page.close()
    
    return results
```

### Security

Profile and credential management:
```python
from playwrightauthor import Browser
import os

def secure_automation_setup():
    profiles = {
        "production": "prod-automation",
        "staging": "staging-test", 
        "development": "dev-local"
    }
    
    environment = os.getenv("ENVIRONMENT", "development")
    profile_name = profiles.get(environment, "default")
    
    with Browser(profile=profile_name, verbose=False) as browser:
        page = browser.new_page()
        page.set_extra_http_headers({
            "User-Agent": "Company-Automation/1.0"
        })
        page.goto("https://secure-api.company.com")
        return page.content()
```

Sensitive data handling:
```python
from playwrightauthor import Browser
import logging

logging.basicConfig(level=logging.INFO)

def secure_login_automation():
    with Browser(profile="secure-profile", verbose=False) as browser:
        page = browser.new_page()
        page.goto("https://app.example.com/login")
        
        username = os.getenv("APP_USERNAME")
        password = os.getenv("APP_PASSWORD")
        
        if not username or not password:
            raise ValueError("Credentials missing")
        
        page.fill('[name="username"]', username)
        page.fill('[name="password"]', password)
        
        logging.info("Attempting login")
        page.click('[type="submit"]')
        page.wait_for_url("**/dashboard")
        logging.info("Authentication successful")
        
        return page
```

### Configuration

Production configuration:
```python
from playwrightauthor.config import PlaywrightAuthorConfig, BrowserConfig, NetworkConfig, LoggingConfig
from pathlib import Path

def create_production_config():
    return PlaywrightAuthorConfig(
        browser=BrowserConfig(
            headless=True,
            timeout=45000,
            viewport_width=1920,
            viewport_height=1080,
            args=[
                "--no-sandbox",
                "--disable-dev-shm-usage",
                "--disable-gpu",
            ]
        ),
        network=NetworkConfig(
            retry_attempts=5,
            download_timeout=600,
            exponential_backoff=True,
            proxy=os.getenv("HTTPS_PROXY")
        ),
        logging=LoggingConfig(
            verbose=False,
            log_level="INFO",
            log_file=Path("/var/log/playwrightauthor.log")
        ),
        enable_lazy_loading=True,
        default_profile="production"
    )

config = create_production_config()
from playwrightauthor.config import save_config
save_config(config)
```

Environment variables:
```bash
export PLAYWRIGHTAUTHOR_HEADLESS=true
export PLAYWRIGHTAUTHOR_TIMEOUT=45000
export PLAYWRIGHTAUTHOR_VERBOSE=false
export PLAYWRIGHTAUTHOR_LOG_LEVEL=INFO
export PLAYWRIGHTAUTHOR_RETRY_ATTEMPTS=5

# Never hardcode credentials
export APP_USERNAME=your-automation-user
export APP_PASSWORD=secure-password-from-secrets-manager

export HTTPS_PROXY=http://proxy.company.com:8080
```

### Error Handling

Production-grade error handling:
```python
from playwrightauthor import Browser
from playwright.sync_api import TimeoutError
import logging
import time

def robust_automation_with_error_handling():
    max_retries = 3
    base_delay = 1.0
    
    for attempt in range(max_retries):
        try:
            with Browser(verbose=attempt > 0) as browser:
                page = browser.new_page()
                page.set_default_timeout(30000)
                
                try:
                    page.goto("https://example.com", wait_until="networkidle")
                except TimeoutError:
                    logging.warning(f"Page load timeout on attempt {attempt + 1}")
                    if attempt < max_retries - 1:
                        continue
                    raise
                
                try:
                    page.wait_for_selector('[data-testid="content"]', timeout=10000)
                except TimeoutError:
                    logging.error("Required content not found")
                    page.screenshot(path=f"error-{int(time.time())}.png")
                    raise
                
                title = page.title()
                if not title:
                    raise ValueError("Page title is empty")
                
                content = page.locator('[data-testid="content"]').inner_text()
                if not content.strip():
                    raise ValueError("Page content is empty")
                
                return {"title": title, "content": content}
                
        except Exception as e:
            logging.error(f"Error on attempt {attempt + 1}: {e}")
            if attempt < max_retries - 1:
                delay = base_delay * (2 ** attempt)
                logging.info(f"Retrying in {delay} seconds...")
                time.sleep(delay)
                continue
            raise
    
    raise Exception(f"Failed after {max_retries} attempts")
```

## Command-Line Interface

### Browser Management

```bash
# Check browser status
python -m playwrightauthor status

# Clear browser cache
python -m playwrightauthor clear-cache

# Run diagnostics
python -m playwrightauthor diagnose
```

### Profile Management

```bash
# List profiles
python -m playwrightauthor profile list

# Create profile
python -m playwrightauthor profile create myprofile

# Show profile details
python -m playwrightauthor profile show myprofile

# Delete profile
python -m playwrightauthor profile delete myprofile

# Clear all profiles
python -m playwrightauthor profile clear
```

### Configuration

```bash
# Show current configuration
python -m playwrightauthor config show

# Show version info
python -m playwrightauthor version
```

All commands support `--json` output and `--verbose` logging.

## Developer workflow

1. **Read** `WORK.md` & `PLAN.md` before coding.

2. **Iterate** in minimal, self-contained commits.

3. After Python changes run:

   ```bash
   fd -e py -x uvx autoflake -i {}; \
   fd -e py -x uvx pyupgrade --py312-plus {}; \
   fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
   fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
   python -m pytest
   ```

4. Update `CHANGELOG.md`, tick items in `TODO.md`, push.

5. End sessions with **"Wait, but"** → reflect → refine → push again.

## Package Architecture

```
src/playwrightauthor/
├── __init__.py              # Public API exports (Browser, AsyncBrowser)
├── __main__.py              # CLI entry point
├── author.py                # Core Browser context managers
├── browser_manager.py       # Legacy browser management
├── cli.py                   # CLI with rich output
├── config.py                # Configuration management
├── connection.py            # Connection health and diagnostics
├── exceptions.py           # Custom exceptions
├── lazy_imports.py         # Performance optimization
├── onboarding.py           # User authentication guidance
├── state_manager.py        # Persistent state management
├── typing.py               # Type definitions
├── browser/                # Modular browser management
│   ├── __init__.py
│   ├── finder.py           # Chrome discovery
│   ├── installer.py        # Chrome installation
│   ├── launcher.py         # Browser launching
│   └── process.py          # Process management
├── templates/
│   └── onboarding.html     # User guidance interface
└── utils/
    ├── logger.py           # Logging configuration
    └── paths.py            # Path management

tests/
├── test_author.py          # Core functionality tests
├── test_benchmark.py       # Performance benchmarks
├── test_integration.py     # Integration tests
├── test_platform_specific.py # Platform-specific tests
└── test_utils.py           # Utility function tests
```

## Key Components

### Core API
- `Browser()` - Synchronous context manager
- `AsyncBrowser()` - Asynchronous context manager

Both return standard Playwright browser objects.

### Browser Management
- **Automatic Discovery**: Cross-platform Chrome detection
- **Smart Installation**: Downloads Chrome for Testing from official endpoints
- **Process Management**: Handles browser launching and cleanup
- **Profile Persistence**: Maintains authentication across sessions

### Configuration System
- **Environment Variables**: `PLAYWRIGHTAUTHOR_*` prefix
- **State Management**: Caches browser paths
- **Profile Support**: Multiple named profiles

## Troubleshooting

### `BrowserManagerError: Could not find Chrome executable...`

PlaywrightAuthor couldn't find Chrome for Testing. Solutions:
- Let it install automatically (downloads on first run)
- Install manually: `npx puppeteer browsers install chrome`

### `playwright._impl._api_types.Error: Target page, context or browser has been closed`

Browser closed during script execution. Happens when:
- You manually close the browser window
- Browser crashes

Run script with `--verbose` flag for more information.

## Contributing

Pull requests welcome. Follow coding principles in `README.md`, keep file headers accurate, and end PRs with a "Wait, but" reflection.

## License

MIT – see `LICENSE`.

## Wait, but…

**Reflection & refinements**

* Refocused from specific scraper to general-purpose Playwright convenience library
* Class-based core API (`Browser`, `AsyncBrowser`) for Pythonic feel
* Updated file layout and CLI to match new scope
* Generalized onboarding HTML to be site-agnostic
* All snippets align with providing zero-setup, authenticated browser access

(End of iteration – ready for review.)
</document_content>
</document>

<document index="16">
<source>TODO.md</source>
<document_content>
# TODO: Remaining Tasks for 100% Package Completion

## Completed Work ✅

### Chrome for Testing Exclusivity & Session Reuse (2025-08-05)
- [x] Make PlaywrightAuthor exclusively use Chrome for Testing (not regular Chrome)
- [x] Update all browser discovery to reject regular Chrome
- [x] Fix Chrome for Testing executable permissions issue
- [x] Add `get_page()` method for session reuse
- [x] Create `playwrightauthor browse` CLI command
- [x] Update examples to use session reuse workflow
- [x] Document pre-authorized sessions workflow in README
- [x] Update CHANGELOG with detailed enhancement documentation

### Verification Against Original Requirements (2025-08-05)
- [x] Verify implementation against the original @old/playwrightauthor.md requirements
  - Browser Management: ✅ Chrome for Testing installation, launch, connection
  - Authentication & Onboarding: ✅ Profile persistence, onboarding UI  
  - Playwright Integration: ✅ Context managers returning Browser objects
  - User Experience: ✅ Simple API, CLI commands, error handling

## Remaining Tasks

- [ ] Pre-commit hooks with `ruff`, `mypy`, `bandit` security scanning
- [ ] Automated semantic versioning based on git tags (already using hatch-vcs)

</document_content>
</document>

<document index="17">
<source>WORK.md</source>
<document_content>
# Work Progress

## Chrome for Testing Exclusivity & Session Reuse Enhancement ✅ COMPLETED (2025-08-05)

### Focus: Exclusive Chrome for Testing Support & Pre-Authorized Sessions Workflow

#### Major Enhancement Completed ✅

1. **Chrome for Testing Exclusivity**:
   - **Browser Discovery**: Removed all regular Chrome paths from finder.py - now ONLY searches for Chrome for Testing
   - **Process Management**: Updated process.py to only accept Chrome for Testing processes
   - **Launch Validation**: Added validation in launcher.py to reject regular Chrome executables
   - **Error Messages**: Updated all error messages to explain why Chrome for Testing is required
   - **Installation Fixes**: Fixed critical permissions issue where Chrome for Testing lacked execute permissions after download

2. **Session Reuse Workflow**:
   - **New API Method**: Added `get_page()` method to Browser/AsyncBrowser classes
   - **Context Reuse**: Reuses existing browser contexts instead of creating new ones
   - **Intelligent Selection**: Skips extension pages and reuses regular pages
   - **Examples Updated**: Modified all examples to use `get_page()` for session persistence

3. **Developer Workflow Enhancement**:
   - **Browse Command**: Added `playwrightauthor browse` CLI command that launches Chrome for Testing and exits
   - **Session Persistence**: Browser stays running for other scripts to connect
   - **Multiple Instance Prevention**: Detects if Chrome is already running to avoid duplicates
   - **Profile Directory Fix**: Fixed browser profile path to use proper `profiles/` subdirectory

4. **Documentation Updates**:
   - **CHANGELOG.md**: Added comprehensive documentation of Chrome for Testing exclusivity
   - **README.md**: Added detailed pre-authorized sessions workflow as recommended approach
   - **Quick Reference**: Updated with new browse command and get_page() method examples

### Technical Details

- **Root Cause**: Google disabled CDP automation with user profiles in regular Chrome
- **Solution**: Exclusive use of Chrome for Testing (official Google build for automation)
- **Key Fix**: Comprehensive permission setting for all Chrome.app bundle executables on macOS
- **Session Reuse**: Implemented context reuse instead of creating new browser contexts

### Results Achieved

- **Reliability**: Scripts now work consistently with Chrome for Testing
- **User Experience**: One-time manual login, then all scripts reuse the session
- **Developer Efficiency**: No need to handle authentication in automation code
- **Performance**: Reusing contexts is faster than creating new ones

### Example Workflow

```bash
# Step 1: Launch Chrome for Testing
playwrightauthor browse

# Step 2: Manually log into services in the browser

# Step 3: Run automation scripts - they reuse the session
python scrape_linkedin_feed.py
```

**Current Status**: Chrome for Testing exclusivity is fully implemented with comprehensive session reuse workflow. PlaywrightAuthor now provides enterprise-grade browser automation with persistent authentication sessions.
</document_content>
</document>

<document index="18">
<source>accessibility-report.md</source>
<document_content>
# Documentation Accessibility Report  
Generated: 2025-08-05 01:47:57  

## Summary  
- **Total Files**: 18  
- **Total Issues**: 118  
- **Errors**: 84 ❌  
- **Warnings**: 32 ⚠️  
- **Info**: 2 ℹ️  

## Issues by Type  

- **Heading Structure**: 116  
- **Language Clarity**: 2  

## Detailed Issues  

### architecture/browser-lifecycle.md  
**1 issue**  

#### Line 437: Heading Structure ❌  
**Element**: `State Management Options`  
**Problem**: Skips from H1 to H3  
**Fix**: Use H2 or restructure  

### architecture/components.md  
**3 issues**  

#### Line 94: Heading Structure ❌  
**Element**: `2. BrowserManager`  
**Problem**: Skips from H1 to H3  
**Fix**: Use H2 or restructure  

#### Line 499: Heading Structure ❌  
**Element**: `9. Exception Hierarchy`  
**Problem**: Skips from H1 to H3  
**Fix**: Use H2 or restructure  

#### Line 639: Heading Structure ❌  
**Element**: `2. **Factory Pattern**`  
**Problem**: Skips from H1 to H3  
**Fix**: Use H2 or restructure  

### architecture/error-handling.md  
**1 issue**  

#### Line 558: Heading Structure ❌  
**Element**: `Diagnostic Report Format`  
**Problem**: Skips from H1 to H3  
**Fix**: Use H2 or restructure  

### auth/github.md  
**8 issues**  

Multiple headings skip levels from H1 to H3:  
- `Step 2: Handling 2FA` (Line 38)  
- `Step 3: Personal Access Token Setup` (Line 71)  
- `GitHub Enterprise` (Line 123)  
- `OAuth App Authorization` (Line 141)  
- `Issue 2: Rate Limiting` (Line 191)  
- `Issue 3: Session Timeout` (Line 211)  
- `Monitor API Rate Limits` (Line 255)  
- `Pull Request Automation` (Line 298)  

**Fix all**: Replace H3 with H2 or adjust hierarchy  

### auth/gmail.md  
**7 issues**  

Headings skipping from H1 to H3:  
- `Step 2: Handling 2FA` (Line 36)  
- `Step 3: Verify Persistent Login` (Line 61)  
- `Google Workspace (G Suite)` (Line 94)  
- `App Passwords (Less Secure Apps Alternative)` (Line 110)  
- `Issue 3: Session Expires Frequently` (Line 149)  
- `Issue 4: 2FA Issues` (Line 168)  
- `Export/Import Profile` (Line 207)  

**Fix all**: Use H2 instead  

### auth/index.md  
**3 issues**  

#### Line 10: Language Clarity ℹ️  
**Element**: `2. **Manual Login**: You log in manually (just onc...`  
**Problem**: Vague language  
**Fix**: Clarify that login happens once per session  

#### Line 62: Heading Structure ❌  
**Element**: `Multi-Step Authentication`  
**Problem**: Skips from H1 to H3  
**Fix**: Use H2  

#### Line 79: Heading Structure ❌  
**Element**: `Profile Management`  
**Problem**: Skips from H1 to H3  
**Fix**: Use H2  

### auth/linkedin.md  
**9 issues**  

Skipped heading levels:  
- `Step 2: Handling Security Challenges` (Line 40)  
- `Step 3: Remember Device` (Line 73)  
- `LinkedIn Sales Navigator` (Line 113)  
- `LinkedIn Learning` (Line 131)  
- `Issue 2: CAPTCHA Challenges` (Line 177)  
- `Issue 3: Account Restrictions` (Line 199)  
- `Monitor Activity Limits` (Line 242)  
- `Content Posting` (Line 305)  
- `Lead Generation` (Line 332)  

**Fix all**: Use H2  

### auth/troubleshooting.md  
**5 issues**  

Headings skip from H1 to H3:  
- `Issue 2: Network/Connection Problems` (Line 107)  
- `Issue 3: Cookie/JavaScript Blocked` (Line 154)  
- `Issue 4: Authentication Failures` (Line 198)  
- `Issue 5: Session Not Persisting` (Line 242)  
- `Monitor Authentication Health` (Line 333)  

**Fix all**: Use H2  

### performance/connection-pooling.md  
**9 issues**  

Duplicate H1 headings:  
- `Close all connections` (Line 267)  
- `Usage` (Lines 448, 525, 602, 657, 771)  

Skipped heading levels:  
- `2. Priority Queue Pool` (Line 540)  
- `3. Geographic Pool Distribution` (Line 615)  
- `Connection Warming` (Line 846)  

**Fix**: Make heading text unique or add context. Use H2 where skipping occurs  

### performance/index.md  
**11 issues**  

Duplicate H1 headings:  
- `Usage` (Lines 343, 408, 520, 675, 747)  
- `Process page...` (Line 417)  

Skipped heading levels:  
- `CPU Optimization` (Line 151)  
- `Network Optimization` (Line 213)  
- `Page Recycling` (Line 366)  
- `Real-time Dashboard` (Line 544)  
- `Memory Leak Detection` (Line 687)  

**Fix**: Rename duplicates; replace skipped H3s with H2  

### performance/memory-management.md  
**10 issues**  

Duplicate H1 headings:  
- `Usage` (Lines 224, 296, 364, 516, 597)  
- `Process page` (Line 429)  

Skipped heading levels:  
- `2. Resource Blocking` (Line 184)  
- `3. Cache Management` (Line 235)  
- `4. Memory-Aware Automation` (Line 306)  
- `Memory Leak Detector` (Line 457)  

**Fix**: Add distinguishing context to duplicates; use H2 for skips  

### performance/monitoring.md  
**2 issues**  

#### Line 757: Heading Structure ❌  
**Element**: `OpenTelemetry Integration`  
**Problem**: Skips from H1 to H3  
**Fix**: Use H2  

#### Line 916: Heading Structure ⚠️  
**Element**: `Usage`  
**Problem**: Duplicate H1  
**Fix**: Add context  

### platforms/index.md  
**7 issues**  

Duplicate H1 headings:  
- `Your automation code` (Lines 43, 48)  

Duplicate H3 headings:  
- `macOS` (Line 154)  
- `Windows` (Line 162)  
- `Linux` (Line 169)  

**Fix**: Distinguish heading content  

### platforms/linux.md  
**21 issues**  

Duplicate H1 headings:  
- `Install Chrome` (Lines 55, 176)  
- `Or install Chromium` (Lines 58, 68)  
- `Install PlaywrightAuthor` (Line 183)  

Skipped heading levels:  
- `Fedora/CentOS/RHEL` (Line 41)  
- `Arch Linux` (Line 62)  
- `Alpine Linux (Minimal/Docker)` (Line 72)  
- `Automated Distribution Detection` (Line 87)  
- `Docker Compose with VNC Access` (Line 198)  
- `Kubernetes Deployment` (Line 230)  
- `Wayland Support` (Line 310)  
- `Virtual Display (Xvfb)` (Line 342)  
- `AppArmor Configuration` (Line 432)  
- `Running as Non-Root` (Line 466)  
- `System Resource Management` (Line 560)  
- `Issue 2: Chrome Crashes` (Line 665)  
- `Issue 3: Permission Issues` (Line 677)  
- `Systemd Service` (Line 704)  

Duplicate H3 headings:  
- `Ubuntu/Debian` (Line 737)  
- `Arch Linux` (Line 747)  

**Fix**: Distinguish duplicate headings; replace skipped H3/H4 with H2  

### platforms/macos.md  
**10 issues**  

Duplicate H1 heading:  
- `Intel Macs` (Line 163)  

Skipped heading levels:  
- `Gatekeeper & Code Signing` (Line 121)  
- `Handling Gatekeeper in Python` (Line 137)  
- `Homebrew Chrome Detection` (Line 173)  
- `Multiple Display Handling` (Line 215)  
- `Activity Monitor Integration` (Line 278)  
- `Issue 2: Chrome Won't Launch` (Line 328)  
- `Issue 3: Slow Performance` (Line 384)  
- `System Integration` (Line 406)  

#### Line 381: Language Clarity ℹ️  
**Element**: `print("\n⚠️  Fix the issues above before proceedin...`  
**Problem**: Unclear reference to "above"  
**Fix**: Specify which issues  

**Fix**: Rename duplicates; replace skips with H2  

### platforms/windows.md  
**11 issues**  

Skipped heading levels:  
- `Windows Defender & Antivirus` (Line 67)  
- `Programmatic Exclusion Management` (Line 88)  
- `PowerShell Execution Policies` (Line 123)  
- `Python Integration` (Line 138)  
- `Profile Storage` (Line 230)  
- `Multi-Monitor Setup` (Line 310)  
- `Process Priority Management` (Line 380)  
- `Issue 2: Permission Denied Errors` (Line 494)  
- `Issue 3: Corporate Proxy Issues` (Line 529)  
- `Windows Services Integration` (Line 552)  
- `AppLocker Considerations` (Line 635)  

**Fix**: Replace skipped H3/H4 with H2  

## Accessibility Guidelines  

Checked against:  
- **WCAG 2.1 Level AA**  
- **Section 508**  
- **Markdown accessibility** best practices  

Resources:  
- [WCAG 2.1 Quick Reference](https://www.w3.org/WAI/WCAG21/quickref/)  
- [Markdown Syntax Guide](https://daringfireball.net/projects/markdown/syntax)
</document_content>
</document>

<document index="19">
<source>docs/architecture/browser-lifecycle.md</source>
<document_content>
# Browser Lifecycle Management

This document details how PlaywrightAuthor manages the Chrome browser lifecycle from installation to connection management.

## Lifecycle Overview

```mermaid
graph TD
    Start([User: with Browser...]) --> Check{Chrome Running?}
    
    Check -->|Yes| Connect[Connect to Existing]
    Check -->|No| Find{Chrome Installed?}
    
    Find -->|Yes| Launch[Launch Chrome]
    Find -->|No| Install[Install Chrome]
    
    Install --> Launch
    Launch --> Wait[Wait for CDP]
    Wait --> Connect
    
    Connect --> Ready[Browser Ready]
    Ready --> Use[User Operations]
    Use --> Exit{Exit Context?}
    
    Exit -->|No| Use
    Exit -->|Yes| Cleanup[Cleanup Resources]
    Cleanup --> KeepAlive[Chrome Stays Running]
    
    style Start fill:#e1f5e1
    style Ready fill:#a5d6a5
    style KeepAlive fill:#66bb6a
```

## Phase 1: Discovery & Installation

### Chrome Discovery Process

```mermaid
flowchart LR
    subgraph "Platform Detection"
        OS{Operating System}
        OS -->|Windows| Win[Windows Paths]
        OS -->|macOS| Mac[macOS Paths]
        OS -->|Linux| Lin[Linux Paths]
    end
    
    subgraph "Search Strategy"
        Win --> WinPaths[Program Files<br/>LocalAppData<br/>Registry]
        Mac --> MacPaths[Applications<br/>User Applications<br/>Homebrew]
        Lin --> LinPaths[usr/bin<br/>Snap<br/>Flatpak]
    end
    
    subgraph "Validation"
        WinPaths --> Check[Verify Executable]
        MacPaths --> Check
        LinPaths --> Check
        Check --> Found{Valid Chrome?}
    end
    
    Found -->|Yes| Cache[Cache Path]
    Found -->|No| Download[Download Chrome]
```

**Implementation**: `src/playwrightauthor/browser/finder.py`

The finder module:
1. Generates platform-specific search paths
2. Checks common installation locations
3. Validates executable permissions
4. Caches successful finds for performance

### Chrome Installation Process

```mermaid
sequenceDiagram
    participant User
    participant Installer
    participant LKGV as Chrome LKGV API
    participant Download
    participant FileSystem
    
    User->>Installer: Chrome not found
    Installer->>LKGV: GET last-known-good-version
    LKGV-->>Installer: Version & URLs
    
    Installer->>Download: Download Chrome.zip
    Note over Download: Progress bar shown
    Download-->>Installer: Chrome binary
    
    Installer->>Installer: Verify SHA256
    Installer->>FileSystem: Extract to install_dir
    FileSystem-->>Installer: Installation complete
    Installer-->>User: Chrome ready
```

**Implementation**: `src/playwrightauthor/browser/installer.py`

Key features:
- Downloads from Google's official LKGV endpoint
- SHA256 integrity verification
- Progress reporting during download
- Atomic installation (no partial installs)

## Phase 2: Process Management

### Chrome Launch Sequence

```mermaid
stateDiagram-v2
    [*] --> CheckExisting: Launch Request
    
    state CheckExisting {
        [*] --> SearchDebugPort
        SearchDebugPort --> FoundDebug: Port 9222 Active
        SearchDebugPort --> SearchNormal: No Debug Port
        SearchNormal --> FoundNormal: Regular Chrome
        SearchNormal --> NoneFound: No Chrome
    }
    
    FoundDebug --> UseExisting: Already Perfect
    FoundNormal --> KillNormal: Kill Non-Debug
    NoneFound --> LaunchNew: Fresh Start
    
    KillNormal --> LaunchNew: Terminated
    
    state LaunchNew {
        [*] --> StartProcess
        StartProcess --> WaitForPort
        WaitForPort --> VerifyCDP
        VerifyCDP --> Success
        WaitForPort --> Retry: Timeout
        Retry --> StartProcess: Attempt < 3
        Retry --> Failed: Max Attempts
    }
    
    UseExisting --> [*]: Connected
    Success --> [*]: Connected
    Failed --> [*]: Error
```

**Implementation**: `src/playwrightauthor/browser/launcher.py`

Launch arguments:
```python
args = [
    f"--remote-debugging-port={debug_port}",
    f"--user-data-dir={user_data_dir}",
    "--no-first-run",
    "--no-default-browser-check",
    "--disable-blink-features=AutomationControlled"
]
```

### Process Monitoring

```mermaid
graph TB
    subgraph "Health Monitoring"
        Monitor[Monitor Thread/Task]
        Monitor --> Check1[CDP Health Check]
        Monitor --> Check2[Process Alive Check]
        Monitor --> Check3[Resource Usage]
    end
    
    subgraph "Metrics Collection"
        Check1 --> M1[Response Time]
        Check2 --> M2[Process Status]
        Check3 --> M3[CPU/Memory]
    end
    
    subgraph "Failure Detection"
        M1 --> D1{Timeout?}
        M2 --> D2{Zombie?}
        M3 --> D3{OOM?}
    end
    
    subgraph "Recovery Actions"
        D1 -->|Yes| Restart
        D2 -->|Yes| Restart
        D3 -->|Yes| Restart
        Restart --> Limits{Under Limit?}
        Limits -->|Yes| LaunchNew
        Limits -->|No| Fail
    end
```

**Implementation**: `src/playwrightauthor/monitoring.py`

## Phase 3: Connection Management

### CDP Connection Flow

```mermaid
sequenceDiagram
    participant Browser as Browser Class
    participant Health as Health Checker
    participant CDP
    participant Playwright
    participant Monitor
    
    Browser->>Health: Check CDP Health
    Health->>CDP: GET /json/version
    
    alt CDP Healthy
        CDP-->>Health: 200 OK + Info
        Health-->>Browser: Healthy
        Browser->>Playwright: connect_over_cdp()
        Playwright->>CDP: WebSocket Connect
        CDP-->>Playwright: Connected
        Playwright-->>Browser: Browser Instance
        Browser->>Monitor: Start Monitoring
    else CDP Unhealthy
        CDP-->>Health: Error/Timeout
        Health-->>Browser: Unhealthy
        Browser->>Browser: Retry with Backoff
    end
```

### Connection Retry Strategy

```mermaid
graph LR
    subgraph "Retry Logic"
        Attempt1[Attempt 1<br/>Wait 1s] --> Fail1{Failed?}
        Fail1 -->|Yes| Attempt2[Attempt 2<br/>Wait 2s]
        Attempt2 --> Fail2{Failed?}
        Fail2 -->|Yes| Attempt3[Attempt 3<br/>Wait 4s]
        Attempt3 --> Fail3{Failed?}
        Fail3 -->|Yes| Error[Give Up]
        
        Fail1 -->|No| Success
        Fail2 -->|No| Success
        Fail3 -->|No| Success
    end
    
    style Attempt1 fill:#ffe0b2
    style Attempt2 fill:#ffcc80
    style Attempt3 fill:#ffb74d
    style Error fill:#ff7043
    style Success fill:#66bb6a
```

**Implementation**: `src/playwrightauthor/connection.py`

## Phase 4: State Persistence

### Profile Management

```mermaid
graph TB
    subgraph "Profile Structure"
        Root[playwrightauthor/]
        Profiles[profiles/]
        Default[default/]
        Work[work/]
        Personal[personal/]
        
        Root --> Profiles
        Profiles --> Default
        Profiles --> Work  
        Profiles --> Personal
    end
    
    subgraph "Chrome Profile Data"
        Default --> D1[Cookies]
        Default --> D2[Local Storage]
        Default --> D3[Session Storage]
        Default --> D4[IndexedDB]
        Default --> D5[Cache]
        
        Work --> W1[Cookies]
        Work --> W2[Local Storage]
        Work --> W3[Session Storage]
    end
    
    subgraph "State File"
        State[state.json]
        State --> ChromePath[chrome_path]
        State --> Profiles2[profiles]
        State --> Version[version]
        State --> LastCheck[last_check]
    end
```

### Session Persistence Flow

```mermaid
sequenceDiagram
    participant User
    participant Chrome
    participant Website
    participant Profile as Profile Storage
    
    User->>Chrome: Login to Website
    Chrome->>Website: POST Credentials
    Website-->>Chrome: Set-Cookie Headers
    Chrome->>Chrome: Store in Memory
    
    Chrome->>Profile: Write Cookies DB
    Chrome->>Profile: Write Local Storage
    Chrome->>Profile: Write Session Data
    
    Note over Profile: Data persisted to disk
    
    User->>User: Close Script
    Note over Chrome: Chrome keeps running
    Note over Profile: Data remains on disk
    
    User->>Chrome: New Script Run
    Chrome->>Profile: Load Cookies DB
    Chrome->>Profile: Load Local Storage
    Profile-->>Chrome: Session Data
    
    Chrome->>Website: Request with Cookies
    Website-->>Chrome: Authenticated Content
```

## Phase 5: Cleanup & Recovery

### Graceful Shutdown

```mermaid
stateDiagram-v2
    [*] --> ExitContext: __exit__ called
    
    ExitContext --> StopMonitor: Stop Monitoring
    StopMonitor --> CollectMetrics: Get Final Metrics
    CollectMetrics --> LogMetrics: Log Performance
    
    LogMetrics --> CloseBrowser: browser.close()
    CloseBrowser --> StopPlaywright: playwright.stop()
    
    StopPlaywright --> KeepChrome: Chrome Stays Running
    KeepChrome --> [*]: Session Preserved
```

### Crash Recovery

```mermaid
flowchart TD
    Crash[Browser Crash Detected] --> Check{Recovery Enabled?}
    
    Check -->|No| Log[Log Error]
    Check -->|Yes| Count{Attempts < Max?}
    
    Count -->|No| Fail[Stop Recovery]
    Count -->|Yes| Clean[Cleanup Old Connection]
    
    Clean --> Relaunch[Launch New Chrome]
    Relaunch --> Reconnect[Connect Playwright]
    Reconnect --> Restore[Restore Monitoring]
    
    Restore --> Success{Success?}
    Success -->|Yes| Resume[Resume Operations]
    Success -->|No| Increment[Increment Counter]
    
    Increment --> Count
    
    style Crash fill:#ff7043
    style Resume fill:#66bb6a
    style Fail fill:#ff5252
```

## Performance Considerations

### Connection Pooling (Future)

```mermaid
graph TB
    subgraph "Connection Pool"
        Pool[Connection Pool Manager]
        C1[Connection 1<br/>Profile: default]
        C2[Connection 2<br/>Profile: work]
        C3[Connection 3<br/>Profile: personal]
        
        Pool --> C1
        Pool --> C2
        Pool --> C3
    end
    
    subgraph "Request Handling"
        Req1[Request Profile: default] --> Pool
        Req2[Request Profile: work] --> Pool
        Pool --> Check{Available?}
        Check -->|Yes| Reuse[Return Existing]
        Check -->|No| Create[Create New]
    end
```

### Resource Management

```mermaid
graph LR
    subgraph "Resource Monitoring"
        Monitor --> CPU[CPU Usage]
        Monitor --> Memory[Memory Usage]
        Monitor --> Handles[File Handles]
    end
    
    subgraph "Thresholds"
        CPU --> T1{> 80%?}
        Memory --> T2{> 2GB?}
        Handles --> T3{> 1000?}
    end
    
    subgraph "Actions"
        T1 -->|Yes| Throttle[Reduce Activity]
        T2 -->|Yes| GC[Force Garbage Collection]
        T3 -->|Yes| Close[Close Unused Pages]
    end
```

## Configuration Options

### Browser Launch Configuration

```python
# config.py settings that affect lifecycle
browser_config = {
    "debug_port": 9222,          # CDP port
    "headless": False,           # Show browser window
    "timeout": 30000,            # Launch timeout (ms)
    "viewport_width": 1280,      # Initial viewport
    "viewport_height": 720,
    "args": [],                  # Additional Chrome args
}

# Monitoring configuration  
monitoring_config = {
    "enabled": True,             # Enable health monitoring
    "check_interval": 30.0,      # Seconds between checks
    "enable_crash_recovery": True,
    "max_restart_attempts": 3,
}
```

### State Management Options

```python
# State persistence options
state_config = {
    "cache_chrome_path": True,   # Cache executable location
    "profile_isolation": True,   # Separate profile directories
    "state_version": 1,         # State schema version
}
```

## Additional Resources

- [Component Details](components.md)
- [Error Handling](error-handling.md)
- [Performance Guide](../performance/index.md)
- [Configuration Reference](../../api/config.md)
</document_content>
</document>

<document index="20">
<source>docs/architecture/components.md</source>
<document_content>
# Component Architecture

This document describes the components that make up PlaywrightAuthor's architecture.

## Core Components Overview

```mermaid
graph TB
    subgraph "Public API Layer"
        Browser[Browser Class]
        AsyncBrowser[AsyncBrowser Class]
        CLI[CLI Interface]
    end
    
    subgraph "Management Layer"
        BrowserManager[BrowserManager]
        ConnectionManager[ConnectionManager]
        StateManager[StateManager]
        ConfigManager[ConfigManager]
    end
    
    subgraph "Browser Operations"
        Finder[ChromeFinder]
        Installer[ChromeInstaller]
        Launcher[ChromeLauncher]
        Process[ProcessManager]
    end
    
    subgraph "Support Services"
        Monitor[BrowserMonitor]
        Logger[Logger]
        Paths[PathManager]
        Exceptions[Exception Classes]
    end
    
    Browser --> BrowserManager
    AsyncBrowser --> BrowserManager
    CLI --> Browser
    
    BrowserManager --> Finder
    BrowserManager --> Installer
    BrowserManager --> Launcher
    BrowserManager --> Process
    BrowserManager --> ConnectionManager
    
    Browser --> StateManager
    Browser --> ConfigManager
    Browser --> Monitor
    
    Process --> Logger
    Monitor --> Logger
    Launcher --> Paths
```

## Component Details

### 1. Browser & AsyncBrowser Classes
**Location**: `src/playwrightauthor/author.py`

Main entry points for users, implementing context managers for browser lifecycle management.

```python
# Sync API
class Browser:
    """Synchronous browser context manager."""
    
    def __init__(self, profile: str = "default", **kwargs):
        """Initialize with profile and optional config overrides."""
        
    def __enter__(self) -> PlaywrightBrowser:
        """Launch/connect browser and return Playwright Browser object."""
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Cleanup resources but keep Chrome running."""

# Async API  
class AsyncBrowser:
    """Asynchronous browser context manager."""
    
    async def __aenter__(self) -> PlaywrightBrowser:
        """Async launch/connect browser."""
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async cleanup resources."""
```

**Features**:
- Profile-based session management
- Automatic Chrome installation
- Connection reuse
- Health monitoring integration
- Graceful error handling

### 2. BrowserManager
**Location**: `src/playwrightauthor/browser_manager.py`

Central orchestrator for browser operations.

```mermaid
sequenceDiagram
    participant User
    participant BrowserManager
    participant Finder
    participant Installer
    participant Launcher
    participant Connection
    
    User->>BrowserManager: ensure_browser()
    BrowserManager->>Finder: find_chrome()
    
    alt Chrome not found
        Finder-->>BrowserManager: None
        BrowserManager->>Installer: install_chrome()
        Installer-->>BrowserManager: chrome_path
    else Chrome found
        Finder-->>BrowserManager: chrome_path
    end
    
    BrowserManager->>Launcher: launch_chrome()
    Launcher-->>BrowserManager: process_info
    
    BrowserManager->>Connection: connect_playwright()
    Connection-->>BrowserManager: browser_instance
    
    BrowserManager-->>User: browser
```

**Responsibilities**:
- Orchestrates browser discovery, installation, and launch
- Manages Chrome process lifecycle
- Handles connection establishment
- Coordinates with state manager

### 3. Configuration System
**Location**: `src/playwrightauthor/config.py`

Hierarchical configuration with sensible defaults.

```mermaid
graph LR
    subgraph "Configuration Hierarchy"
        Default[Default Config]
        File[config.toml]
        Env[Environment Variables]
        Runtime[Runtime Overrides]
        Final[Final Config]
        
        Default --> File
        File --> Env
        Env --> Runtime
        Runtime --> Final
    end
    
    subgraph "Config Categories"
        Browser[BrowserConfig]
        Connection[ConnectionConfig]
        Monitoring[MonitoringConfig]
        Paths[PathConfig]
    end
    
    Final --> Browser
    Final --> Connection
    Final --> Monitoring
    Final --> Paths
```

**Configuration Classes**:

```python
@dataclass
class BrowserConfig:
    """Browser launch configuration."""
    headless: bool = False
    debug_port: int = 9222
    viewport_width: int = 1280
    viewport_height: int = 720
    args: list[str] = field(default_factory=list)

@dataclass
class ConnectionConfig:
    """Connection settings."""
    timeout: int = 30000
    retry_attempts: int = 3
    retry_delay: float = 1.0
    health_check_timeout: int = 5000

@dataclass
class MonitoringConfig:
    """Health monitoring settings."""
    enabled: bool = True
    check_interval: float = 30.0
    enable_crash_recovery: bool = True
    max_restart_attempts: int = 3
```

### 4. State Management
**Location**: `src/playwrightauthor/state_manager.py`

Persistent state storage for browser information.

```mermaid
stateDiagram-v2
    [*] --> LoadState: Application Start
    
    LoadState --> CheckState: Read state.json
    CheckState --> ValidState: State exists & valid
    CheckState --> EmptyState: No state file
    
    ValidState --> UpdateState: Use cached data
    EmptyState --> UpdateState: Create new state
    
    UpdateState --> SaveState: State changed
    SaveState --> [*]: State persisted
    
    note right of ValidState
        Contains:
        - Chrome path
        - Chrome version
        - Profile info
        - Last check time
    end note
```

**State Structure**:
```json
{
    "version": 1,
    "chrome_path": "/path/to/chrome",
    "chrome_version": "120.0.6099.109",
    "last_check": "2024-01-20T10:30:00Z",
    "profiles": {
        "default": {
            "created": "2024-01-15T08:00:00Z",
            "last_used": "2024-01-20T10:30:00Z"
        }
    }
}
```

### 5. Browser Operations

#### ChromeFinder
**Location**: `src/playwrightauthor/browser/finder.py`

Platform-specific Chrome discovery logic.

```mermaid
graph TD
    subgraph "Platform Detection"
        Start[find_chrome_executable]
        OS{Operating System}
        
        Start --> OS
        OS -->|Windows| WinPaths[Windows Paths]
        OS -->|macOS| MacPaths[macOS Paths]
        OS -->|Linux| LinuxPaths[Linux Paths]
    end
    
    subgraph "Search Strategy"
        WinPaths --> WinSearch[Registry + Program Files]
        MacPaths --> MacSearch[Applications + Homebrew]
        LinuxPaths --> LinSearch[/usr/bin + Snap + Flatpak]
    end
    
    subgraph "Validation"
        WinSearch --> Validate[Verify Executable]
        MacSearch --> Validate
        LinSearch --> Validate
        
        Validate --> Found{Valid Chrome?}
        Found -->|Yes| Return[Return Path]
        Found -->|No| NotFound[Return None]
    end
```

**Search Locations**:
- **Windows**: Registry, Program Files, LocalAppData
- **macOS**: /Applications, ~/Applications, Homebrew
- **Linux**: /usr/bin, Snap packages, Flatpak, AppImage

#### ChromeInstaller
**Location**: `src/playwrightauthor/browser/installer.py`

Downloads and installs Chrome for Testing.

```mermaid
sequenceDiagram
    participant Installer
    participant LKGV as Chrome LKGV API
    participant Download
    participant FileSystem
    
    Installer->>LKGV: GET /last-known-good-version
    LKGV-->>Installer: {"channels": {"Stable": {...}}}
    
    Installer->>Installer: Select platform URL
    Installer->>Download: Download Chrome.zip
    
    loop Progress Updates
        Download-->>Installer: Progress %
        Installer-->>User: Update progress bar
    end
    
    Download-->>Installer: Complete
    
    Installer->>Installer: Verify SHA256
    Installer->>FileSystem: Extract archive
    FileSystem-->>Installer: Extraction complete
    
    alt Platform is macOS
        Installer->>FileSystem: Remove quarantine
        Installer->>FileSystem: Set permissions
    else Platform is Linux
        Installer->>FileSystem: Set executable
    end
    
    Installer-->>User: Installation complete
```

#### ChromeLauncher
**Location**: `src/playwrightauthor/browser/launcher.py`

Manages Chrome process launch with proper arguments.

**Launch Arguments**:
```python
CHROME_ARGS = [
    f"--remote-debugging-port={debug_port}",
    f"--user-data-dir={user_data_dir}",
    "--no-first-run",
    "--no-default-browser-check",
    "--disable-blink-features=AutomationControlled",
    "--disable-component-extensions-with-background-pages",
    "--disable-background-networking",
    "--disable-background-timer-throttling",
    "--disable-backgrounding-occluded-windows",
    "--disable-renderer-backgrounding",
    "--disable-features=TranslateUI",
    "--disable-ipc-flooding-protection",
    "--enable-features=NetworkService,NetworkServiceInProcess"
]
```

#### ProcessManager
**Location**: `src/playwrightauthor/browser/process.py`

Handles process lifecycle and monitoring.

```mermaid
stateDiagram-v2
    [*] --> FindProcess: Check existing Chrome
    
    FindProcess --> DebugProcess: Found with debug port
    FindProcess --> NormalProcess: Found without debug
    FindProcess --> NoProcess: Not found
    
    DebugProcess --> UseExisting: Reuse connection
    NormalProcess --> KillProcess: Terminate
    KillProcess --> LaunchNew: Start fresh
    NoProcess --> LaunchNew: Start fresh
    
    LaunchNew --> MonitorProcess: Process started
    UseExisting --> MonitorProcess: Process running
    
    MonitorProcess --> HealthCheck: Periodic checks
    HealthCheck --> Healthy: Process responsive
    HealthCheck --> Unhealthy: Process hung/crashed
    
    Healthy --> MonitorProcess: Continue
    Unhealthy --> RestartProcess: Recovery
    RestartProcess --> LaunchNew: Restart
```

### 6. Connection Management
**Location**: `src/playwrightauthor/connection.py`

Handles CDP connection establishment and health checks.

```python
class ConnectionManager:
    """Manages Chrome DevTools Protocol connections."""
    
    def connect_playwright(self, endpoint_url: str) -> Browser:
        """Establish Playwright connection to Chrome."""
        
    def check_health(self) -> ConnectionHealth:
        """Verify CDP endpoint is responsive."""
        
    def wait_for_ready(self, timeout: int) -> bool:
        """Wait for Chrome to be ready for connections."""
```

**Health Check Flow**:
```mermaid
graph LR
    Start[Health Check] --> Request[GET /json/version]
    Request --> Response{Response?}
    
    Response -->|200 OK| Parse[Parse JSON]
    Response -->|Timeout| Unhealthy[Mark Unhealthy]
    Response -->|Error| Unhealthy
    
    Parse --> Validate{Valid CDP?}
    Validate -->|Yes| Healthy[Mark Healthy]
    Validate -->|No| Unhealthy
    
    Healthy --> Metrics[Update Metrics]
    Unhealthy --> Retry{Retry?}
    
    Retry -->|Yes| Start
    Retry -->|No| Alert[Trigger Recovery]
```

### 7. Monitoring System
**Location**: `src/playwrightauthor/monitoring.py`

Production-grade health monitoring and recovery.

```mermaid
graph TB
    subgraph "Monitoring Components"
        Monitor[BrowserMonitor]
        Metrics[BrowserMetrics]
        HealthCheck[Health Checker]
        Recovery[Recovery Handler]
    end
    
    subgraph "Metrics Collection"
        CPU[CPU Usage]
        Memory[Memory Usage]
        Response[Response Time]
        Crashes[Crash Count]
    end
    
    subgraph "Recovery Actions"
        Restart[Restart Browser]
        Reconnect[Reconnect CDP]
        Alert[Alert User]
        Fallback[Fallback Mode]
    end
    
    Monitor --> Metrics
    Monitor --> HealthCheck
    HealthCheck --> Recovery
    
    Metrics --> CPU & Memory & Response & Crashes
    
    Recovery --> Restart
    Recovery --> Reconnect
    Recovery --> Alert
    Recovery --> Fallback
```

**Monitoring Features**:
- Periodic health checks
- Resource usage tracking
- Crash detection and recovery
- Performance metrics collection
- Configurable thresholds
- Automatic restart with backoff

### 8. CLI Interface
**Location**: `src/playwrightauthor/cli.py`

Fire-powered command-line interface.

```mermaid
graph LR
    CLI[playwrightauthor] --> Status[status]
    CLI --> ClearCache[clear-cache]
    CLI --> Login[login]
    CLI --> Profile[profile]
    CLI --> Health[health]
    
    Profile --> List[list]
    Profile --> Create[create]
    Profile --> Delete[delete]
    Profile --> Export[export]
    Profile --> Import[import]
```

**Command Examples**:
```bash
# Check browser status
playwrightauthor status

# Clear cache but keep profiles
playwrightauthor clear-cache --keep-profiles

# Manage profiles
playwrightauthor profile list
playwrightauthor profile create work
playwrightauthor profile export default backup.zip

# Interactive login
playwrightauthor login github
```

### 9. Exception Hierarchy
**Location**: `src/playwrightauthor/exceptions.py`

Structured exception handling with user guidance.

```mermaid
graph TD
    BaseException[PlaywrightAuthorError]
    
    BaseException --> BrowserError[BrowserError]
    BaseException --> ConfigError[ConfigurationError]
    BaseException --> StateError[StateError]
    
    BrowserError --> LaunchError[BrowserLaunchError]
    BrowserError --> ConnectError[BrowserConnectionError]
    BrowserError --> InstallError[BrowserInstallationError]
    
    LaunchError --> ProcessError[ProcessStartError]
    LaunchError --> PortError[PortInUseError]
    
    ConnectError --> TimeoutError[ConnectionTimeoutError]
    ConnectError --> CDPError[CDPError]
```

**Exception Features**:
- User-friendly error messages
- Suggested solutions
- Diagnostic information
- Recovery actions

### 10. Utility Components

#### Logger
**Location**: `src/playwrightauthor/utils/logger.py`

Loguru-based logging with rich formatting.

```python
def configure(verbose: bool = False) -> Logger:
    """Configure application logger."""
    logger.remove()  # Remove default handler
    
    if verbose:
        level = "DEBUG"
        format = "<green>{time:HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>"
    else:
        level = "INFO"
        format = "<green>{time:HH:mm:ss}</green> | <level>{message}</level>"
    
    logger.add(sys.stderr, format=format, level=level)
    return logger
```

#### PathManager
**Location**: `src/playwrightauthor/utils/paths.py`

Cross-platform path resolution using platformdirs.

```python
def data_dir() -> Path:
    """Get platform-specific data directory."""
    # Windows: %LOCALAPPDATA%\playwrightauthor
    # macOS: ~/Library/Application Support/playwrightauthor
    # Linux: ~/.local/share/playwrightauthor
    
def cache_dir() -> Path:
    """Get platform-specific cache directory."""
    # Windows: %LOCALAPPDATA%\playwrightauthor\Cache
    # macOS: ~/Library/Caches/playwrightauthor
    # Linux: ~/.cache/playwrightauthor
```

## Component Interactions

### Startup Sequence

```mermaid
sequenceDiagram
    participant User
    participant Browser
    participant Config
    participant State
    participant BrowserManager
    participant Monitor
    
    User->>Browser: with Browser() as browser
    Browser->>Config: Load configuration
    Config-->>Browser: Config object
    
    Browser->>State: Load state
    State-->>Browser: State data
    
    Browser->>BrowserManager: ensure_browser()
    BrowserManager-->>Browser: Chrome ready
    
    Browser->>BrowserManager: connect()
    BrowserManager-->>Browser: Playwright browser
    
    Browser->>Monitor: Start monitoring
    Monitor-->>Browser: Monitor started
    
    Browser-->>User: browser instance
```

### Error Recovery Flow

```mermaid
flowchart TD
    Error[Error Detected] --> Type{Error Type}
    
    Type -->|Connection| ConnRetry[Connection Retry]
    Type -->|Process| ProcRestart[Process Restart]
    Type -->|Installation| Install[Reinstall Chrome]
    
    ConnRetry --> Success1{Success?}
    Success1 -->|Yes| Resume[Resume Operation]
    Success1 -->|No| ProcRestart
    
    ProcRestart --> Success2{Success?}
    Success2 -->|Yes| Resume
    Success2 -->|No| UserGuide[Show User Guidance]
    
    Install --> Success3{Success?}
    Success3 -->|Yes| Resume
    Success3 -->|No| UserGuide
    
    UserGuide --> Manual[Manual Intervention]
```

## Design Patterns

### 1. **Context Manager Pattern**
Used for automatic resource management:
```python
with Browser() as browser:
    # Browser is ready
    pass
# Chrome keeps running after exit
```

### 2. **Factory Pattern**
BrowserManager acts as a factory for browser instances.

### 3. **Strategy Pattern**
Platform-specific implementations for Chrome discovery.

### 4. **Observer Pattern**
Health monitoring observes browser state changes.

### 5. **Singleton Pattern**
Configuration and state managers are singletons.

## Performance Characteristics

### Memory Usage
- Base library: ~50MB
- Per browser instance: ~200MB
- Per page: ~50-100MB
- Monitoring overhead: ~10MB

### Startup Times
- Cold start (with download): 30-60s
- Cold start (Chrome installed): 2-5s
- Warm start (Chrome running): 0.5-1s
- With monitoring: +0.1s

### Connection Reliability
- Retry attempts: 3 (configurable)
- Backoff strategy: Exponential
- Health check interval: 30s (configurable)
- Recovery time: <5s typical

## Security Considerations

### Profile Isolation
Each profile maintains separate:
- Cookies and session storage
- Cache and local storage
- Extension data
- Browsing history

### Process Security
- Chrome runs with minimal privileges
- Separate user data directories
- No shared state between profiles
- Secure IPC via CDP

### Future: Encryption
- Profile data encryption at rest
- Secure credential storage
- Key derivation from user password
- Automatic lock on idle

## Additional Resources

- [Browser Lifecycle](browser-lifecycle.md)
- [Error Handling](error-handling.md)
- [API Reference](../../api/index.md)
- [Configuration Guide](../configuration/index.md)
- [Performance Tuning](../performance/optimization.md)
</document_content>
</document>

<document index="21">
<source>docs/architecture/error-handling.md</source>
<document_content>
# Error Handling & Recovery

This document details PlaywrightAuthor's error handling system, recovery mechanisms, and user guidance features.

## Error Handling Philosophy

PlaywrightAuthor follows these principles for error handling:

1. **Fail Gracefully**: Never leave the system in a bad state
2. **Guide Users**: Provide clear, actionable error messages
3. **Auto-Recover**: Attempt automatic recovery when safe
4. **Preserve Data**: Never lose user sessions or data
5. **Learn & Adapt**: Use errors to improve future reliability

## Exception Hierarchy

```mermaid
graph TD
    BaseError[PlaywrightAuthorError<br/>Base exception class]
    
    BaseError --> BrowserError[BrowserError<br/>Browser-related issues]
    BaseError --> ConfigError[ConfigurationError<br/>Config problems]
    BaseError --> StateError[StateError<br/>State management issues]
    BaseError --> NetworkError[NetworkError<br/>Network/connection issues]
    
    BrowserError --> LaunchError[BrowserLaunchError<br/>Chrome won't start]
    BrowserError --> InstallError[BrowserInstallationError<br/>Install failed]
    BrowserError --> ProcessError[BrowserProcessError<br/>Process crashed]
    
    NetworkError --> ConnectError[ConnectionError<br/>Can't connect to Chrome]
    NetworkError --> TimeoutError[ConnectionTimeoutError<br/>Operation timed out]
    NetworkError --> CDPError[CDPError<br/>Chrome DevTools Protocol error]
    
    LaunchError --> PortError[PortInUseError<br/>Debug port occupied]
    LaunchError --> ExecError[ExecutableNotFoundError<br/>Chrome not found]
    LaunchError --> PermError[PermissionError<br/>Can't access Chrome]
    
    style BaseError fill:#ff9999
    style BrowserError fill:#ffcc99
    style NetworkError fill:#99ccff
    style ConfigError fill:#99ff99
    style StateError fill:#ffff99
```

## Exception Details

### Base Exception

```python
class PlaywrightAuthorError(Exception):
    """Base exception with user guidance."""
    
    def __init__(
        self, 
        message: str,
        suggestion: str = None,
        diagnostic_info: dict = None
    ):
        self.message = message
        self.suggestion = suggestion
        self.diagnostic_info = diagnostic_info or {}
        super().__init__(self._format_message())
    
    def _format_message(self) -> str:
        """Format exception with guidance."""
        parts = [f"Error: {self.message}"]
        
        if self.suggestion:
            parts.append(f"\nSuggestion: {self.suggestion}")
        
        if self.diagnostic_info:
            parts.append("\nDiagnostic Info:")
            for key, value in self.diagnostic_info.items():
                parts.append(f"   {key}: {value}")
        
        return "\n".join(parts)
```

### Browser Launch Errors

```python
class BrowserLaunchError(BrowserError):
    """Failed to launch Chrome browser."""
    
    @staticmethod
    def port_in_use(port: int) -> "BrowserLaunchError":
        return BrowserLaunchError(
            f"Port {port} is already in use",
            suggestion=(
                f"1. Kill existing Chrome: pkill -f 'chrome.*--remote-debugging-port={port}'\n"
                f"2. Use different port: Browser(debug_port=9333)\n"
                f"3. Let PlaywrightAuthor handle it: Browser(kill_existing=True)"
            ),
            diagnostic_info={
                "port": port,
                "process_check": "ps aux | grep chrome"
            }
        )
    
    @staticmethod
    def executable_not_found(search_paths: list[str]) -> "BrowserLaunchError":
        return BrowserLaunchError(
            "Chrome executable not found",
            suggestion=(
                "1. Let PlaywrightAuthor install it: playwrightauthor install\n"
                "2. Install manually: https://googlechromelabs.github.io/chrome-for-testing/\n"
                "3. Specify path: Browser(chrome_path='/path/to/chrome')"
            ),
            diagnostic_info={
                "searched_paths": search_paths,
                "platform": platform.system()
            }
        )
```

### Connection Errors

```python
class ConnectionTimeoutError(NetworkError):
    """Connection to Chrome timed out."""
    
    @staticmethod
    def cdp_timeout(endpoint: str, timeout: int) -> "ConnectionTimeoutError":
        return ConnectionTimeoutError(
            f"Chrome DevTools Protocol connection timed out",
            suggestion=(
                "1. Check if Chrome is running: ps aux | grep chrome\n"
                "2. Verify CDP endpoint: curl http://localhost:9222/json/version\n"
                "3. Increase timeout: Browser(connection_timeout=60000)\n"
                "4. Check firewall/antivirus settings"
            ),
            diagnostic_info={
                "endpoint": endpoint,
                "timeout_ms": timeout,
                "diagnostic_url": f"{endpoint}/json/version"
            }
        )
```

## Retry Mechanisms

### Connection Retry Strategy

```mermaid
flowchart TD
    Connect[Initial Connection] --> Check{Success?}
    Check -->|Yes| Success[Return Browser]
    Check -->|No| Retry{Retry Count < Max?}
    
    Retry -->|Yes| Wait[Wait with Backoff]
    Retry -->|No| Fail[Raise Exception]
    
    Wait --> Calculate[Calculate Delay]
    Calculate --> Delay1[Attempt 1: 1s]
    Calculate --> Delay2[Attempt 2: 2s]
    Calculate --> Delay3[Attempt 3: 4s]
    Calculate --> DelayN[Attempt N: 2^(N-1)s]
    
    Delay1 --> Connect
    Delay2 --> Connect
    Delay3 --> Connect
    DelayN --> Connect
    
    style Success fill:#90EE90
    style Fail fill:#FFB6C1
```

### Implementation

```python
class RetryStrategy:
    """Configurable retry with exponential backoff."""
    
    def __init__(
        self,
        max_attempts: int = 3,
        base_delay: float = 1.0,
        max_delay: float = 60.0,
        exponential_base: float = 2.0
    ):
        self.max_attempts = max_attempts
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.exponential_base = exponential_base
    
    def execute(self, operation: Callable, *args, **kwargs):
        """Execute operation with retries."""
        last_error = None
        
        for attempt in range(1, self.max_attempts + 1):
            try:
                return operation(*args, **kwargs)
            except RetriableError as e:
                last_error = e
                
                if attempt < self.max_attempts:
                    delay = self.calculate_delay(attempt)
                    logger.warning(
                        f"Attempt {attempt}/{self.max_attempts} failed: {e}. "
                        f"Retrying in {delay:.1f}s..."
                    )
                    time.sleep(delay)
        
        raise last_error
    
    def calculate_delay(self, attempt: int) -> float:
        """Calculate exponential backoff delay."""
        delay = self.base_delay * (self.exponential_base ** (attempt - 1))
        return min(delay, self.max_delay)
```

## Recovery Mechanisms

### Browser Crash Recovery

```mermaid
stateDiagram-v2
    [*] --> Monitoring: Browser Running
    
    Monitoring --> CrashDetected: Health Check Failed
    CrashDetected --> CheckRecovery: Recovery Enabled?
    
    CheckRecovery --> Cleanup: Yes
    CheckRecovery --> NotifyUser: No
    
    Cleanup --> KillZombie: Kill Zombie Process
    KillZombie --> Restart: Launch New Chrome
    
    Restart --> CheckAttempts: Check Restart Count
    CheckAttempts --> Success: Under Limit
    CheckAttempts --> GiveUp: Over Limit
    
    Success --> RestoreState: Restore Connection
    RestoreState --> ResumeMonitor: Resume Monitoring
    ResumeMonitor --> Monitoring
    
    GiveUp --> NotifyUser: Alert User
    NotifyUser --> [*]: Manual Intervention
    
    note right of RestoreState
        - Reuse profile
        - Maintain session
        - Preserve cookies
    end note
```

### Recovery Implementation

```python
class BrowserRecovery:
    """Automatic browser crash recovery."""
    
    def __init__(self, config: RecoveryConfig):
        self.config = config
        self.restart_count = 0
        self.last_restart = None
    
    async def handle_crash(self, error: Exception) -> Browser:
        """Handle browser crash with automatic recovery."""
        logger.error(f"Browser crash detected: {error}")
        
        # Check if recovery is enabled
        if not self.config.enable_crash_recovery:
            raise BrowserCrashError(
                "Browser crashed and automatic recovery is disabled",
                suggestion="Enable recovery: Browser(enable_crash_recovery=True)"
            )
        
        # Check restart limits
        if self.restart_count >= self.config.max_restart_attempts:
            raise BrowserCrashError(
                f"Browser crashed {self.restart_count} times, giving up",
                suggestion=(
                    "1. Check system resources: free -h\n"
                    "2. Review Chrome logs: ~/.config/google-chrome/chrome_debug.log\n"
                    "3. Try different Chrome version\n"
                    "4. Report issue: https://github.com/twardoch/playwrightauthor/issues"
                )
            )
        
        # Implement restart cooldown
        if self.last_restart:
            cooldown = self.config.restart_cooldown
            elapsed = time.time() - self.last_restart
            if elapsed < cooldown:
                wait_time = cooldown - elapsed
                logger.info(f"Waiting {wait_time:.1f}s before restart...")
                await asyncio.sleep(wait_time)
        
        # Attempt recovery
        try:
            logger.info(f"Attempting browser restart ({self.restart_count + 1}/{self.config.max_restart_attempts})...")
            
            # Clean up crashed process
            await self._cleanup_crashed_browser()
            
            # Restart browser
            new_browser = await self._restart_browser()
            
            self.restart_count += 1
            self.last_restart = time.time()
            
            logger.success("Browser recovered successfully!")
            return new_browser
            
        except Exception as e:
            logger.error(f"Recovery failed: {e}")
            raise
```

## User Guidance System

### Intelligent Error Messages

```python
class UserGuidance:
    """Provides contextual help for errors."""
    
    ERROR_GUIDANCE = {
        "permission_denied": {
            "windows": [
                "Run as Administrator",
                "Check Windows Defender settings",
                "Add to antivirus exclusions"
            ],
            "macos": [
                "Grant Terminal permissions in System Preferences",
                "Run: sudo xattr -cr /path/to/chrome",
                "Check Gatekeeper settings"
            ],
            "linux": [
                "Check file permissions: ls -la",
                "Run: chmod +x chrome",
                "Check AppArmor/SELinux policies"
            ]
        },
        "network_error": [
            "Check internet connection",
            "Verify proxy settings",
            "Try: curl http://localhost:9222/json/version",
            "Check firewall rules"
        ],
        "profile_corruption": [
            "Clear profile: playwrightauthor clear-cache",
            "Create new profile: Browser(profile='fresh')",
            "Backup and restore: playwrightauthor profile export/import"
        ]
    }
    
    @classmethod
    def get_guidance(cls, error_type: str, platform: str = None) -> list[str]:
        """Get platform-specific guidance."""
        guidance = cls.ERROR_GUIDANCE.get(error_type, [])
        
        if isinstance(guidance, dict) and platform:
            return guidance.get(platform.lower(), [])
        
        return guidance if isinstance(guidance, list) else []
```

### Interactive Error Resolution

```python
def interactive_error_handler(error: PlaywrightAuthorError):
    """Guide user through error resolution."""
    console = Console()
    
    # Display error
    console.print(f"\nError: {error.message}")
    
    if error.suggestion:
        console.print(f"\nSuggestion:")
        console.print(error.suggestion)
    
    # Offer automated fixes
    if hasattr(error, 'auto_fix_available'):
        if Confirm.ask("\nWould you like to try automatic fix?"):
            try:
                error.auto_fix()
                console.print("Fixed automatically!")
                return True
            except Exception as e:
                console.print(f"Auto-fix failed: {e}")
    
    # Interactive troubleshooting
    if hasattr(error, 'troubleshooting_steps'):
        console.print("\nTroubleshooting Steps:")
        
        for i, step in enumerate(error.troubleshooting_steps, 1):
            console.print(f"{i}. {step['description']}")
            
            if step.get('check_command'):
                result = run_diagnostic(step['check_command'])
                console.print(f"   Result: {result}")
            
            if step.get('requires_input'):
                user_input = Prompt.ask(f"   {step['prompt']}")
                step['handler'](user_input)
    
    return False
```

## Health Check System

### Health Check Flow

```mermaid
sequenceDiagram
    participant Monitor
    participant HealthChecker
    participant Chrome
    participant Metrics
    participant Recovery
    
    loop Every check_interval seconds
        Monitor->>HealthChecker: Perform health check
        
        HealthChecker->>Chrome: GET /json/version
        alt Chrome responds
            Chrome-->>HealthChecker: 200 OK + version info
            HealthChecker->>Metrics: Update success metrics
            
            HealthChecker->>Chrome: Check memory usage
            Chrome-->>HealthChecker: Process stats
            HealthChecker->>Metrics: Update resource metrics
            
        else Chrome unresponsive
            Chrome-->>HealthChecker: Timeout/Error
            HealthChecker->>Metrics: Update failure metrics
            HealthChecker->>Recovery: Trigger recovery
            
            Recovery->>Recovery: Analyze failure type
            Recovery->>Chrome: Attempt recovery
        end
        
        HealthChecker-->>Monitor: Health status
    end
```

### Health Metrics

```python
@dataclass
class HealthMetrics:
    """Browser health metrics."""
    last_check_time: float
    last_success_time: float
    consecutive_failures: int
    total_checks: int
    success_rate: float
    average_response_time: float
    memory_usage_mb: float
    cpu_percent: float
    
    def is_healthy(self) -> bool:
        """Determine if browser is healthy."""
        return (
            self.consecutive_failures < 3 and
            self.success_rate > 0.9 and
            self.average_response_time < 1000 and
            self.memory_usage_mb < 2048
        )
    
    def get_health_score(self) -> float:
        """Calculate health score 0-100."""
        score = 100.0
        
        # Deduct for failures
        score -= self.consecutive_failures * 10
        
        # Deduct for poor success rate
        if self.success_rate < 0.95:
            score -= (0.95 - self.success_rate) * 100
        
        # Deduct for slow response
        if self.average_response_time > 500:
            score -= min(20, (self.average_response_time - 500) / 50)
        
        # Deduct for high memory
        if self.memory_usage_mb > 1024:
            score -= min(20, (self.memory_usage_mb - 1024) / 100)
        
        return max(0, score)
```

## Diagnostic Tools

### Built-in Diagnostics

```python
class DiagnosticRunner:
    """Run diagnostic checks for troubleshooting."""
    
    def run_full_diagnostic(self) -> DiagnosticReport:
        """Run comprehensive diagnostic check."""
        report = DiagnosticReport()
        
        # System checks
        report.add_section("System", {
            "OS": platform.system(),
            "Version": platform.version(),
            "Python": sys.version,
            "PlaywrightAuthor": __version__
        })
        
        # Chrome checks
        chrome_info = self._check_chrome()
        report.add_section("Chrome", chrome_info)
        
        # Network checks
        network_info = self._check_network()
        report.add_section("Network", network_info)
        
        # Profile checks
        profile_info = self._check_profiles()
        report.add_section("Profiles", profile_info)
        
        # Generate recommendations
        report.recommendations = self._generate_recommendations(report)
        
        return report
    
    def _check_chrome(self) -> dict:
        """Check Chrome installation and process."""
        info = {}
        
        # Find Chrome
        try:
            chrome_path = find_chrome_executable()
            info["executable"] = str(chrome_path)
            info["executable_exists"] = chrome_path.exists()
            
            # Check version
            result = subprocess.run(
                [str(chrome_path), "--version"],
                capture_output=True,
                text=True
            )
            info["version"] = result.stdout.strip()
            
        except Exception as e:
            info["error"] = str(e)
        
        # Check running processes
        chrome_processes = []
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            if 'chrome' in proc.info['name'].lower():
                chrome_processes.append({
                    'pid': proc.info['pid'],
                    'debug_port': self._extract_debug_port(proc.info['cmdline'])
                })
        
        info["running_processes"] = chrome_processes
        
        return info
```

### Diagnostic Report Format

```python
class DiagnosticReport:
    """Structured diagnostic report."""
    
    def to_markdown(self) -> str:
        """Generate markdown report."""
        lines = ["# PlaywrightAuthor Diagnostic Report", ""]
        lines.append(f"Generated: {datetime.now().isoformat()}")
        lines.append("")
        
        # Add sections
        for section_name, section_data in self.sections.items():
            lines.append(f"## {section_name}")
            lines.append("")
            
            for key, value in section_data.items():
                lines.append(f"- **{key}**: {value}")
            
            lines.append("")
        
        # Add recommendations
        if self.recommendations:
            lines.append("## Recommendations")
            lines.append("")
            
            for i, rec in enumerate(self.recommendations, 1):
                lines.append(f"{i}. {rec}")
            
            lines.append("")
        
        return "\n".join(lines)
    
    def to_json(self) -> str:
        """Generate JSON report."""
        return json.dumps({
            "timestamp": datetime.now().isoformat(),
            "sections": self.sections,
            "recommendations": self.recommendations,
            "health_score": self.calculate_health_score()
        }, indent=2)
```

## Error Patterns & Solutions

### Common Error Patterns

```mermaid
graph TD
    subgraph "Error Categories"
        Launch[Launch Failures]
        Connect[Connection Issues]
        Runtime[Runtime Errors]
        Resource[Resource Issues]
    end
    
    subgraph "Root Causes"
        Launch --> Port[Port Conflict]
        Launch --> Perms[Permissions]
        Launch --> Missing[Missing Chrome]
        
        Connect --> Firewall[Firewall Block]
        Connect --> Timeout[Slow System]
        Connect --> Version[Version Mismatch]
        
        Runtime --> Crash[Browser Crash]
        Runtime --> Hang[Browser Hang]
        Runtime --> Script[Script Error]
        
        Resource --> Memory[Out of Memory]
        Resource --> CPU[High CPU]
        Resource --> Disk[Disk Full]
    end
    
    subgraph "Solutions"
        Port --> KillProc[Kill Process]
        Perms --> FixPerms[Fix Permissions]
        Missing --> Install[Install Chrome]
        
        Firewall --> Rules[Update Rules]
        Timeout --> Increase[Increase Timeout]
        Version --> Update[Update Library]
        
        Crash --> Restart[Auto Restart]
        Hang --> ForceKill[Force Kill]
        Script --> Debug[Debug Mode]
        
        Memory --> Cleanup[Clean Profiles]
        CPU --> Throttle[Throttle Activity]
        Disk --> FreeSpace[Free Space]
    end
```

### Error Resolution Matrix

| Error Type | Automatic Fix | Manual Fix | Prevention |
|------------|---------------|------------|------------|
| Port in use | Kill process | Change port | Check before launch |
| Chrome missing | Auto-install | Manual install | Cache path |
| Permission denied | Request elevation | Run as admin | Proper setup |
| Connection timeout | Retry with backoff | Increase timeout | Health checks |
| Browser crash | Auto-restart | Debug mode | Resource limits |
| Profile corruption | Create new | Clear cache | Regular backups |
| Network error | Retry | Check proxy | Validate connectivity |
| Out of memory | Clear cache | Restart system | Monitor usage |

## Configuration Options

### Error Handling Configuration

```python
@dataclass
class ErrorHandlingConfig:
    """Error handling configuration."""
    
    # Retry configuration
    max_retry_attempts: int = 3
    retry_base_delay: float = 1.0
    retry_max_delay: float = 60.0
    retry_exponential_base: float = 2.0
    
    # Recovery configuration
    enable_crash_recovery: bool = True
    max_restart_attempts: int = 3
    restart_cooldown: float = 10.0
    preserve_profile_on_crash: bool = True
    
    # User guidance
    show_suggestions: bool = True
    interactive_mode: bool = False
    log_diagnostic_info: bool = True
    
    # Health monitoring
    health_check_interval: float = 30.0
    health_check_timeout: float = 5.0
    unhealthy_threshold: int = 3
```

## Security Considerations

### Error Information Disclosure

1. **Sanitize Error Messages**: Remove sensitive paths and data
2. **Log Rotation**: Implement log size limits and rotation
3. **Diagnostic Permissions**: Require auth for diagnostic endpoints
4. **Profile Protection**: Don't expose profile data in errors

### Safe Recovery Practices

1. **Validate State**: Ensure profile integrity before reuse
2. **Clean Shutdown**: Always attempt graceful shutdown
3. **Resource Limits**: Prevent resource exhaustion attacks
4. **Audit Trail**: Log all recovery attempts

## Additional Resources

- [Component Architecture](components.md)
- [Browser Lifecycle](browser-lifecycle.md)
- [Monitoring System](monitoring.md)
- [Troubleshooting Guide](../auth/troubleshooting.md)
- [API Reference](../../api/exceptions.md)
</document_content>
</document>

<document index="22">
<source>docs/architecture/index.md</source>
<document_content>
# PlaywrightAuthor Architecture

This section describes PlaywrightAuthor's internal architecture, component design, and system flows.

## Overview

PlaywrightAuthor uses a modular architecture that separates concerns for flexibility and maintainability:

```mermaid
graph TB
    subgraph "User Interface"
        CLI[CLI Commands]
        API[Python API]
        REPL[Interactive REPL]
    end
    
    subgraph "Core Layer"
        Browser[Browser Manager]
        Auth[Author Classes]
        Config[Configuration]
        State[State Manager]
    end
    
    subgraph "Browser Layer"
        Finder[Chrome Finder]
        Installer[Chrome Installer]
        Launcher[Process Launcher]
        Process[Process Manager]
    end
    
    subgraph "Support Layer"
        Monitor[Health Monitor]
        Error[Error Handler]
        Logger[Logger]
        Utils[Utilities]
    end
    
    CLI --> Auth
    API --> Auth
    REPL --> Auth
    
    Auth --> Browser
    Auth --> Config
    Auth --> State
    Auth --> Monitor
    
    Browser --> Finder
    Browser --> Installer
    Browser --> Launcher
    Browser --> Process
    
    Browser --> Error
    Monitor --> Logger
    Process --> Utils
```

## Core Components

### [Browser Lifecycle Management](browser-lifecycle.md)
How PlaywrightAuthor manages Chrome instances:
- Installation and discovery
- Process management
- Connection handling
- Session persistence

### [Component Architecture](components.md)
Component breakdown:
- Author classes (Browser/AsyncBrowser)
- Configuration system
- State management
- Browser management modules

### [Error Handling & Recovery](error-handling.md)
Failure handling mechanisms:
- Exception hierarchy
- Retry logic
- User guidance
- Crash recovery

### [Monitoring & Metrics](monitoring.md)
Production monitoring features:
- Health checks
- Performance metrics
- Crash detection
- Resource tracking

## System Flows

### Authentication Flow

```mermaid
sequenceDiagram
    participant User
    participant Browser
    participant Chrome
    participant Website
    participant Storage
    
    User->>Browser: with Browser() as browser
    Browser->>Chrome: Launch/Connect
    Chrome-->>Browser: CDP Connection
    Browser->>User: browser instance
    
    User->>Browser: page.goto("site.com")
    Browser->>Chrome: Navigate
    Chrome->>Website: HTTP Request
    Website-->>Chrome: Login Page
    
    User->>Chrome: Manual Login
    Chrome->>Website: Credentials
    Website-->>Chrome: Set Cookies
    Chrome->>Storage: Save Profile
    
    Note over Storage: Cookies, LocalStorage,<br/>SessionStorage persisted
    
    User->>Browser: exit context
    Browser->>Chrome: Keep Running
    Browser-->>User: Session Saved
```

### Connection Management

```mermaid
stateDiagram-v2
    [*] --> CheckRunning: Browser Request
    
    CheckRunning --> Connected: Already Running
    CheckRunning --> FindChrome: Not Running
    
    FindChrome --> InstallChrome: Not Found
    FindChrome --> LaunchChrome: Found
    
    InstallChrome --> LaunchChrome: Installed
    LaunchChrome --> WaitForCDP: Process Started
    
    WaitForCDP --> Connected: CDP Ready
    WaitForCDP --> Retry: Timeout
    
    Retry --> WaitForCDP: Attempt < Max
    Retry --> Error: Max Retries
    
    Connected --> [*]: Success
    Error --> [*]: Failure
```

## Design Principles

### 1. Separation of Concerns
Each module handles one specific task:
- `browser_manager.py` - High-level orchestration
- `browser/*.py` - Browser operations
- `author.py` - User-facing API
- `config.py` - Configuration management

### 2. Fail-Safe Design
Error handling strategy:
- Attempt graceful operations first
- Use forceful methods as fallback
- Provide clear user guidance
- Maintain system stability

### 3. Cross-Platform Compatibility
Platform-specific code is isolated:
- `finder.py` - Path discovery
- `process.py` - Process management
- `paths.py` - Directory resolution

### 4. Performance Optimization
Optimization techniques:
- Lazy loading of Playwright
- Caching of Chrome paths
- Connection reuse
- Minimal startup overhead

### 5. User Experience First
Error messages include:
- Clear explanation
- Actionable solution
- Required commands
- Documentation links

## Extension Points

### Plugin Architecture (Future)

```mermaid
graph LR
    subgraph "PlaywrightAuthor Core"
        Core[Core Engine]
        Hooks[Hook System]
    end
    
    subgraph "Plugin Types"
        Auth[Auth Plugins]
        Monitor[Monitor Plugins]
        Network[Network Plugins]
    end
    
    Core --> Hooks
    Hooks --> Auth
    Hooks --> Monitor
    Hooks --> Network
    
    Auth --> OAuth[OAuth Helper]
    Auth --> SAML[SAML Helper]
    Monitor --> Metrics[Metrics Export]
    Network --> Proxy[Proxy Manager]
```

### Configuration Layers

```mermaid
graph TD
    Default[Default Config] --> File[File Config]
    File --> Env[Environment Vars]
    Env --> Runtime[Runtime Override]
    Runtime --> Final[Final Config]
    
    style Default fill:#f9f,stroke:#333
    style Final fill:#9f9,stroke:#333
```

## Performance Characteristics

### Startup Performance
- First run: 2-5s (includes Chrome launch)
- Subsequent runs: 0.5-1s (connection only)
- With monitoring: +0.1s overhead
- REPL mode: +0.2s for prompt toolkit

### Memory Usage
- Base: ~50MB (Python + PlaywrightAuthor)
- Per browser: ~200MB (Chrome process)
- Per page: 50-100MB (content dependent)
- Monitoring: ~10MB (metrics storage)

### Scalability
- Profiles: Unlimited (filesystem bound)
- Concurrent browsers: System resource limited
- Pages per browser: 50-100 recommended
- Monitoring interval: 5-300s configurable

## Security Architecture

### Profile Isolation

```mermaid
graph TB
    subgraph "Profile Storage"
        Default[Default Profile]
        Work[Work Profile]
        Personal[Personal Profile]
    end
    
    subgraph "Isolation"
        Cookies1[Cookies]
        Storage1[LocalStorage]
        Cache1[Cache]
        
        Cookies2[Cookies]
        Storage2[LocalStorage]
        Cache2[Cache]
        
        Cookies3[Cookies]
        Storage3[LocalStorage]
        Cache3[Cache]
    end
    
    Default --> Cookies1 & Storage1 & Cache1
    Work --> Cookies2 & Storage2 & Cache2
    Personal --> Cookies3 & Storage3 & Cache3
    
    style Default fill:#f99
    style Work fill:#99f
    style Personal fill:#9f9
```

### Future: Encryption

```mermaid
sequenceDiagram
    participant User
    participant PA as PlaywrightAuthor
    participant KDF
    participant Storage
    
    User->>PA: Create Profile
    PA->>User: Request Password
    User->>PA: Password
    
    PA->>KDF: Derive Key
    KDF-->>PA: Encryption Key
    
    PA->>PA: Encrypt Profile Data
    PA->>Storage: Store Encrypted
    
    Note over Storage: Encrypted cookies,<br/>tokens, session data
```

## Additional Resources

- [Component Details](components.md)
- [Browser Lifecycle](browser-lifecycle.md)
- [Error Handling](error-handling.md)
- [Performance Guide](../performance/index.md)
- [API Reference](../../api/index.md)
</document_content>
</document>

<document index="23">
<source>docs/auth/github.md</source>
<document_content>
# GitHub Authentication Guide

This guide shows how to authenticate with GitHub using PlaywrightAuthor for automation, API access, and CI/CD workflows.

## Prerequisites

You'll need:

1. **GitHub Account**: An active account
2. **2FA Setup**: Your authenticator app or SMS ready if two-factor authentication is enabled
3. **Personal Access Tokens**: PATs are safer than passwords for automation

## Step-by-Step Authentication

### Step 1: Basic Authentication

```python
from playwrightauthor import Browser

# First run - manual login
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://github.com/login")
    
    print("Log in to GitHub manually")
    print("Complete any 2FA requirements if prompted")
    
    # Wait for successful login
    try:
        page.wait_for_selector('[aria-label="Dashboard"]', timeout=300000)
    except:
        # Fallback check
        page.wait_for_selector('summary[aria-label*="profile"]', timeout=300000)
    
    print("GitHub login successful")
```

### Step 2: Handling 2FA

```python
# Automated login with 2FA handling
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://github.com/login")
    
    # Enter credentials
    page.fill('input[name="login"]', "your-username")
    page.fill('input[name="password"]', "your-password")
    page.click('input[type="submit"]')
    
    # Check if 2FA is required
    try:
        page.wait_for_selector('input[name="otp"]', timeout=5000)
        print("2FA required. Enter your code:")
        
        # Manual entry
        code = input("Enter 2FA code: ")
        page.fill('input[name="otp"]', code)
        page.press('input[name="otp"]', "Enter")
        
    except:
        print("No 2FA required or already completed")
```

### Step 3: Personal Access Token Setup

PATs are better for automation:

```python
# Navigate to token creation
with Browser() as browser:
    page = browser.new_page()
    
    # Ensure we're logged in
    page.goto("https://github.com")
    
    # Go to token settings
    page.goto("https://github.com/settings/tokens/new")
    
    print("Create a Personal Access Token:")
    print("1. Give it a descriptive name")
    print("2. Set expiration (90 days recommended)")
    print("3. Select required scopes:")
    print("   - repo (for repository access)")
    print("   - workflow (for Actions)")
    print("   - read:org (for organization access)")
    
    # Wait for token generation
    page.wait_for_selector('input[id*="new_token"]', timeout=300000)
    
    # Get the token value
    token_input = page.query_selector('input[id*="new_token"]')
    if token_input:
        token = token_input.get_attribute("value")
        print(f"Token generated: {token[:8]}...")
        print("Save this token securely - you won't see it again")
```

## Advanced Scenarios

### Multiple GitHub Accounts

```python
# Personal account
with Browser(profile="github-personal") as browser:
    page = browser.new_page()
    page.goto("https://github.com")
    # Already logged in as personal account

# Work account
with Browser(profile="github-work") as browser:
    page = browser.new_page()
    page.goto("https://github.com")
    # Already logged in as work account
```

### GitHub Enterprise

```python
# For GitHub Enterprise Server
GITHUB_ENTERPRISE_URL = "https://github.company.com"

with Browser(profile="github-enterprise") as browser:
    page = browser.new_page()
    page.goto(f"{GITHUB_ENTERPRISE_URL}/login")
    
    # Handle SSO if required
    if "sso" in page.url:
        print("Complete SSO authentication...")
        page.wait_for_url(f"{GITHUB_ENTERPRISE_URL}/**", timeout=300000)
```

### OAuth App Authorization

```python
# Authorize OAuth apps
def authorize_oauth_app(app_name: str, client_id: str):
    with Browser() as browser:
        page = browser.new_page()
        
        # Navigate to OAuth authorization
        auth_url = f"https://github.com/login/oauth/authorize?client_id={client_id}"
        page.goto(auth_url)
        
        # Check if already authorized
        if "callback" in page.url:
            print(f"{app_name} already authorized")
            return
        
        # Click authorize button
        try:
            page.click('button[name="authorize"]')
            print(f"{app_name} authorized successfully")
        except:
            print(f"Could not authorize {app_name}")
```

## Common Issues & Solutions

### Issue 1: Device Verification Required

**Symptoms**: GitHub asks for device verification

**Solution**:
```python
# Handle device verification
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://github.com/login")
    
    # ... login steps ...
    
    # Check for device verification
    if "sessions/verified-device" in page.url:
        print("Device verification required!")
        print("Check your email for the verification code")
        
        code = input("Enter verification code: ")
        page.fill('input[name="otp"]', code)
        page.click('button[type="submit"]')
```

### Issue 2: Rate Limiting

**Symptoms**: "Too many requests" errors

**Solution**:
```python
import time

# Add delays between requests
def github_action_with_delay(page, action):
    action()
    time.sleep(2)  # 2-second delay between actions

# Use authenticated requests
headers = {
    "Authorization": f"token {GITHUB_TOKEN}",
    "Accept": "application/vnd.github.v3+json"
}
```

### Issue 3: Session Timeout

**Symptoms**: Need to log in repeatedly

**Solution**:
```python
# Keep session alive
def keep_github_session_alive():
    with Browser() as browser:
        page = browser.new_page()
        
        while True:
            # Visit GitHub every 30 minutes
            page.goto("https://github.com/notifications")
            print("Session refreshed")
            time.sleep(1800)  # 30 minutes
```

## Monitoring & Maintenance

### Check Authentication Status

```python
def check_github_auth():
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://github.com")
        
        # Check if logged in
        try:
            avatar = page.query_selector('summary[aria-label*="profile"]')
            if avatar:
                username = avatar.get_attribute("aria-label")
                return True, f"Authenticated as: {username}"
            else:
                return False, "Not authenticated"
        except:
            return False, "Authentication check failed"

status, message = check_github_auth()
print(f"{'Authenticated' if status else 'Not authenticated'}: {message}")
```

### Monitor API Rate Limits

```python
def check_rate_limits():
    with Browser() as browser:
        page = browser.new_page()
        
        # Check API rate limit
        response = page.goto("https://api.github.com/rate_limit")
        data = response.json()
        
        core_limit = data["resources"]["core"]
        print(f"API Rate Limit: {core_limit['remaining']}/{core_limit['limit']}")
        print(f"Resets at: {core_limit['reset']}")
```

## Automation Examples

### Repository Management

```python
def create_repository(repo_name: str, private: bool = False):
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://github.com/new")
        
        # Fill repository details
        page.fill('input[name="repository[name]"]', repo_name)
        page.fill('input[name="repository[description]"]', 
                  "Created with PlaywrightAuthor")
        
        # Set visibility
        if private:
            page.click('input[value="private"]')
        
        # Create repository
        page.click('button[type="submit"]')
        
        # Wait for repository page
        page.wait_for_url(f"**/{repo_name}")
        print(f"Repository '{repo_name}' created")
```

### Pull Request Automation

```python
def review_pull_request(repo: str, pr_number: int, approve: bool = True):
    with Browser() as browser:
        page = browser.new_page()
        page.goto(f"https://github.com/{repo}/pull/{pr_number}")
        
        # Click review button
        page.click('button[name="review_button"]')
        
        # Add review comment
        page.fill('textarea[name="body"]', 
                  "Automated review via PlaywrightAuthor")
        
        # Approve or request changes
        if approve:
            page.click('input[value="approve"]')
        else:
            page.click('input[value="reject"]')
        
        # Submit review
        page.click('button[type="submit"]')
        print(f"PR #{pr_number} reviewed")
```

## Best Practices

1. **Use PATs** for automation instead of passwords
2. **Add retry logic** for API calls and page interactions
3. **Respect rate limits** - add delays between operations
4. **Use dedicated bot accounts** for automation workflows
5. **Enable 2FA** but keep backup codes for emergencies
6. **Check authentication status** regularly
7. **Rotate tokens** periodically

## Security Considerations

1. **Never commit tokens** to repositories
2. **Use environment variables**:
   ```python
   import os
   GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN")
   ```
3. **Limit token scopes** to what's actually needed
4. **Set expiration dates** (90 days works well)
5. **Use GitHub Secrets** in Actions workflows
6. **Review token usage** in GitHub settings

## Additional Resources

- [GitHub Personal Access Tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)
- [GitHub OAuth Apps](https://docs.github.com/en/developers/apps/building-oauth-apps)
- [GitHub API Documentation](https://docs.github.com/en/rest)
- [GitHub Actions](https://docs.github.com/en/actions)
- [PlaywrightAuthor Examples](https://github.com/twardoch/playwrightauthor/tree/main/examples)
</document_content>
</document>

<document index="24">
<source>docs/auth/gmail.md</source>
<document_content>
# Gmail/Google Authentication Guide

This guide shows how to authenticate with Gmail and Google services using PlaywrightAuthor.

## Prerequisites

Before starting:

1. **Disable "Less Secure Apps"**: Not needed - we use full browser automation
2. **2FA Considerations**: Have your phone or authenticator app ready
3. **Browser Permissions**: Ensure Chrome has necessary permissions (especially on macOS)

## Authentication Steps

### Step 1: Initial Setup

```python
from playwrightauthor import Browser

# First run - launches Chrome for manual login
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://mail.google.com")
    
    print("Please complete the login process...")
    print("The browser will stay open until you're logged in.")
    
    # Wait for successful login (inbox appears)
    try:
        page.wait_for_selector('div[role="main"]', timeout=300000)  # 5 minutes
        print("Login successful!")
    except:
        print("Login timeout - please try again")
```

### Step 2: Handling 2FA

If you have 2FA enabled:

```python
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://accounts.google.com")
    
    # Enter email
    page.fill('input[type="email"]', "your.email@gmail.com")
    page.click("#identifierNext")
    
    # Enter password
    page.wait_for_selector('input[type="password"]', timeout=10000)
    page.fill('input[type="password"]', "your_password")
    page.click("#passwordNext")
    
    print("Complete 2FA verification in the browser...")
    
    # Wait for successful authentication
    page.wait_for_url("**/myaccount.google.com/**", timeout=120000)
    print("2FA completed successfully!")
```

### Step 3: Verify Persistent Login

```python
# Run this after initial login to verify persistence
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://mail.google.com")
    
    # Should load directly to inbox without login
    if page.url.startswith("https://mail.google.com/mail/"):
        print("Authentication persisted successfully!")
    else:
        print("Authentication not persisted - please login again")
```

## Advanced Scenarios

### Multiple Google Accounts

```python
# Work account
with Browser(profile="work") as browser:
    page = browser.new_page()
    page.goto("https://mail.google.com")
    # Login with work@company.com

# Personal account  
with Browser(profile="personal") as browser:
    page = browser.new_page()
    page.goto("https://mail.google.com")
    # Login with personal@gmail.com
```

### Google Workspace (G Suite)

```python
# For custom domain emails
with Browser() as browser:
    page = browser.new_page()
    
    # Go directly to your domain's login
    page.goto("https://accounts.google.com/AccountChooser"
              "?Email=user@yourdomain.com"
              "&continue=https://mail.google.com")
    
    # Complete SSO if required
    print("Complete your organization's login process...")
```

### App Passwords

For automation, consider using App Passwords:

1. Enable 2FA on your Google Account
2. Go to https://myaccount.google.com/apppasswords
3. Generate an app-specific password
4. Use it in your automation scripts

## Common Issues

### Issue 1: "Couldn't sign you in" Error

**Symptoms**: Google blocks the login attempt

**Solutions**:
1. Run `playwrightauthor setup` for guided configuration
2. Try logging in manually first
3. Check if your IP is trusted by Google
4. Use the same network as your regular browser

### Issue 2: Captcha Challenges

**Symptoms**: Repeated captcha requests

**Solutions**:
```python
# Add delays to appear more human-like
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://accounts.google.com")
    
    # Add realistic delays
    page.wait_for_timeout(2000)  # 2 seconds
    page.fill('input[type="email"]', "email@gmail.com")
    page.wait_for_timeout(1000)
    page.click("#identifierNext")
```

### Issue 3: Session Expires Frequently

**Symptoms**: Need to re-login often

**Solutions**:
1. Check Chrome flags: `chrome://flags`
2. Ensure cookies aren't being cleared
3. Verify profile persistence:

```python
# Check profile location
import os
from playwrightauthor.utils.paths import data_dir

profile_path = data_dir() / "profiles" / "default"
print(f"Profile stored at: {profile_path}")
print(f"Profile exists: {profile_path.exists()}")
```

### Issue 4: 2FA Problems

**Symptoms**: Can't complete 2FA

**Solutions**:
1. Use backup codes for automation
2. Set up a dedicated automation account
3. Use Google's Advanced Protection for better security

## Monitoring

### Check Authentication Status

```python
from playwrightauthor import Browser

def check_gmail_auth():
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://mail.google.com", wait_until="domcontentloaded")
        
        # Check if redirected to login
        if "accounts.google.com" in page.url:
            return False, "Not authenticated"
        elif "mail.google.com/mail/" in page.url:
            # Get account email
            try:
                email_element = page.query_selector('[aria-label*="Google Account"]')
                email = email_element.get_attribute("aria-label")
                return True, f"Authenticated as: {email}"
            except:
                return True, "Authenticated (email unknown)"
        else:
            return False, f"Unknown state: {page.url}"

status, message = check_gmail_auth()
print(f"{'✓' if status else '✗'} {message}")
```

### Export/Import Profile

```bash
# Export profile for backup or sharing
playwrightauthor profile export work --output work-profile.zip

# Import on another machine
playwrightauthor profile import work --input work-profile.zip
```

## Best Practices

1. **Dedicated Accounts**: Use separate Google accounts for automation
2. **Regular Checks**: Monitor authentication status weekly
3. **Backup Profiles**: Export working profiles regularly
4. **Error Handling**: Always implement retry logic
5. **Rate Limiting**: Add delays between actions to avoid detection

## Security

1. **Never hardcode passwords** in your scripts
2. **Use environment variables** for sensitive data
3. **Encrypt profile exports** when sharing
4. **Regularly rotate** app passwords
5. **Monitor account activity** for unauthorized access

## Resources

- [Google Account Security](https://myaccount.google.com/security)
- [App Passwords Guide](https://support.google.com/accounts/answer/185833)
- [Google Workspace Admin](https://admin.google.com)
- [PlaywrightAuthor Troubleshooting](troubleshooting.md)
</document_content>
</document>

<document index="25">
<source>docs/auth/index.md</source>
<document_content>
# Authentication Workflows

PlaywrightAuthor's key feature is maintaining persistent authentication sessions. This section provides practical guides for authenticating with common services.

## Overview

When using PlaywrightAuthor with a service that requires authentication:

1. **Browser Opens**: Chrome starts with a fresh profile
2. **Manual Login**: You log in manually—just once
3. **Session Saved**: Cookies and storage are saved automatically
4. **Future Runs**: Authentication happens automatically

## Service-Specific Guides

### Popular Services

- **[Gmail/Google](gmail.md)** – Handle 2FA, app passwords, and workspace accounts  
- **[GitHub](github.md)** – Personal access tokens and OAuth apps  
- **[LinkedIn](linkedin.md)** – Professional networking automation  
- **[Microsoft/Office 365](microsoft.md)** – Enterprise authentication  
- **[Facebook](facebook.md)** – Social media automation  
- **[Twitter/X](twitter.md)** – API alternatives  

### Enterprise Services

- **[Salesforce](salesforce.md)** – CRM automation  
- **[Slack](slack.md)** – Workspace automation  
- **[Jira/Confluence](atlassian.md)** – Project management  

## Best Practices

### Security

1. **Use Dedicated Accounts**: Where possible, create accounts specifically for automation  
2. **App Passwords**: Prefer app-specific passwords over primary credentials  
3. **2FA Workarounds**: Use backup codes or an authenticator app  
4. **Profile Isolation**: Keep different accounts in separate profiles  

### Reliability

1. **Test Authentication**: Run `playwrightauthor health` to verify login status  
2. **Monitor Sessions**: Watch for expired sessions and re-authenticate as needed  
3. **Backup Profiles**: Export important profiles for team use or recovery  
4. **Error Handling**: Add retry logic for unexpected authentication failures  

## Common Authentication Patterns

### Basic Login Flow

```python
from playwrightauthor import Browser

# First run - manual login required
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com/login")
    print("Please log in manually...")
    input("Press Enter when logged in...")
```

### Multi-Step Authentication

```python
# Handle 2FA or multi-step login
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://secure-site.com")
    
    # Wait for login page
    page.wait_for_selector("input[name='username']")
    print("Enter credentials and complete 2FA...")
    
    # Wait for successful login (up to 5 minutes)
    page.wait_for_selector(".dashboard", timeout=300000)
    print("Login successful!")
```

### Profile Management

```python
# Use different profiles for different accounts
with Browser(profile="work") as browser:
    page = browser.new_page()
    page.goto("https://workspace.google.com")

with Browser(profile="personal") as browser:
    page = browser.new_page()
    page.goto("https://gmail.com")
```

## Troubleshooting

See the [Troubleshooting Guide](troubleshooting.md) for help with:

- Cookie and session problems  
- JavaScript errors  
- Popup blockers  
- Network issues  
- Platform-specific quirks  

## Tips

1. **First-Time Setup**: Run `playwrightauthor setup` for guided configuration  
2. **Health Checks**: Use `playwrightauthor health` to validate your setup  
3. **Debug Mode**: Set `PLAYWRIGHTAUTHOR_VERBOSE=true` for detailed logs  
4. **Manual Testing**: Use `playwrightauthor repl` for interactive debugging
</document_content>
</document>

<document index="26">
<source>docs/auth/linkedin.md</source>
<document_content>
# LinkedIn Authentication Guide

This guide covers authenticating with LinkedIn using PlaywrightAuthor for professional networking automation, lead generation, and content management.

## Prerequisites

Before starting:

1. **LinkedIn Account**: Active account in good standing
2. **Security Verification**: Phone number or email for two-factor authentication
3. **Rate Limits**: Understand LinkedIn's automation restrictions

**Important**: LinkedIn actively blocks automation. Use carefully and consider official APIs for production applications.

## Authentication Process

### Basic Login

```python
from playwrightauthor import Browser

# First run - manual login
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://www.linkedin.com/login")
    
    print("Log in to LinkedIn manually")
    print("Complete security challenges if prompted")
    
    # Wait for successful login
    try:
        page.wait_for_selector('[data-test-id="feed"]', timeout=300000)
        print("Login successful")
    except:
        # Fallback check
        page.wait_for_selector('nav[aria-label="Primary"]', timeout=300000)
        print("Login successful")
```

### Automated Login with Security Handling

```python
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://www.linkedin.com/login")
    
    # Enter credentials
    page.fill('#username', "your-email@example.com")
    page.fill('#password', "your-password")
    page.click('button[type="submit"]')
    
    # Handle verification code
    try:
        page.wait_for_selector('input[name="pin"]', timeout=5000)
        print("Verification required")
        
        code = input("Enter code from email/phone: ")
        page.fill('input[name="pin"]', code)
        page.click('button[type="submit"]')
        
    except:
        print("No verification required")
    
    # Confirm login
    page.wait_for_selector('[data-test-id="feed"]', timeout=30000)
    print("Authentication complete")
```

### Remember Device Setup

```python
# Reduce future security prompts
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://www.linkedin.com/login")
    
    # Complete login process first
    
    try:
        remember_checkbox = page.query_selector('input[type="checkbox"][name="rememberMe"]')
        if remember_checkbox:
            page.click('input[type="rememberMe"]')
            print("Device will be remembered")
    except:
        pass
```

## Advanced Authentication

### Multiple Account Management

```python
# Personal profile
with Browser(profile="linkedin-personal") as browser:
    page = browser.new_page()
    page.goto("https://www.linkedin.com/feed")

# Company page management
with Browser(profile="linkedin-company") as browser:
    page = browser.new_page()
    page.goto("https://www.linkedin.com/company/admin")
```

### Sales Navigator Access

```python
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://www.linkedin.com/sales")
    
    try:
        page.wait_for_selector('[data-test="sales-nav-logo"]', timeout=10000)
        print("Sales Navigator access confirmed")
    except:
        print("Sales Navigator subscription required")
```

### LinkedIn Learning Access

```python
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://www.linkedin.com/learning")
    
    if "learning" in page.url:
        print("LinkedIn Learning accessible")
    else:
        print("LinkedIn Learning subscription required")
```

## Common Problems

### Suspicious Activity Blocks

LinkedIn may block logins that appear automated:

```python
import time
import random

with Browser() as browser:
    page = browser.new_page()
    
    # Human-like delays
    time.sleep(random.uniform(2, 5))
    page.goto("https://www.linkedin.com/login")
    
    time.sleep(random.uniform(1, 3))
    page.fill('#username', "email@example.com")
    
    time.sleep(random.uniform(1, 2))
    page.fill('#password', "password")
    
    time.sleep(random.uniform(1, 2))
    page.click('button[type="submit"]')
```

### CAPTCHA Challenges

```python
def handle_captcha(page):
    try:
        page.wait_for_selector('iframe[src*="captcha"]', timeout=3000)
        print("CAPTCHA detected. Solve manually.")
        
        page.wait_for_selector('[data-test-id="feed"]', timeout=300000)
        print("CAPTCHA solved. Continuing.")
        
    except:
        pass  # No CAPTCHA
```

### Account Restrictions

When LinkedIn limits your access:
1. Reduce automation frequency
2. Increase delays between actions
3. Vary activity patterns
4. Use official LinkedIn APIs

## Status Monitoring

### Authentication Check

```python
def check_linkedin_auth():
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://www.linkedin.com/feed")
        
        if "login" in page.url:
            return False, "Not authenticated"
        
        try:
            page.click('[data-control-name="nav.settings_signout"]')
            name_element = page.query_selector('.t-16.t-black.t-bold')
            if name_element:
                name = name_element.inner_text()
                return True, f"Authenticated as: {name}"
        except:
            pass
        
        return True, "Authenticated"

status, message = check_linkedin_auth()
print(message)
```

### Activity Tracking

```python
from datetime import datetime

class LinkedInActivityTracker:
    def __init__(self):
        self.activities = []
        self.daily_limits = {
            'connection_requests': 100,
            'messages': 150,
            'profile_views': 1000
        }
    
    def log_activity(self, activity_type: str):
        self.activities.append({
            'type': activity_type,
            'timestamp': datetime.now()
        })
        
        today_count = len([a for a in self.activities 
                          if a['type'] == activity_type 
                          and a['timestamp'].date() == datetime.now().date()])
        
        limit = self.daily_limits.get(activity_type, float('inf'))
        if today_count >= limit:
            print(f"Daily limit reached for {activity_type}")
            return False
        
        print(f"{activity_type}: {today_count}/{limit}")
        return True
```

## Automation Examples

### Send Connection Request

```python
def send_connection_request(profile_url: str, message: str = None):
    with Browser() as browser:
        page = browser.new_page()
        page.goto(profile_url)
        
        connect_button = page.query_selector('button:has-text("Connect")')
        if not connect_button:
            print("Already connected or pending")
            return
        
        connect_button.click()
        
        if message:
            page.click('button:has-text("Add a note")')
            page.fill('textarea[name="message"]', message)
        
        page.click('button[aria-label="Send now"]')
        print("Connection request sent")
```

### Post Content

```python
def post_update(content: str):
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://www.linkedin.com/feed")
        
        page.click('button[data-control-name="share.share_box_open"]')
        page.wait_for_selector('.ql-editor', timeout=10000)
        page.fill('.ql-editor', content)
        
        # Add hashtags
        for tag in ["#automation", "#productivity"]:
            page.type('.ql-editor', f" {tag}")
        
        page.click('button[data-control-name="share.post"]')
        print("Update posted")
```

### Lead Generation Search

```python
def search_and_connect(search_query: str, max_connections: int = 10):
    with Browser() as browser:
        page = browser.new_page()
        page.goto(f"https://www.linkedin.com/search/results/people/?keywords={search_query}")
        page.wait_for_selector('.search-results-container')
        
        profiles = page.query_selector_all('.entity-result__title-text a')
        
        connected = 0
        for profile in profiles[:max_connections]:
            if connected >= max_connections:
                break
                
            profile_url = profile.get_attribute('href')
            page.goto(profile_url)
            time.sleep(random.uniform(3, 7))
            
            try:
                connect_btn = page.query_selector('button:has-text("Connect")')
                if connect_btn:
                    connect_btn.click()
                    time.sleep(1)
                    
                    send_btn = page.query_selector('button[aria-label="Send now"]')
                    if send_btn:
                        send_btn.click()
                        connected += 1
                        print(f"Connected: {connected}/{max_connections}")
                        time.sleep(random.uniform(30, 60))
            except:
                continue
```

## Best Practices

1. **Respect Rate Limits**:
   - Connection requests: ~100/day
   - Messages: ~150/day
   - Profile views: ~1000/day

2. **Human-like Behavior**:
   - Random delays between actions (2-10 seconds)
   - Vary activity patterns
   - No 24/7 automation

3. **Profile Warm-up**:
   - Start slowly with new accounts
   - Gradually increase activity
   - Mix automated and manual actions

4. **Content Quality**:
   - Personalize connection messages
   - Avoid spam-like content
   - Engage authentically

5. **Error Handling**:
   - Retry failed actions with backoff
   - Handle CAPTCHAs gracefully
   - Monitor for account restrictions

## Security

1. **Use Dedicated Profiles**: Never automate your primary account
2. **IP Rotation**: Consider residential proxies
3. **Session Management**: Keep browser fingerprints consistent
4. **Data Privacy**: Follow GDPR and local privacy laws
5. **API Alternative**: Use LinkedIn's official APIs when possible

## Legal & Ethical Notes

1. **Terms of Service**: LinkedIn prohibits most automation
2. **Data Scraping**: Likely violates LinkedIn's terms
3. **Spam Laws**: Comply with CAN-SPAM and similar regulations
4. **User Consent**: Respect privacy and preferences
5. **Professional Use**: Legitimate business purposes only

## Resources

- [LinkedIn User Agreement](https://www.linkedin.com/legal/user-agreement)
- [LinkedIn API Documentation](https://docs.microsoft.com/en-us/linkedin/)
- [LinkedIn Help Center](https://www.linkedin.com/help/linkedin)
- [PlaywrightAuthor Rate Limiting Guide](../performance/rate-limiting.md)
- [Ethical Automation Guidelines](../best-practices/ethics.md)
</document_content>
</document>

<document index="27">
<source>docs/auth/troubleshooting.md</source>
<document_content>
# Authentication Troubleshooting Guide

This guide helps you diagnose and fix authentication issues with PlaywrightAuthor.

## Quick Diagnosis

Run this command first to check your setup:

```bash
playwrightauthor health
```

## Troubleshooting Flowchart

```mermaid
flowchart TD
    Start[Authentication Failed] --> Check1{Browser Opens?}
    
    Check1 -->|No| BrowserIssue[Browser Installation Issue]
    Check1 -->|Yes| Check2{Login Page Loads?}
    
    Check2 -->|No| NetworkIssue[Network/Proxy Issue]
    Check2 -->|Yes| Check3{Can Enter Credentials?}
    
    Check3 -->|No| JSIssue[JavaScript/Cookie Issue]
    Check3 -->|Yes| Check4{Login Successful?}
    
    Check4 -->|No| CredIssue[Credential/Security Issue]
    Check4 -->|Yes| Check5{Session Persists?}
    
    Check5 -->|No| ProfileIssue[Profile Storage Issue]
    Check5 -->|Yes| Success[Authentication Working!]
    
    BrowserIssue --> Fix1[Run: playwrightauthor clear-cache]
    NetworkIssue --> Fix2[Check Proxy Settings]
    JSIssue --> Fix3[Enable Cookies/JavaScript]
    CredIssue --> Fix4[Verify Credentials/2FA]
    ProfileIssue --> Fix5[Check Profile Permissions]
```

## Common Issues & Solutions

### Issue 1: Browser Won't Launch

**Symptoms**:
- `BrowserLaunchError: Failed to launch Chrome`
- Browser window doesn't appear
- Timeout errors

**Diagnostic Steps**:
```python
# 1. Check Chrome installation
from playwrightauthor.browser.finder import find_chrome_executable
from playwrightauthor.utils.logger import configure

logger = configure(verbose=True)
chrome_path = find_chrome_executable(logger)
print(f"Chrome found at: {chrome_path}")

# 2. Check if Chrome process is running
import psutil
chrome_procs = [p for p in psutil.process_iter() if 'chrome' in p.name().lower()]
print(f"Chrome processes: {len(chrome_procs)}")

# 3. Try manual launch
import subprocess
subprocess.run([str(chrome_path), "--version"])
```

**Solutions**:

1. **Clear cache and reinstall**:
   ```bash
   playwrightauthor clear-cache
   playwrightauthor status
   ```

2. **Platform-specific fixes**:
   
   **macOS**:
   ```bash
   # Grant terminal permissions
   # System Preferences > Security & Privacy > Privacy > Accessibility
   # Add Terminal or your IDE
   
   # Reset Chrome permissions
   tccutil reset Accessibility com.google.Chrome
   ```
   
   **Windows**:
   ```powershell
   # Run as Administrator
   # Check Windows Defender/Antivirus exclusions
   # Add Chrome to firewall exceptions
   ```
   
   **Linux**:
   ```bash
   # Install dependencies
   sudo apt-get update
   sudo apt-get install -y libgbm1 libxss1
   
   # Check display
   echo $DISPLAY  # Should show :0 or similar
   ```

### Issue 2: Network/Connection Problems

**Symptoms**:
- `ERR_CONNECTION_REFUSED`
- `ERR_PROXY_CONNECTION_FAILED`
- Page load timeouts

**Diagnostic Steps**:
```python
# Check CDP connection
from playwrightauthor.connection import ConnectionHealthChecker

checker = ConnectionHealthChecker(9222)
diagnostics = checker.get_connection_diagnostics()
print(f"CDP Available: {diagnostics['cdp_available']}")
print(f"Response Time: {diagnostics['response_time_ms']}ms")
print(f"Error: {diagnostics.get('error', 'None')}")
```

**Solutions**:

1. **Check proxy settings**:
   ```python
   import os
   
   # Disable proxy for local connections
   os.environ['NO_PROXY'] = 'localhost,127.0.0.1'
   
   # Or set proxy if required
   os.environ['HTTP_PROXY'] = 'http://proxy.company.com:8080'
   os.environ['HTTPS_PROXY'] = 'http://proxy.company.com:8080'
   ```

2. **Check firewall**:
   ```bash
   # Allow Chrome debug port
   sudo ufw allow 9222/tcp  # Linux
   
   # Windows: Add firewall rule for port 9222
   ```

3. **Use custom debug port**:
   ```python
   # If 9222 is blocked, use different port
   os.environ['PLAYWRIGHTAUTHOR_DEBUG_PORT'] = '9333'
   ```

### Issue 3: Cookie/JavaScript Blocked

**Symptoms**:
- Login form doesn't work
- "Please enable cookies" message
- JavaScript errors in console

**Diagnostic Steps**:
```python
# Check browser console for errors
with Browser() as browser:
    page = browser.new_page()
    
    # Enable console logging
    page.on("console", lambda msg: print(f"Console: {msg.text}"))
    page.on("pageerror", lambda err: print(f"Error: {err}"))
    
    page.goto("https://example.com/login")
```

**Solutions**:

1. **Enable cookies and JavaScript**:
   ```python
   # Check Chrome settings
   with Browser() as browser:
       page = browser.new_page()
       page.goto("chrome://settings/content/cookies")
       # Ensure "Allow all cookies" is selected
       
       page.goto("chrome://settings/content/javascript")
       # Ensure JavaScript is enabled
   ```

2. **Clear site data**:
   ```python
   # Clear cookies for specific site
   with Browser() as browser:
       context = browser.new_context()
       context.clear_cookies()
       page = context.new_page()
       page.goto("https://example.com")
   ```

### Issue 4: Authentication Failures

**Symptoms**:
- "Invalid credentials" (but they're correct)
- Security challenges/CAPTCHAs
- Account locked messages

**Solutions**:

1. **Add human-like delays**:
   ```python
   import time
   import random
   
   with Browser() as browser:
       page = browser.new_page()
       page.goto("https://example.com/login")
       
       # Random delay before typing
       time.sleep(random.uniform(1, 3))
       
       # Type slowly
       page.type("#username", "user@example.com", delay=100)
       time.sleep(random.uniform(0.5, 1.5))
       
       page.type("#password", "password", delay=100)
       time.sleep(random.uniform(0.5, 1.5))
       
       page.click("button[type='submit']")
   ```

2. **Handle security challenges**:
   ```python
   # Wait for and handle 2FA
   try:
       page.wait_for_selector("input[name='code']", timeout=5000)
       print("2FA required - check your authenticator")
       code = input("Enter 2FA code: ")
       page.fill("input[name='code']", code)
       page.press("input[name='code']", "Enter")
   except:
       print("No 2FA required")
   ```

### Issue 5: Session Not Persisting

**Symptoms**:
- Have to login every time
- "Profile not found" errors
- Cookies not saved

**Diagnostic Steps**:
```python
# Check profile location and permissions
from playwrightauthor.utils.paths import data_dir
import os

profile_path = data_dir() / "profiles" / "default"
print(f"Profile path: {profile_path}")
print(f"Exists: {profile_path.exists()}")
print(f"Writable: {os.access(profile_path.parent, os.W_OK)}")

# List profile contents
if profile_path.exists():
    for item in profile_path.iterdir():
        print(f"  {item.name} ({item.stat().st_size} bytes)")
```

**Solutions**:

1. **Fix permissions**:
   ```bash
   # Linux/macOS
   chmod -R 755 ~/.local/share/playwrightauthor
   
   # Windows (Run as Administrator)
   icacls "%APPDATA%\playwrightauthor" /grant %USERNAME%:F /T
   ```

2. **Check disk space**:
   ```python
   import shutil
   
   path = data_dir()
   stat = shutil.disk_usage(path)
   print(f"Free space: {stat.free / 1024**3:.2f} GB")
   ```

## Advanced Diagnostics

### Complete System Check

```python
def full_diagnostic():
    """Run complete diagnostic check"""
    from playwrightauthor import Browser
    from playwrightauthor.browser.finder import find_chrome_executable
    from playwrightauthor.connection import ConnectionHealthChecker
    from playwrightauthor.utils.paths import data_dir
    import platform
    import os
    
    print("=== PlaywrightAuthor Diagnostic Report ===")
    print(f"\n1. System Info:")
    print(f"   OS: {platform.system()} {platform.release()}")
    print(f"   Python: {platform.python_version()}")
    
    print(f"\n2. Chrome Installation:")
    try:
        chrome = find_chrome_executable()
        print(f"   ✅ Chrome found: {chrome}")
    except:
        print(f"   ❌ Chrome not found")
    
    print(f"\n3. Profile Storage:")
    profile_dir = data_dir() / "profiles"
    print(f"   Path: {profile_dir}")
    print(f"   Exists: {profile_dir.exists()}")
    print(f"   Writable: {os.access(profile_dir, os.W_OK)}")
    
    print(f"\n4. CDP Connection:")
    checker = ConnectionHealthChecker(9222)
    diag = checker.get_connection_diagnostics()
    print(f"   Available: {diag['cdp_available']}")
    print(f"   Response: {diag.get('response_time_ms', 'N/A')}ms")
    
    print(f"\n5. Environment:")
    for key in ['HTTP_PROXY', 'HTTPS_PROXY', 'NO_PROXY', 'DISPLAY']:
        value = os.environ.get(key, 'Not set')
        print(f"   {key}: {value}")

# Run diagnostic
full_diagnostic()
```

### Monitor Authentication Health

```python
def monitor_auth_health(url: str, check_selector: str):
    """Continuously monitor authentication status"""
    import time
    from datetime import datetime
    
    while True:
        try:
            with Browser() as browser:
                page = browser.new_page()
                page.goto(url, wait_until="domcontentloaded", timeout=30000)
                
                # Check if authenticated
                try:
                    page.wait_for_selector(check_selector, timeout=5000)
                    status = "✅ Authenticated"
                except:
                    status = "❌ Not authenticated"
                
                print(f"[{datetime.now():%Y-%m-%d %H:%M:%S}] {status}")
                
        except Exception as e:
            print(f"[{datetime.now():%Y-%m-%d %H:%M:%S}] ❌ Error: {e}")
        
        time.sleep(300)  # Check every 5 minutes

# Example usage
# monitor_auth_health("https://github.com", '[aria-label="Dashboard"]')
```

## Prevention Tips

1. **Regular Maintenance**:
   ```bash
   # Weekly health check
   playwrightauthor health
   
   # Monthly cache cleanup
   playwrightauthor clear-cache --keep-profiles
   ```

2. **Backup Profiles**:
   ```bash
   # Export working profiles
   playwrightauthor profile export default --output backup.zip
   ```

3. **Monitor Logs**:
   ```bash
   # Enable verbose logging
   export PLAYWRIGHTAUTHOR_VERBOSE=true
   export PLAYWRIGHTAUTHOR_LOG_FILE=~/.playwrightauthor/debug.log
   ```

4. **Test Authentication**:
   ```python
   # Simple auth test script
   def test_auth(url: str, success_indicator: str):
       try:
           with Browser() as browser:
               page = browser.new_page()
               page.goto(url)
               page.wait_for_selector(success_indicator, timeout=10000)
               return True
       except:
           return False
   ```

## Getting Help

If you're still experiencing issues:

1. **Collect diagnostic info**:
   ```bash
   playwrightauthor diagnose --json > diagnostic.json
   ```

2. **Check GitHub Issues**:
   - [Search existing issues](https://github.com/twardoch/playwrightauthor/issues)
   - [Create new issue](https://github.com/twardoch/playwrightauthor/issues/new)

3. **Enable debug logging**:
   ```python
   import logging
   logging.basicConfig(level=logging.DEBUG)
   ```

4. **Community Support**:
   - Include diagnostic output
   - Specify the service you're trying to authenticate with
   - Share relevant code snippets (without credentials!)

## Additional Resources

- [Platform-Specific Guides](../platforms/index.md)
- [Performance Optimization](../performance/optimization.md)
- [Security Best Practices](../security/index.md)
- [API Reference](../../api/index.md)
</document_content>
</document>

<document index="28">
<source>docs/index.md</source>
<document_content>
# PlaywrightAuthor Documentation

Master browser automation with persistent authentication.

## Documentation Structure

### [Authentication Workflows](auth/index.md)
Step-by-step guides for authenticating with popular services:
- [Gmail/Google Authentication](auth/gmail.md)
- [GitHub Authentication](auth/github.md)
- [LinkedIn Authentication](auth/linkedin.md)
- [Troubleshooting Authentication](auth/troubleshooting.md)

### [Architecture](architecture/index.md)
Understanding PlaywrightAuthor's internals:
- [Browser Lifecycle Management](architecture/browser-lifecycle.md)
- [Component Architecture](architecture/components.md)
- [Error Handling & Recovery](architecture/error-handling.md)

### [Platform-Specific Guides](platforms/index.md)
Setup and optimization for each platform:
- [macOS Guide](platforms/macos.md) - M1/Intel, permissions, Homebrew
- [Windows Guide](platforms/windows.md) - UAC, antivirus, PowerShell
- [Linux Guide](platforms/linux.md) - Distributions, Docker, dependencies

### [Performance](performance/index.md)
Optimization and best practices:
- [Resource Optimization](performance/optimization.md)
- [Memory Management](performance/memory.md)
- [Connection Pooling](performance/connection-pooling.md)
- [Monitoring & Debugging](performance/monitoring.md)

## Quick Start

```python
from playwrightauthor import Browser

# First run - follow the authentication prompts
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://mail.google.com")
    # Browser stays open for manual login

# Subsequent runs - already authenticated
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://mail.google.com")
    # Automatically logged in
```

## Getting Help

- **Installation Issues**: [Troubleshooting guide](auth/troubleshooting.md)
- **Platform-Specific Problems**: [Platform guides](platforms/index.md)
- **Performance Issues**: [Optimization strategies](performance/optimization.md)
- **Bug Reports**: [GitHub Issues](https://github.com/twardoch/playwrightauthor/issues)

## Common Use Cases

1. **Automated Testing** - Reuse authenticated sessions for faster test runs
2. **Web Scraping** - Stay logged in across scraping jobs
3. **Process Automation** - Automate tasks that require login
4. **Multi-Account Management** - Switch between different authenticated profiles
</document_content>
</document>

<document index="29">
<source>docs/performance/connection-pooling.md</source>
<document_content>
# Connection Pooling Guide

This guide covers connection pooling strategies for PlaywrightAuthor to improve performance and resource efficiency when managing multiple browser instances.

## Why Connection Pooling?

Connection pooling provides several benefits:
- **Reduced Startup Time**: Reuse existing browser instances instead of launching new ones
- **Resource Efficiency**: Control maximum number of concurrent browsers
- **Better Performance**: Eliminate repeated connection overhead
- **Scalability**: Handle high-volume automation tasks efficiently

## Connection Pool Architecture

```mermaid
graph TD
    subgraph "Connection Pool"
        Pool[Pool Manager]
        Queue[Connection Queue]
        Active[Active Connections]
        Idle[Idle Connections]
    end
    
    subgraph "Clients"
        C1[Client 1]
        C2[Client 2]
        C3[Client 3]
        CN[Client N]
    end
    
    subgraph "Browser Instances"
        B1[Browser 1]
        B2[Browser 2]
        B3[Browser 3]
        BN[Browser N]
    end
    
    C1 --> Pool
    C2 --> Pool
    C3 --> Pool
    CN --> Pool
    
    Pool --> Queue
    Queue --> Active
    Active --> B1
    Active --> B2
    Active --> B3
    
    Idle --> BN
    
    B1 -.-> Idle
    B2 -.-> Idle
    B3 -.-> Idle
```

## Basic Connection Pool

### Simple Pool Implementation

```python
import queue
import threading
import time
from contextlib import contextmanager
from dataclasses import dataclass
from datetime import datetime

@dataclass
class PooledConnection:
    """Wrapper for pooled browser connection."""
    browser: object
    created_at: datetime
    last_used: datetime
    use_count: int = 0
    
    def touch(self):
        """Update last used timestamp."""
        self.last_used = datetime.now()
        self.use_count += 1

class BrowserPool:
    """Basic browser connection pool."""
    
    def __init__(
        self,
        min_size: int = 1,
        max_size: int = 5,
        max_idle_time: int = 300  # 5 minutes
    ):
        self.min_size = min_size
        self.max_size = max_size
        self.max_idle_time = max_idle_time
        
        self._pool = queue.Queue(maxsize=max_size)
        self._all_connections = []
        self._lock = threading.Lock()
        self._shutdown = False
        
        # Initialize minimum connections
        self._initialize_pool()
    
    def _initialize_pool(self):
        """Create initial connections."""
        for _ in range(self.min_size):
            conn = self._create_connection()
            self._pool.put(conn)
    
    def _create_connection(self) -> PooledConnection:
        """Create new browser connection."""
        from playwrightauthor import Browser
        
        browser = Browser().__enter__()
        conn = PooledConnection(
            browser=browser,
            created_at=datetime.now(),
            last_used=datetime.now()
        )
        
        with self._lock:
            self._all_connections.append(conn)
        
        return conn
    
    @contextmanager
    def acquire(self, timeout: float = 30.0):
        """Acquire browser from pool."""
        connection = None
        
        try:
            # Try to get from pool
            try:
                connection = self._pool.get(timeout=timeout)
            except queue.Empty:
                # Create new if under limit
                with self._lock:
                    if len(self._all_connections) < self.max_size:
                        connection = self._create_connection()
                    else:
                        raise RuntimeError("Connection pool exhausted")
            
            # Update usage
            connection.touch()
            
            # Yield browser
            yield connection.browser
            
        finally:
            # Return to pool
            if connection and not self._shutdown:
                self._pool.put(connection)
    
    def close(self):
        """Close all connections."""
        self._shutdown = True
        
        # Close all connections
        with self._lock:
            for conn in self._all_connections:
                try:
                    conn.browser.__exit__(None, None, None)
                except:
                    pass
            
            self._all_connections.clear()

# Usage
pool = BrowserPool(min_size=2, max_size=10)

# Use browsers from pool
def process_url(url: str):
    with pool.acquire() as browser:
        page = browser.new_page()
        page.goto(url)
        title = page.title()
        page.close()
        return title

# Process multiple URLs concurrently
from concurrent.futures import ThreadPoolExecutor

urls = ["https://example.com", "https://google.com", "https://github.com"]

with ThreadPoolExecutor(max_workers=5) as executor:
    results = list(executor.map(process_url, urls))

print(results)
pool.close()
```

## Advanced Connection Pool

### Full-Featured Pool with Health Checks

```python
import asyncio
from enum import Enum
from typing import Optional, Dict, Any
import logging

class ConnectionState(Enum):
    """Connection states."""
    IDLE = "idle"
    ACTIVE = "active"
    UNHEALTHY = "unhealthy"
    CLOSED = "closed"

class AdvancedBrowserPool:
    """Advanced connection pool with health checks and monitoring."""
    
    def __init__(
        self,
        min_size: int = 2,
        max_size: int = 10,
        max_idle_time: int = 300,
        health_check_interval: int = 30,
        max_use_count: int = 100,
        max_lifetime: int = 3600
    ):
        self.min_size = min_size
        self.max_size = max_size
        self.max_idle_time = max_idle_time
        self.health_check_interval = health_check_interval
        self.max_use_count = max_use_count
        self.max_lifetime = max_lifetime
        
        self._connections: Dict[str, PooledConnection] = {}
        self._idle_queue = asyncio.Queue(maxsize=max_size)
        self._semaphore = asyncio.Semaphore(max_size)
        self._stats = {
            'created': 0,
            'destroyed': 0,
            'acquired': 0,
            'released': 0,
            'health_checks': 0,
            'failed_health_checks': 0
        }
        
        self.logger = logging.getLogger(__name__)
        self._running = False
        self._health_check_task = None
    
    async def start(self):
        """Start the pool."""
        self._running = True
        
        # Create initial connections
        for _ in range(self.min_size):
            await self._create_connection()
        
        # Start health check task
        self._health_check_task = asyncio.create_task(self._health_check_loop())
        
        self.logger.info(f"Pool started with {self.min_size} connections")
    
    async def stop(self):
        """Stop the pool."""
        self._running = False
        
        # Cancel health check
        if self._health_check_task:
            self._health_check_task.cancel()
            try:
                await self._health_check_task
            except asyncio.CancelledError:
                pass
        
        # Close all connections
        for conn_id in list(self._connections.keys()):
            await self._destroy_connection(conn_id)
        
        self.logger.info("Pool stopped")
    
    async def _create_connection(self) -> str:
        """Create new connection."""
        from playwrightauthor import AsyncBrowser
        
        async with self._semaphore:
            browser = await AsyncBrowser().__aenter__()
            
            conn_id = f"conn_{self._stats['created']}"
            conn = PooledConnection(
                browser=browser,
                created_at=datetime.now(),
                last_used=datetime.now()
            )
            
            self._connections[conn_id] = conn
            await self._idle_queue.put(conn_id)
            
            self._stats['created'] += 1
            self.logger.debug(f"Created connection {conn_id}")
            
            return conn_id
    
    async def _destroy_connection(self, conn_id: str):
        """Destroy a connection."""
        if conn_id not in self._connections:
            return
        
        conn = self._connections[conn_id]
        
        try:
            await conn.browser.__aexit__(None, None, None)
        except Exception as e:
            self.logger.error(f"Error closing connection {conn_id}: {e}")
        
        del self._connections[conn_id]
        self._stats['destroyed'] += 1
        
        self.logger.debug(f"Destroyed connection {conn_id}")
    
    async def _check_connection_health(self, conn_id: str) -> bool:
        """Check if connection is healthy."""
        if conn_id not in self._connections:
            return False
        
        conn = self._connections[conn_id]
        
        try:
            # Simple health check - create and close a page
            page = await conn.browser.new_page()
            await page.goto("about:blank", timeout=5000)
            await page.close()
            
            return True
        except Exception as e:
            self.logger.warning(f"Health check failed for {conn_id}: {e}")
            return False
    
    async def _health_check_loop(self):
        """Periodic health check loop."""
        while self._running:
            try:
                await asyncio.sleep(self.health_check_interval)
                
                # Check all idle connections
                idle_connections = []
                
                # Get all idle connections
                while not self._idle_queue.empty():
                    try:
                        conn_id = self._idle_queue.get_nowait()
                        idle_connections.append(conn_id)
                    except asyncio.QueueEmpty:
                        break
                
                # Check health and lifecycle
                for conn_id in idle_connections:
                    conn = self._connections.get(conn_id)
                    if not conn:
                        continue
                    
                    self._stats['health_checks'] += 1
                    
                    # Check lifetime
                    age = (datetime.now() - conn.created_at).total_seconds()
                    if age > self.max_lifetime:
                        self.logger.info(f"Connection {conn_id} exceeded lifetime")
                        await self._destroy_connection(conn_id)
                        continue
                    
                    # Check use count
                    if conn.use_count > self.max_use_count:
                        self.logger.info(f"Connection {conn_id} exceeded use count")
                        await self._destroy_connection(conn_id)
                        continue
                    
                    # Check idle time
                    idle_time = (datetime.now() - conn.last_used).total_seconds()
                    if idle_time > self.max_idle_time:
                        self.logger.info(f"Connection {conn_id} exceeded idle time")
                        await self._destroy_connection(conn_id)
                        continue
                    
                    # Health check
                    if not await self._check_connection_health(conn_id):
                        self._stats['failed_health_checks'] += 1
                        await self._destroy_connection(conn_id)
                        continue
                    
                    # Return to pool if healthy
                    await self._idle_queue.put(conn_id)
                
                # Ensure minimum connections
                current_count = len(self._connections)
                if current_count < self.min_size:
                    for _ in range(self.min_size - current_count):
                        await self._create_connection()
                
            except Exception as e:
                self.logger.error(f"Health check error: {e}")
    
    async def acquire(self, timeout: float = 30.0) -> Any:
        """Acquire connection from pool."""
        start_time = asyncio.get_event_loop().time()
        
        while True:
            try:
                # Try to get idle connection
                conn_id = await asyncio.wait_for(
                    self._idle_queue.get(),
                    timeout=min(1.0, timeout)
                )
                
                conn = self._connections.get(conn_id)
                if conn:
                    conn.touch()
                    self._stats['acquired'] += 1
                    return conn.browser
                
            except asyncio.TimeoutError:
                # Check if we can create new connection
                if len(self._connections) < self.max_size:
                    conn_id = await self._create_connection()
                    conn = self._connections[conn_id]
                    conn.touch()
                    self._stats['acquired'] += 1
                    return conn.browser
                
                # Check timeout
                if asyncio.get_event_loop().time() - start_time > timeout:
                    raise TimeoutError("Failed to acquire connection from pool")
    
    async def release(self, browser: Any):
        """Release connection back to pool."""
        # Find connection by browser
        conn_id = None
        for cid, conn in self._connections.items():
            if conn.browser == browser:
                conn_id = cid
                break
        
        if conn_id:
            await self._idle_queue.put(conn_id)
            self._stats['released'] += 1
        else:
            self.logger.warning("Released unknown browser connection")
    
    def get_stats(self) -> Dict[str, Any]:
        """Get pool statistics."""
        return {
            **self._stats,
            'total_connections': len(self._connections),
            'idle_connections': self._idle_queue.qsize(),
            'active_connections': len(self._connections) - self._idle_queue.qsize()
        }

# Usage
async def advanced_pool_example():
    pool = AdvancedBrowserPool(
        min_size=3,
        max_size=10,
        health_check_interval=30
    )
    
    await pool.start()
    
    try:
        # Process URLs with pool
        async def process_url(url: str):
            browser = await pool.acquire()
            try:
                page = await browser.new_page()
                await page.goto(url)
                title = await page.title()
                await page.close()
                return title
            finally:
                await pool.release(browser)
        
        # Concurrent processing
        urls = ["https://example.com"] * 20
        tasks = [process_url(url) for url in urls]
        results = await asyncio.gather(*tasks)
        
        # Check stats
        stats = pool.get_stats()
        print(f"Pool stats: {stats}")
        
    finally:
        await pool.stop()

# Run example
asyncio.run(advanced_pool_example())
```

## Pool Patterns

### 1. Profile-Based Pools

```python
class ProfileBasedPool:
    """Separate pools for different browser profiles."""
    
    def __init__(self):
        self.pools = {}
        self.default_pool_config = {
            'min_size': 1,
            'max_size': 5
        }
    
    def get_pool(self, profile: str) -> BrowserPool:
        """Get or create pool for profile."""
        if profile not in self.pools:
            self.pools[profile] = BrowserPool(
                **self.default_pool_config,
                profile=profile
            )
        
        return self.pools[profile]
    
    @contextmanager
    def acquire(self, profile: str = "default"):
        """Acquire browser from profile-specific pool."""
        pool = self.get_pool(profile)
        
        with pool.acquire() as browser:
            yield browser
    
    def close_all(self):
        """Close all pools."""
        for pool in self.pools.values():
            pool.close()

# Usage
profile_pool = ProfileBasedPool()

# Use different profiles
with profile_pool.acquire("work") as browser:
    # Work profile browser
    pass

with profile_pool.acquire("personal") as browser:
    # Personal profile browser
    pass

profile_pool.close_all()
```

### 2. Priority Queue Pool

```python
import heapq
from dataclasses import dataclass, field

@dataclass
class PriorityRequest:
    """Priority-based connection request."""
    priority: int
    request_id: str
    future: asyncio.Future
    timestamp: float = field(default_factory=time.time)
    
    def __lt__(self, other):
        # Lower priority number = higher priority
        return self.priority < other.priority

class PriorityBrowserPool:
    """Pool with priority-based allocation."""
    
    def __init__(self, max_size: int = 10):
        self.max_size = max_size
        self._connections = []
        self._available = asyncio.Queue()
        self._waiting = []  # Priority queue
        self._lock = asyncio.Lock()
    
    async def acquire(self, priority: int = 5) -> Any:
        """Acquire with priority (1=highest, 10=lowest)."""
        # Try immediate acquisition
        try:
            conn = self._available.get_nowait()
            return conn
        except asyncio.QueueEmpty:
            pass
        
        # Add to priority queue
        future = asyncio.Future()
        request = PriorityRequest(
            priority=priority,
            request_id=str(time.time()),
            future=future
        )
        
        async with self._lock:
            heapq.heappush(self._waiting, request)
        
        # Wait for connection
        return await future
    
    async def release(self, browser: Any):
        """Release connection back to pool."""
        async with self._lock:
            if self._waiting:
                # Give to highest priority waiter
                request = heapq.heappop(self._waiting)
                request.future.set_result(browser)
            else:
                # Return to available pool
                await self._available.put(browser)

# Usage
priority_pool = PriorityBrowserPool(max_size=5)

# High priority request
high_priority_browser = await priority_pool.acquire(priority=1)

# Normal priority request
normal_browser = await priority_pool.acquire(priority=5)

# Low priority request
low_priority_browser = await priority_pool.acquire(priority=9)
```

### 3. Geographic Pool Distribution

```python
class GeographicBrowserPool:
    """Pool with geographic distribution."""
    
    def __init__(self):
        self.region_pools = {
            'us-east': {'proxy': 'http://us-east-proxy.com:8080'},
            'us-west': {'proxy': 'http://us-west-proxy.com:8080'},
            'eu-west': {'proxy': 'http://eu-west-proxy.com:8080'},
            'ap-south': {'proxy': 'http://ap-south-proxy.com:8080'}
        }
        self.pools = {}
    
    def _create_regional_pool(self, region: str) -> BrowserPool:
        """Create pool for specific region."""
        config = self.region_pools.get(region, {})
        
        class RegionalBrowserPool(BrowserPool):
            def _create_connection(self):
                from playwrightauthor import Browser
                
                # Regional configuration
                args = []
                if 'proxy' in config:
                    args.append(f'--proxy-server={config["proxy"]}')
                
                browser = Browser(args=args).__enter__()
                # ... rest of connection creation
        
        return RegionalBrowserPool(min_size=2, max_size=5)
    
    @contextmanager
    def acquire(self, region: str = 'us-east'):
        """Acquire browser from regional pool."""
        if region not in self.pools:
            self.pools[region] = self._create_regional_pool(region)
        
        with self.pools[region].acquire() as browser:
            yield browser

# Usage
geo_pool = GeographicBrowserPool()

# Use browser from specific region
with geo_pool.acquire('eu-west') as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    # Browser uses EU proxy
```

## Pool Monitoring

### Pool Metrics Dashboard

```python
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from collections import deque
import numpy as np

class PoolMetricsDashboard:
    """Real-time pool metrics visualization."""
    
    def __init__(self, pool: BrowserPool, window_size: int = 60):
        self.pool = pool
        self.window_size = window_size
        
        # Metrics history
        self.timestamps = deque(maxlen=window_size)
        self.active_connections = deque(maxlen=window_size)
        self.idle_connections = deque(maxlen=window_size)
        self.queue_size = deque(maxlen=window_size)
        self.avg_wait_time = deque(maxlen=window_size)
        
        # Setup plot
        self.fig, self.axes = plt.subplots(2, 2, figsize=(12, 8))
        self.fig.suptitle('Browser Pool Metrics Dashboard')
    
    def update_metrics(self):
        """Update metrics from pool."""
        stats = self.pool.get_stats()
        
        self.timestamps.append(time.time())
        self.active_connections.append(stats.get('active_connections', 0))
        self.idle_connections.append(stats.get('idle_connections', 0))
        self.queue_size.append(stats.get('queue_size', 0))
        self.avg_wait_time.append(stats.get('avg_wait_time', 0))
    
    def animate(self, frame):
        """Update dashboard plots."""
        self.update_metrics()
        
        # Clear axes
        for ax in self.axes.flat:
            ax.clear()
        
        if len(self.timestamps) < 2:
            return
        
        # Convert timestamps to relative seconds
        times = np.array(self.timestamps)
        times = times - times[0]
        
        # Plot 1: Connection counts
        ax1 = self.axes[0, 0]
        ax1.plot(times, self.active_connections, 'r-', label='Active')
        ax1.plot(times, self.idle_connections, 'g-', label='Idle')
        ax1.set_title('Connection Status')
        ax1.set_xlabel('Time (s)')
        ax1.set_ylabel('Count')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # Plot 2: Queue size
        ax2 = self.axes[0, 1]
        ax2.plot(times, self.queue_size, 'b-')
        ax2.fill_between(times, self.queue_size, alpha=0.3)
        ax2.set_title('Waiting Queue Size')
        ax2.set_xlabel('Time (s)')
        ax2.set_ylabel('Requests')
        ax2.grid(True, alpha=0.3)
        
        # Plot 3: Wait times
        ax3 = self.axes[1, 0]
        ax3.plot(times, self.avg_wait_time, 'orange')
        ax3.set_title('Average Wait Time')
        ax3.set_xlabel('Time (s)')
        ax3.set_ylabel('Wait Time (ms)')
        ax3.grid(True, alpha=0.3)
        
        # Plot 4: Pool utilization
        ax4 = self.axes[1, 1]
        total = np.array(self.active_connections) + np.array(self.idle_connections)
        utilization = np.array(self.active_connections) / np.maximum(total, 1) * 100
        ax4.plot(times, utilization, 'purple')
        ax4.fill_between(times, utilization, alpha=0.3)
        ax4.set_title('Pool Utilization')
        ax4.set_xlabel('Time (s)')
        ax4.set_ylabel('Utilization %')
        ax4.set_ylim(0, 100)
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
    
    def start(self):
        """Start dashboard animation."""
        anim = FuncAnimation(
            self.fig,
            self.animate,
            interval=1000,  # Update every second
            cache_frame_data=False
        )
        plt.show()

# Usage
pool = BrowserPool(min_size=3, max_size=10)
dashboard = PoolMetricsDashboard(pool)

# Start dashboard in separate thread
import threading
dashboard_thread = threading.Thread(target=dashboard.start)
dashboard_thread.daemon = True
dashboard_thread.start()

# Run your automation...
```

## Pool Optimization

### Dynamic Pool Sizing

```python
class DynamicBrowserPool(BrowserPool):
    """Pool that adjusts size based on demand."""
    
    def __init__(self, initial_size: int = 2, max_size: int = 20):
        super().__init__(min_size=initial_size, max_size=max_size)
        
        self.metrics = {
            'wait_times': deque(maxlen=100),
            'queue_lengths': deque(maxlen=100),
            'utilization': deque(maxlen=100)
        }
        
        self._adjustment_task = None
    
    async def start(self):
        """Start pool with dynamic adjustment."""
        await super().start()
        self._adjustment_task = asyncio.create_task(self._adjust_pool_size())
    
    async def _adjust_pool_size(self):
        """Periodically adjust pool size based on metrics."""
        while self._running:
            await asyncio.sleep(30)  # Check every 30 seconds
            
            # Calculate metrics
            avg_wait = np.mean(self.metrics['wait_times']) if self.metrics['wait_times'] else 0
            avg_queue = np.mean(self.metrics['queue_lengths']) if self.metrics['queue_lengths'] else 0
            avg_util = np.mean(self.metrics['utilization']) if self.metrics['utilization'] else 0
            
            current_size = len(self._connections)
            
            # Scaling rules
            if avg_wait > 5000 and current_size < self.max_size:  # >5s wait
                # Scale up
                new_size = min(current_size + 2, self.max_size)
                self.logger.info(f"Scaling up pool from {current_size} to {new_size}")
                
                for _ in range(new_size - current_size):
                    await self._create_connection()
            
            elif avg_util < 30 and current_size > self.min_size:  # <30% utilization
                # Scale down
                new_size = max(current_size - 1, self.min_size)
                self.logger.info(f"Scaling down pool from {current_size} to {new_size}")
                
                # Remove idle connections
                for _ in range(current_size - new_size):
                    try:
                        conn_id = await asyncio.wait_for(
                            self._idle_queue.get(),
                            timeout=1.0
                        )
                        await self._destroy_connection(conn_id)
                    except asyncio.TimeoutError:
                        break
```

### Connection Warming

```python
class WarmBrowserPool(BrowserPool):
    """Pool with connection warming."""
    
    async def _create_connection(self) -> str:
        """Create and warm connection."""
        conn_id = await super()._create_connection()
        
        # Warm the connection
        await self._warm_connection(conn_id)
        
        return conn_id
    
    async def _warm_connection(self, conn_id: str):
        """Warm up a connection for better performance."""
        conn = self._connections.get(conn_id)
        if not conn:
            return
        
        browser = conn.browser
        
        # Pre-create a context
        context = await browser.new_context(
            viewport={'width': 1280, 'height': 720},
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        )
        
        # Pre-warm with common operations
        page = await context.new_page()
        
        # Load a minimal page to initialize resources
        await page.goto('about:blank')
        
        # Pre-compile common JavaScript
        await page.evaluate('''() => {
            // Pre-warm JavaScript engine
            const arr = Array(1000).fill(0).map((_, i) => i);
            const sum = arr.reduce((a, b) => a + b, 0);
            
            // Pre-warm DOM operations
            const div = document.createElement('div');
            div.innerHTML = '<p>Warm</p>';
            document.body.appendChild(div);
            document.body.removeChild(div);
            
            return sum;
        }''')
        
        # Clean up warming resources
        await page.close()
        await context.close()
        
        self.logger.debug(f"Warmed connection {conn_id}")
```

## Best Practices

1. **Right-size Your Pool**
   - Start with min_size = 2-3
   - Set max_size based on system resources
   - Monitor and adjust based on usage

2. **Implement Health Checks**
   - Regular connection validation
   - Automatic recovery from failures
   - Remove unhealthy connections

3. **Use Connection Limits**
   - Max lifetime to prevent memory leaks
   - Max use count to ensure freshness
   - Idle timeout to free resources

4. **Monitor Pool Metrics**
   - Track wait times
   - Monitor utilization
   - Alert on pool exhaustion

5. **Handle Failures Gracefully**
   - Implement retry logic
   - Provide fallback options
   - Log issues for debugging

## Additional Resources

- [Performance Optimization](index.md)
- [Memory Management](memory-management.md)
- [Browser Architecture](../architecture/browser-lifecycle.md)
- [Monitoring Guide](monitoring.md)
</document_content>
</document>

<document index="30">
<source>docs/performance/index.md</source>
<document_content>
# Performance Optimization Guide

This guide covers strategies for optimizing PlaywrightAuthor performance, managing resources efficiently, and debugging performance issues.

## Performance Overview

PlaywrightAuthor performance depends on:
- Hardware resources (CPU, RAM, disk)
- Number of browser instances
- Page complexity and JavaScript execution
- Network conditions
- Profile size and cache

## Performance Benchmarks

### Baseline Metrics

| Operation | Cold Start | Warm Start | Memory Usage | CPU Usage |
|-----------|------------|------------|--------------|-----------|
| Browser Launch | 2-5s | 0.5-1s | 200-300MB | 10-20% |
| Page Navigation | 1-3s | 0.5-1s | 50-100MB | 5-15% |
| Screenshot | 100-500ms | 50-200ms | +20-50MB | 20-40% |
| PDF Generation | 500-2000ms | 200-1000ms | +50-100MB | 30-50% |

### Scalability Limits

| Resource | Recommended | Maximum | Impact |
|----------|-------------|---------|---------|
| Browser Instances | 1-5 | 10-20 | Memory/CPU |
| Pages per Browser | 5-10 | 50-100 | Memory |
| Concurrent Operations | 3-5 | 10-15 | CPU/Network |
| Profile Size | <100MB | <1GB | Disk I/O |

## Quick Optimizations

```python
from playwrightauthor import Browser

# Optimal configuration for performance
PERFORMANCE_CONFIG = {
    'args': [
        '--disable-blink-features=AutomationControlled',
        '--disable-dev-shm-usage',  # Use disk instead of shared memory
        '--disable-gpu',  # Disable GPU in headless
        '--no-sandbox',  # Faster startup (use with caution)
        '--disable-setuid-sandbox',
        '--disable-web-security',  # Faster but less secure
        '--disable-features=TranslateUI',
        '--disable-extensions',
        '--disable-images',  # Don't load images
        '--disable-javascript',  # If JS not needed
    ],
    'viewport_width': 1280,
    'viewport_height': 720,
    'headless': True,  # Always faster
    'timeout': 30000
}

with Browser(**PERFORMANCE_CONFIG) as browser:
    pass
```

## Resource Optimization Strategies

### Memory Management

```mermaid
graph TD
    subgraph "Memory Usage Pattern"
        Start[Browser Start<br/>200MB] --> Nav[Page Navigation<br/>+50MB]
        Nav --> JS[JavaScript Execution<br/>+30MB]
        JS --> IMG[Image Loading<br/>+40MB]
        IMG --> Cache[Cache Building<br/>+20MB]
        Cache --> Peak[Peak Usage<br/>340MB]
    end
    
    subgraph "Optimization Points"
        Peak --> Close[Close Unused Pages<br/>-120MB]
        Close --> Clear[Clear Cache<br/>-40MB]
        Clear --> GC[Force Garbage Collection<br/>-30MB]
        GC --> Optimized[Optimized<br/>150MB]
    end
```

#### Memory Optimization Techniques

```python
import gc
import psutil
import os

class MemoryOptimizedBrowser:
    def __init__(self, memory_limit_mb: int = 1024):
        self.memory_limit_mb = memory_limit_mb
        self.browser = None
        self.pages = []
    
    def check_memory(self):
        process = psutil.Process(os.getpid())
        memory_mb = process.memory_info().rss / 1024 / 1024
        return memory_mb
    
    def optimize_memory(self):
        # Close old pages
        if len(self.pages) > 5:
            for page in self.pages[:-5]:
                page.close()
            self.pages = self.pages[-5:]
        
        # Clear caches
        for page in self.pages:
            page.evaluate("() => { window.localStorage.clear(); }")
        
        # Force garbage collection
        gc.collect()
    
    def new_page_with_limit(self):
        current_memory = self.check_memory()
        
        if current_memory > self.memory_limit_mb:
            print(f"Memory limit reached ({current_memory}MB), optimizing...")
            self.optimize_memory()
        
        page = self.browser.new_page()
        self.pages.append(page)
        
        # Disable memory-heavy features
        page.route("**/*.{png,jpg,jpeg,gif,webp}", lambda route: route.abort())
        
        return page

# Usage
with Browser() as browser:
    optimizer = MemoryOptimizedBrowser()
    optimizer.browser = browser
    
    for i in range(20):
        page = optimizer.new_page_with_limit()
        page.goto("https://example.com")
```

### CPU Optimization

```python
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

class CPUOptimizedAutomation:
    @staticmethod
    def throttle_operations(operations: list, max_concurrent: int = 3, delay: float = 0.5):
        results = []
        
        with ThreadPoolExecutor(max_workers=max_concurrent) as executor:
            futures = []
            for i, operation in enumerate(operations):
                if i > 0:
                    time.sleep(delay)
                
                future = executor.submit(operation)
                futures.append(future)
            
            for future in as_completed(futures):
                results.append(future.result())
        
        return results
    
    @staticmethod
    def batch_process_pages(urls: list, process_func, batch_size: int = 5):
        results = []
        
        with Browser() as browser:
            for i in range(0, len(urls), batch_size):
                batch = urls[i:i + batch_size]
                
                pages = []
                for url in batch:
                    page = browser.new_page()
                    page.goto(url)
                    pages.append(page)
                
                for page in pages:
                    result = process_func(page)
                    results.append(result)
                
                for page in pages:
                    page.close()
                
                time.sleep(1)
        
        return results
```

### Network Optimization

```python
class NetworkOptimizedBrowser:
    @staticmethod
    def configure_network_optimizations(page):
        def handle_route(route):
            resource_type = route.request.resource_type
            url = route.request.url
            
            blocked_types = ['image', 'media', 'font', 'stylesheet']
            blocked_domains = ['googletagmanager.com', 'google-analytics.com', 'doubleclick.net']
            
            if resource_type in blocked_types:
                route.abort()
            elif any(domain in url for domain in blocked_domains):
                route.abort()
            else:
                route.continue_()
        
        page.route("**/*", handle_route)
        page.context.set_offline(False)
    
    @staticmethod
    def parallel_fetch(urls: list, max_concurrent: int = 5):
        from concurrent.futures import ThreadPoolExecutor
        
        def fetch_url(url):
            with Browser() as browser:
                page = browser.new_page()
                NetworkOptimizedBrowser.configure_network_optimizations(page)
                
                response = page.goto(url, wait_until='domcontentloaded')
                content = page.content()
                page.close()
                
                return {
                    'url': url,
                    'status': response.status,
                    'size': len(content),
                    'content': content
                }
        
        with ThreadPoolExecutor(max_workers=max_concurrent) as executor:
            results = list(executor.map(fetch_url, urls))
        
        return results
```

## Connection Pooling

### Browser Pool Implementation

```python
import queue
import threading
import time
from contextlib import contextmanager

class BrowserPool:
    def __init__(self, min_size: int = 2, max_size: int = 10):
        self.min_size = min_size
        self.max_size = max_size
        self.pool = queue.Queue(maxsize=max_size)
        self.size = 0
        self.lock = threading.Lock()
        
        self._initialize_pool()
    
    def _initialize_pool(self):
        for _ in range(self.min_size):
            browser = self._create_browser()
            self.pool.put(browser)
            self.size += 1
    
    def _create_browser(self):
        from playwrightauthor import Browser
        return Browser().__enter__()
    
    @contextmanager
    def get_browser(self, timeout: float = 30):
        browser = None
        
        try:
            try:
                browser = self.pool.get(timeout=timeout)
            except queue.Empty:
                with self.lock:
                    if self.size < self.max_size:
                        browser = self._create_browser()
                        self.size += 1
                    else:
                        raise RuntimeError("Browser pool exhausted")
            
            yield browser
            
        finally:
            if browser:
                self.pool.put(browser)
    
    def shutdown(self):
        while not self.pool.empty():
            try:
                browser = self.pool.get_nowait()
                browser.__exit__(None, None, None)
            except queue.Empty:
                break

# Usage
pool = BrowserPool(min_size=3, max_size=10)

urls = ["https://example.com", "https://google.com", "https://github.com"]

def process_url(url):
    with pool.get_browser() as browser:
        page = browser.new_page()
        page.goto(url)
        title = page.title()
        page.close()
        return title

with ThreadPoolExecutor(max_workers=5) as executor:
    results = list(executor.map(process_url, urls * 10))

pool.shutdown()
```

### Page Recycling

```python
class PageRecycler:
    def __init__(self, browser, max_pages: int = 10):
        self.browser = browser
        self.max_pages = max_pages
        self.available_pages = queue.Queue()
        self.all_pages = []
    
    def get_page(self):
        try:
            page = self.available_pages.get_nowait()
            
            page.goto("about:blank")
            page.evaluate("() => { localStorage.clear(); sessionStorage.clear(); }")
            
        except queue.Empty:
            if len(self.all_pages) < self.max_pages:
                page = self.browser.new_page()
                self.all_pages.append(page)
            else:
                page = self.available_pages.get()
        
        return page
    
    def return_page(self, page):
        self.available_pages.put(page)
    
    def cleanup(self):
        for page in self.all_pages:
            page.close()

# Usage
with Browser() as browser:
    recycler = PageRecycler(browser)
    
    for url in urls:
        page = recycler.get_page()
        try:
            page.goto(url)
        finally:
            recycler.return_page(page)
    
    recycler.cleanup()
```

## Monitoring & Profiling

### Performance Monitoring

```python
import time
import psutil
from dataclasses import dataclass, field
from typing import Dict, List
import statistics

@dataclass
class PerformanceMetrics:
    operation: str
    start_time: float = field(default_factory=time.time)
    end_time: float = None
    memory_start: float = None
    memory_end: float = None
    cpu_percent: float = None
    
    def complete(self):
        self.end_time = time.time()
        process = psutil.Process()
        self.memory_end = process.memory_info().rss / 1024 / 1024
        self.cpu_percent = process.cpu_percent(interval=0.1)
    
    @property
    def duration(self) -> float:
        if self.end_time:
            return self.end_time - self.start_time
        return time.time() - self.start_time
    
    @property
    def memory_delta(self) -> float:
        if self.memory_start and self.memory_end:
            return self.memory_end - self.memory_start
        return 0

class PerformanceMonitor:
    def __init__(self):
        self.metrics: List[PerformanceMetrics] = []
        self.process = psutil.Process()
    
    def start_operation(self, name: str) -> PerformanceMetrics:
        metric = PerformanceMetrics(
            operation=name,
            memory_start=self.process.memory_info().rss / 1024 / 1024
        )
        self.metrics.append(metric)
        return metric
    
    def get_summary(self) -> Dict:
        if not self.metrics:
            return {}
        
        durations = [m.duration for m in self.metrics if m.end_time]
        memory_deltas = [m.memory_delta for m in self.metrics if m.memory_delta]
        cpu_usage = [m.cpu_percent for m in self.metrics if m.cpu_percent]
        
        return {
            'total_operations': len(self.metrics),
            'avg_duration': statistics.mean(durations) if durations else 0,
            'max_duration': max(durations) if durations else 0,
            'avg_memory_delta': statistics.mean(memory_deltas) if memory_deltas else 0,
            'max_memory_delta': max(memory_deltas) if memory_deltas else 0,
            'avg_cpu_percent': statistics.mean(cpu_usage) if cpu_usage else 0,
            'current_memory_mb': self.process.memory_info().rss / 1024 / 1024
        }
    
    def print_report(self):
        summary = self.get_summary()
        
        print("\n=== Performance Report ===")
        print(f"Total Operations: {summary['total_operations']}")
        print(f"Average Duration: {summary['avg_duration']:.2f}s")
        print(f"Max Duration: {summary['max_duration']:.2f}s")
        print(f"Average Memory Change: {summary['avg_memory_delta']:.2f}MB")
        print(f"Max Memory Change: {summary['max_memory_delta']:.2f}MB")
        print(f"Average CPU Usage: {summary['avg_cpu_percent']:.1f}%")
        print(f"Current Memory: {summary['current_memory_mb']:.2f}MB")
        
        print("\nTop 5 Slowest Operations:")
        sorted_ops = sorted(self.metrics, key=lambda m: m.duration, reverse=True)[:5]
        for op in sorted_ops:
            print(f"  - {op.operation}: {op.duration:.2f}s")

# Usage
monitor = PerformanceMonitor()

with Browser() as browser:
    launch_metric = monitor.start_operation("browser_launch")
    launch_metric.complete()
    
    page = browser.new_page()
    
    nav_metric = monitor.start_operation("navigate_to_example")
    page.goto("https://example.com")
    nav_metric.complete()
    
    screen_metric = monitor.start_operation("take_screenshot")
    page.screenshot(path="example.png")
    screen_metric.complete()

monitor.print_report()
```

### Real-time Dashboard

```python
import threading
import time
from rich.console import Console
from rich.table import Table
from rich.live import Live

class PerformanceDashboard:
    def __init__(self):
        self.console = Console()
        self.metrics = {}
        self.running = False
    
    def update_metric(self, name: str, value: float, unit: str = ""):
        self.metrics[name] = {
            'value': value,
            'unit': unit,
            'timestamp': time.time()
        }
    
    def create_table(self) -> Table:
        table = Table(title="PlaywrightAuthor Performance Dashboard")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="green")
        table.add_column("Unit", style="yellow")
        table.add_column("Updated", style="blue")
        
        current_time = time.time()
        
        for name, data in self.metrics.items():
            age = int(current_time - data['timestamp'])
            table.add_row(
                name,
                f"{data['value']:.2f}",
                data['unit'],
                f"{age}s ago"
            )
        
        return table
    
    def monitor_system(self):
        while self.running:
            process = psutil.Process()
            
            self.update_metric("CPU Usage", process.cpu_percent(interval=1), "%")
            self.update_metric("Memory Usage", process.memory_info().rss / 1024 / 1024, "MB")
            self.update_metric("Thread Count", process.num_threads(), "threads")
            
            chrome_count = sum(1 for p in psutil.process_iter(['name']) 
                             if 'chrome' in p.info['name'].lower())
            self.update_metric("Chrome Processes", chrome_count, "processes")
            
            time.sleep(1)
    
    def start(self):
        self.running = True
        
        monitor_thread = threading.Thread(target=self.monitor_system)
        monitor_thread.daemon = True
        monitor_thread.start()
        
        with Live(self.create_table(), refresh_per_second=1) as live:
            while self.running:
                time.sleep(0.5)
                live.update(self.create_table())
    
    def stop(self):
        self.running = False

# Usage (run in separate thread or process)
dashboard = PerformanceDashboard()

try:
    with Browser() as browser:
        dashboard.update_metric("Browser Status", 1, "running")
except KeyboardInterrupt:
    dashboard.stop()
```

## Debugging Performance Issues

### Performance Profiler

```python
import cProfile
import pstats
import io
from functools import wraps

def profile_performance(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        profiler = cProfile.Profile()
        profiler.enable()
        
        try:
            result = func(*args, **kwargs)
        finally:
            profiler.disable()
            
            s = io.StringIO()
            stats = pstats.Stats(profiler, stream=s)
            stats.strip_dirs()
            stats.sort_stats('cumulative')
            stats.print_stats(10)
            
            print(f"\n=== Profile for {func.__name__} ===")
            print(s.getvalue())
        
        return result
    
    return wrapper

# Usage
@profile_performance
def slow_automation():
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://example.com")
        page.wait_for_timeout(5000)
        return page.title()

title = slow_automation()
```

### Memory Leak Detection

```python
import tracemalloc
import gc

class MemoryLeakDetector:
    def __init__(self):
        self.snapshots = []
        tracemalloc.start()
    
    def take_snapshot(self, label: str):
        gc.collect()
        snapshot = tracemalloc.take_snapshot()
        self.snapshots.append((label, snapshot))
    
    def compare_snapshots(self, index1: int = 0, index2: int = -1):
        if len(self.snapshots) < 2:
            print("Need at least 2 snapshots")
            return
        
        label1, snap1 = self.snapshots[index1]
        label2, snap2 = self.snapshots[index2]
        
        print(f"\n=== Memory Comparison: {label1} → {label2} ===")
        
        top_stats = snap2.compare_to(snap1, 'lineno')
        
        print("Top 10 differences:")
        for stat in top_stats[:10]:
            print(f"{stat}")
    
    def find_leaks(self, threshold_mb: float = 10):
        if len(self.snapshots) < 2:
            return []
        
        first_snap = self.snapshots[0][1]
        last_snap = self.snapshots[-1][1]
        
        first_size = sum(stat.size for stat in first_snap.statistics('filename'))
        last_size = sum(stat.size for stat in last_snap.statistics('filename'))
        
        leak_mb = (last_size - first_size) / 1024 / 1024
        
        if leak_mb > threshold_mb:
            print(f"\n⚠️  Potential memory leak detected: {leak_mb:.2f}MB increase")
            
            top_stats = last_snap.compare_to(first_snap, 'filename')
            print("\nTop growing allocations:")
            for stat in top_stats[:5]:
                if stat.size_diff > 0:
                    print(f"  {stat.filename}: +{stat.size_diff / 1024 / 1024:.2f}MB")

# Usage
detector = MemoryLeakDetector()

detector.take_snapshot("Start")

with Browser() as browser:
    for i in range(10):
        page = browser.new_page()
        page.goto("https://example.com")
    
    detector.take_snapshot("After 10 pages")
    
    for page in browser.pages:
        page.close()
    
    detector.take_snapshot("After cleanup")

detector.compare_snapshots(0, 1)
detector.compare_snapshots(1, 2)
detector.find_leaks()
```

## Best Practices

### 1. Resource Management
- Always close pages when done
- Limit concurrent operations
- Use connection pooling
- Monitor resource usage

### 2. Network Efficiency
- Block unnecessary resources
- Enable caching
- Use CDNs when possible
- Batch API requests

### 3. Browser Configuration
- Use headless mode for better performance
- Disable unnecessary features
- Optimize viewport size
- Use minimal Chrome flags

### 4. Code Optimization
- Avoid unnecessary waits
- Use appropriate wait conditions
- Batch similar operations
- Implement proper error handling

### 5. Monitoring
- Track key metrics
- Set up alerts for anomalies
- Profile bottlenecks
- Regular performance testing

## Additional Resources

- [Browser Architecture](../architecture/browser-lifecycle.md)
- [Memory Management](memory-management.md)
- [Connection Pooling](connection-pooling.md)
- [Monitoring Guide](monitoring.md)
- [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/)
</document_content>
</document>

<document index="31">
<source>docs/performance/memory-management.md</source>
<document_content>
# Memory Management Guide

This guide explains how to manage memory effectively when using PlaywrightAuthor for browser automation.

## Understanding Memory Usage

### Memory Components

```mermaid
graph TD
    subgraph "Chrome Memory Structure"
        Browser[Browser Process<br/>~100MB]
        Renderer1[Renderer Process 1<br/>~50MB]
        Renderer2[Renderer Process 2<br/>~50MB]
        GPU[GPU Process<br/>~30MB]
        Network[Network Service<br/>~20MB]
        Storage[Storage Service<br/>~15MB]
    end
    
    subgraph "PlaywrightAuthor Memory"
        Python[Python Process<br/>~50MB]
        PA[PlaywrightAuthor<br/>~10MB]
        PW[Playwright<br/>~20MB]
        Profile[Profile Data<br/>Variable]
    end
    
    Browser --> Renderer1
    Browser --> Renderer2
    Browser --> GPU
    Browser --> Network
    Browser --> Storage
    
    Python --> PA
    Python --> PW
    PA --> Browser
    PA --> Profile
```

### Memory Growth Patterns

```python
import psutil
import matplotlib.pyplot as plt
from datetime import datetime

class MemoryTracker:
    """Track memory usage over time."""
    
    def __init__(self):
        self.timestamps = []
        self.memory_usage = []
        self.process = psutil.Process()
    
    def record(self):
        """Record current memory usage."""
        self.timestamps.append(datetime.now())
        self.memory_usage.append(self.process.memory_info().rss / 1024 / 1024)
    
    def plot(self, title="Memory Usage Over Time"):
        """Plot memory usage graph."""
        plt.figure(figsize=(12, 6))
        plt.plot(self.timestamps, self.memory_usage, 'b-', linewidth=2)
        plt.xlabel('Time')
        plt.ylabel('Memory (MB)')
        plt.title(title)
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()
    
    def get_statistics(self):
        """Get memory statistics."""
        if not self.memory_usage:
            return {}
        
        return {
            'min_mb': min(self.memory_usage),
            'max_mb': max(self.memory_usage),
            'avg_mb': sum(self.memory_usage) / len(self.memory_usage),
            'growth_mb': self.memory_usage[-1] - self.memory_usage[0],
            'samples': len(self.memory_usage)
        }

# Track memory during automation
tracker = MemoryTracker()

with Browser() as browser:
    tracker.record()  # Initial
    
    for i in range(10):
        page = browser.new_page()
        tracker.record()  # After page creation
        
        page.goto("https://example.com")
        tracker.record()  # After navigation
        
        page.close()
        tracker.record()  # After cleanup

# Analyze results
stats = tracker.get_statistics()
print(f"Memory grew by {stats['growth_mb']:.2f}MB")
tracker.plot()
```

## Memory Optimization Techniques

### 1. Page Lifecycle Management

```python
from contextlib import contextmanager
import weakref

class PageManager:
    """Manage page lifecycle for memory efficiency."""
    
    def __init__(self, browser, max_pages: int = 5):
        self.browser = browser
        self.max_pages = max_pages
        self.pages = weakref.WeakSet()
        self.page_data = {}
    
    @contextmanager
    def create_page(self, page_id: str = None):
        """Create managed page."""
        # Clean up if at limit
        if len(self.pages) >= self.max_pages:
            self._cleanup_oldest()
        
        page = self.browser.new_page()
        self.pages.add(page)
        
        if page_id:
            self.page_data[page_id] = {
                'created': datetime.now(),
                'page': weakref.ref(page)
            }
        
        try:
            yield page
        finally:
            # Always close page
            if not page.is_closed():
                page.close()
            
            # Remove from tracking
            self.pages.discard(page)
            if page_id and page_id in self.page_data:
                del self.page_data[page_id]
    
    def _cleanup_oldest(self):
        """Close oldest pages."""
        # Sort by creation time
        sorted_pages = sorted(
            self.page_data.items(),
            key=lambda x: x[1]['created']
        )
        
        # Close oldest
        if sorted_pages:
            oldest_id, oldest_data = sorted_pages[0]
            page_ref = oldest_data['page']
            page = page_ref()
            
            if page and not page.is_closed():
                page.close()
            
            del self.page_data[oldest_id]

# Usage
with Browser() as browser:
    manager = PageManager(browser, max_pages=3)
    
    # Pages are automatically managed
    with manager.create_page("page1") as page:
        page.goto("https://example.com")
        # Page auto-closes after block
    
    # Old pages cleaned up automatically
    for i in range(10):
        with manager.create_page(f"page{i}") as page:
            page.goto("https://example.com")
```

### 2. Resource Blocking

```python
class ResourceBlocker:
    """Block memory-heavy resources."""
    
    BLOCK_PATTERNS = {
        'images': ['*.jpg', '*.jpeg', '*.png', '*.gif', '*.webp', '*.svg', '*.ico'],
        'media': ['*.mp4', '*.webm', '*.mp3', '*.wav', '*.flac'],
        'fonts': ['*.woff', '*.woff2', '*.ttf', '*.otf'],
        'styles': ['*.css'],
        'scripts': ['*.js'],
    }
    
    @staticmethod
    def apply_blocking(page, block_types: list = None):
        """Apply resource blocking to page."""
        if block_types is None:
            block_types = ['images', 'media', 'fonts']
        
        # Build pattern list
        patterns = []
        for block_type in block_types:
            patterns.extend(ResourceBlocker.BLOCK_PATTERNS.get(block_type, []))
        
        # Block matching resources
        def handle_route(route):
            if any(route.request.url.endswith(pattern.replace('*', '')) 
                   for pattern in patterns):
                route.abort()
            else:
                route.continue_()
        
        page.route("**/*", handle_route)
        
        # Also block by resource type
        page.route("**/*", lambda route: route.abort() 
                   if route.request.resource_type in block_types 
                   else route.continue_())

# Usage
with Browser() as browser:
    page = browser.new_page()
    
    # Block memory-heavy resources
    ResourceBlocker.apply_blocking(page, ['images', 'media', 'fonts'])
    
    # Page loads much faster and uses less memory
    page.goto("https://heavy-website.com")
```

### 3. Cache Management

```python
import shutil
from pathlib import Path

class CacheManager:
    """Manage browser cache for memory efficiency."""
    
    def __init__(self, cache_dir: Path, max_size_mb: int = 100):
        self.cache_dir = Path(cache_dir)
        self.max_size_mb = max_size_mb
    
    def get_cache_size(self) -> float:
        """Get current cache size in MB."""
        if not self.cache_dir.exists():
            return 0
        
        total_size = 0
        for file in self.cache_dir.rglob('*'):
            if file.is_file():
                total_size += file.stat().st_size
        
        return total_size / 1024 / 1024
    
    def clean_cache(self, keep_recent: bool = True):
        """Clean cache to free memory."""
        if not self.cache_dir.exists():
            return
        
        current_size = self.get_cache_size()
        print(f"Cache size before cleaning: {current_size:.2f}MB")
        
        if keep_recent:
            # Remove old files first
            files = []
            for file in self.cache_dir.rglob('*'):
                if file.is_file():
                    files.append((file, file.stat().st_mtime))
            
            # Sort by modification time
            files.sort(key=lambda x: x[1])
            
            # Remove oldest files until under limit
            removed_size = 0
            for file, _ in files:
                if current_size - removed_size < self.max_size_mb:
                    break
                
                file_size = file.stat().st_size
                file.unlink()
                removed_size += file_size / 1024 / 1024
        else:
            # Clear entire cache
            shutil.rmtree(self.cache_dir)
            self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        new_size = self.get_cache_size()
        print(f"Cache size after cleaning: {new_size:.2f}MB")
        print(f"Freed: {current_size - new_size:.2f}MB")

# Usage
from playwrightauthor.utils.paths import cache_dir

cache_manager = CacheManager(cache_dir(), max_size_mb=50)

# Check and clean cache periodically
if cache_manager.get_cache_size() > 50:
    cache_manager.clean_cache()
```

### 4. Memory-Aware Automation

```python
class MemoryAwareAutomation:
    """Automation that adapts based on memory usage."""
    
    def __init__(self, memory_threshold_mb: int = 1024):
        self.memory_threshold_mb = memory_threshold_mb
        self.process = psutil.Process()
        self.gc_frequency = 10  # GC every N operations
        self.operation_count = 0
    
    def check_memory(self) -> dict:
        """Check current memory status."""
        memory_info = self.process.memory_info()
        return {
            'rss_mb': memory_info.rss / 1024 / 1024,
            'vms_mb': memory_info.vms / 1024 / 1024,
            'percent': self.process.memory_percent(),
            'available_mb': psutil.virtual_memory().available / 1024 / 1024
        }
    
    def should_optimize(self) -> bool:
        """Check if memory optimization needed."""
        status = self.check_memory()
        return status['rss_mb'] > self.memory_threshold_mb
    
    def optimize_memory(self):
        """Perform memory optimization."""
        import gc
        
        # Force garbage collection
        gc.collect()
        gc.collect()  # Second pass for cyclic references
        
        # Clear caches
        if hasattr(self, 'browser'):
            for page in self.browser.pages:
                page.evaluate("() => { window.gc && window.gc(); }")
    
    def run_with_memory_management(self, operation):
        """Run operation with memory management."""
        self.operation_count += 1
        
        # Check memory before operation
        if self.should_optimize():
            print(f"Memory threshold exceeded, optimizing...")
            self.optimize_memory()
        
        # Run operation
        result = operation()
        
        # Periodic GC
        if self.operation_count % self.gc_frequency == 0:
            gc.collect()
        
        return result

# Usage
automation = MemoryAwareAutomation(memory_threshold_mb=800)

with Browser() as browser:
    automation.browser = browser
    
    def process_page(url):
        page = browser.new_page()
        page.goto(url)
        data = page.evaluate("() => document.title")
        page.close()
        return data
    
    # Process pages with memory management
    urls = ["https://example.com"] * 100
    results = []
    
    for url in urls:
        result = automation.run_with_memory_management(
            lambda: process_page(url)
        )
        results.append(result)
        
        # Print memory status periodically
        if len(results) % 10 == 0:
            status = automation.check_memory()
            print(f"Processed {len(results)} pages, Memory: {status['rss_mb']:.2f}MB")
```

## Memory Leak Prevention

### Common Memory Leak Sources

1. **Unclosed Pages**
   ```python
   # BAD - Memory leak
   pages = []
   for url in urls:
       page = browser.new_page()
       page.goto(url)
       pages.append(page)  # Pages never closed
   
   # GOOD - Proper cleanup
   for url in urls:
       page = browser.new_page()
       page.goto(url)
       # Process page
       page.close()  # Always close
   ```

2. **Event Listeners**
   ```python
   # BAD - Accumulating listeners
   def add_listener(page):
       page.on("console", lambda msg: print(msg))
   
   for _ in range(100):
       add_listener(page)  # 100 listeners!
   
   # GOOD - Remove listeners
   def process_with_listener(page):
       def console_handler(msg):
           print(msg)
       
       page.on("console", console_handler)
       # Process page
       page.remove_listener("console", console_handler)
   ```

3. **Large Data Retention**
   ```python
   # BAD - Keeping all data in memory
   all_data = []
   for url in urls:
       page = browser.new_page()
       data = page.evaluate("() => document.body.innerHTML")
       all_data.append(data)  # Accumulating large strings
       page.close()
   
   # GOOD - Process and discard
   def process_data(data):
       # Process immediately
       return len(data)  # Return only what's needed
   
   results = []
   for url in urls:
       page = browser.new_page()
       data = page.evaluate("() => document.body.innerHTML")
       result = process_data(data)
       results.append(result)  # Store only small results
       page.close()
   ```

### Memory Leak Detector

```python
import tracemalloc
import linecache
import os

class MemoryLeakDetector:
    """Advanced memory leak detection."""
    
    def __init__(self, top_n: int = 10):
        self.top_n = top_n
        tracemalloc.start()
        self.baseline = None
    
    def take_baseline(self):
        """Take baseline snapshot."""
        self.baseline = tracemalloc.take_snapshot()
    
    def check_for_leaks(self) -> list:
        """Check for memory leaks."""
        if not self.baseline:
            raise ValueError("No baseline snapshot taken")
        
        current = tracemalloc.take_snapshot()
        top_stats = current.compare_to(self.baseline, 'lineno')
        
        leaks = []
        for stat in top_stats[:self.top_n]:
            if stat.size_diff > 1024 * 1024:  # > 1MB growth
                # Get source code line
                filename = stat.traceback[0].filename
                lineno = stat.traceback[0].lineno
                line = linecache.getline(filename, lineno).strip()
                
                leaks.append({
                    'file': os.path.basename(filename),
                    'line': lineno,
                    'code': line,
                    'size_diff_mb': stat.size_diff / 1024 / 1024,
                    'count_diff': stat.count_diff
                })
        
        return leaks
    
    def print_report(self):
        """Print leak detection report."""
        leaks = self.check_for_leaks()
        
        if not leaks:
            print("No significant memory leaks detected")
            return
        
        print("Potential memory leaks detected:")
        for leak in leaks:
            print(f"\n{leak['file']}:{leak['line']}")
            print(f"   Code: {leak['code']}")
            print(f"   Growth: +{leak['size_diff_mb']:.2f}MB ({leak['count_diff']:+d} objects)")

# Usage
detector = MemoryLeakDetector()
detector.take_baseline()

# Run automation
with Browser() as browser:
    for i in range(50):
        page = browser.new_page()
        page.goto("https://example.com")
        # Intentionally not closing some pages to create leak
        if i % 10 != 0:
            page.close()

# Check for leaks
detector.print_report()
```

## Memory Monitoring Tools

### Real-time Memory Monitor

```python
import threading
import time
from collections import deque

class RealTimeMemoryMonitor:
    """Monitor memory usage in real-time."""
    
    def __init__(self, window_size: int = 60):
        self.window_size = window_size
        self.memory_history = deque(maxlen=window_size)
        self.running = False
        self.alert_threshold_mb = 1024
        self.process = psutil.Process()
    
    def start_monitoring(self):
        """Start monitoring in background."""
        self.running = True
        monitor_thread = threading.Thread(target=self._monitor_loop)
        monitor_thread.daemon = True
        monitor_thread.start()
    
    def stop_monitoring(self):
        """Stop monitoring."""
        self.running = False
    
    def _monitor_loop(self):
        """Monitor loop."""
        while self.running:
            memory_mb = self.process.memory_info().rss / 1024 / 1024
            self.memory_history.append({
                'timestamp': time.time(),
                'memory_mb': memory_mb
            })
            
            # Check for alerts
            if memory_mb > self.alert_threshold_mb:
                self._trigger_alert(memory_mb)
            
            time.sleep(1)
    
    def _trigger_alert(self, memory_mb: float):
        """Trigger memory alert."""
        print(f"MEMORY ALERT: {memory_mb:.2f}MB exceeds threshold of {self.alert_threshold_mb}MB")
    
    def get_statistics(self) -> dict:
        """Get memory statistics."""
        if not self.memory_history:
            return {}
        
        memory_values = [h['memory_mb'] for h in self.memory_history]
        
        return {
            'current_mb': memory_values[-1] if memory_values else 0,
            'min_mb': min(memory_values),
            'max_mb': max(memory_values),
            'avg_mb': sum(memory_values) / len(memory_values),
            'trend': 'increasing' if memory_values[-1] > memory_values[0] else 'decreasing'
        }

# Usage
monitor = RealTimeMemoryMonitor()
monitor.alert_threshold_mb = 800
monitor.start_monitoring()

try:
    with Browser() as browser:
        # Your automation code
        for i in range(30):
            page = browser.new_page()
            page.goto("https://example.com")
            
            # Check memory stats
            if i % 10 == 0:
                stats = monitor.get_statistics()
                print(f"\nMemory Stats after {i} pages:")
                print(f"  Current: {stats.get('current_mb', 0):.2f}MB")
                print(f"  Average: {stats.get('avg_mb', 0):.2f}MB")
                print(f"  Trend: {stats.get('trend', 'unknown')}")
            
            time.sleep(1)
            page.close()

finally:
    monitor.stop_monitoring()
```

## Memory Best Practices

1. **Always Close Resources**
   - Close pages when done
   - Close contexts when done
   - Remove event listeners

2. **Limit Concurrent Operations**
   - Control number of open pages
   - Batch operations
   - Use page recycling

3. **Block Unnecessary Resources**
   - Images and media
   - Fonts and stylesheets
   - Third-party scripts

4. **Monitor Memory Usage**
   - Set up alerts
   - Track trends
   - Profile memory hotspots

5. **Implement Cleanup Strategies**
   - Periodic garbage collection
   - Cache clearing
   - Profile rotation

## Additional Resources

- [Performance Optimization](index.md)
- [Connection Pooling](connection-pooling.md)
- [Resource Management](../architecture/components.md#resource-management)
- [Chrome Memory Profiling](https://developer.chrome.com/docs/devtools/memory-problems/)
</document_content>
</document>

<document index="32">
<source>docs/performance/monitoring.md</source>
<document_content>
# Performance Monitoring Guide

This guide covers monitoring strategies for PlaywrightAuthor, including metrics collection, alerting, debugging, and production monitoring.

## Monitoring Overview

Effective monitoring helps you:
- Detect issues before they impact users
- Optimize performance by finding bottlenecks
- Track automation usage patterns
- Maintain system reliability

## Key Metrics to Monitor

### System Metrics

```mermaid
graph TD
    subgraph "Resource Metrics"
        CPU[CPU Usage]
        Memory[Memory Usage]
        Disk[Disk I/O]
        Network[Network I/O]
    end
    
    subgraph "Browser Metrics"
        Instances[Active Instances]
        Pages[Open Pages]
        Connections[CDP Connections]
        Crashes[Crash Rate]
    end
    
    subgraph "Performance Metrics"
        ResponseTime[Response Time]
        Throughput[Throughput]
        ErrorRate[Error Rate]
        QueueLength[Queue Length]
    end
    
    subgraph "Business Metrics"
        Success[Success Rate]
        Duration[Task Duration]
        Retries[Retry Count]
        SLA[SLA Compliance]
    end
```

### Metric Collection Implementation

```python
from dataclasses import dataclass, field
from typing import Dict, List, Optional
import time
import psutil
import statistics
from datetime import datetime, timedelta
from collections import defaultdict, deque

@dataclass
class MetricPoint:
    """Single metric data point."""
    name: str
    value: float
    timestamp: float = field(default_factory=time.time)
    tags: Dict[str, str] = field(default_factory=dict)
    
@dataclass
class MetricSummary:
    """Summary statistics for a metric."""
    name: str
    count: int
    mean: float
    median: float
    min: float
    max: float
    p95: float
    p99: float
    std_dev: float

class MetricsCollector:
    """Comprehensive metrics collection system."""
    
    def __init__(self, window_size: int = 300):  # 5-minute window
        self.window_size = window_size
        self.metrics: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))
        self.counters: Dict[str, int] = defaultdict(int)
        self.gauges: Dict[str, float] = {}
        self.histograms: Dict[str, List[float]] = defaultdict(list)
        
        # System monitoring
        self.process = psutil.Process()
        
    def record_counter(self, name: str, value: int = 1, tags: Dict[str, str] = None):
        """Record counter metric (cumulative)."""
        self.counters[name] += value
        
        metric = MetricPoint(name, self.counters[name], tags=tags or {})
        self.metrics[name].append(metric)
    
    def record_gauge(self, name: str, value: float, tags: Dict[str, str] = None):
        """Record gauge metric (point-in-time)."""
        self.gauges[name] = value
        
        metric = MetricPoint(name, value, tags=tags or {})
        self.metrics[name].append(metric)
    
    def record_histogram(self, name: str, value: float, tags: Dict[str, str] = None):
        """Record histogram metric (distribution)."""
        self.histograms[name].append(value)
        
        # Keep only recent values
        cutoff_time = time.time() - self.window_size
        self.histograms[name] = [
            v for i, v in enumerate(self.histograms[name])
            if i > len(self.histograms[name]) - 1000
        ]
        
        metric = MetricPoint(name, value, tags=tags or {})
        self.metrics[name].append(metric)
    
    def record_timing(self, name: str, duration: float, tags: Dict[str, str] = None):
        """Record timing metric."""
        self.record_histogram(f"{name}.duration", duration, tags)
    
    def get_summary(self, name: str) -> Optional[MetricSummary]:
        """Get summary statistics for a metric."""
        if name in self.histograms and self.histograms[name]:
            values = self.histograms[name]
        elif name in self.metrics and self.metrics[name]:
            values = [m.value for m in self.metrics[name]]
        else:
            return None
        
        if not values:
            return None
        
        sorted_values = sorted(values)
        
        return MetricSummary(
            name=name,
            count=len(values),
            mean=statistics.mean(values),
            median=statistics.median(values),
            min=min(values),
            max=max(values),
            p95=sorted_values[int(len(sorted_values) * 0.95)],
            p99=sorted_values[int(len(sorted_values) * 0.99)],
            std_dev=statistics.stdev(values) if len(values) > 1 else 0
        )
    
    def collect_system_metrics(self):
        """Collect system resource metrics."""
        # CPU metrics
        cpu_percent = self.process.cpu_percent(interval=0.1)
        self.record_gauge("system.cpu.percent", cpu_percent)
        
        # Memory metrics
        memory_info = self.process.memory_info()
        self.record_gauge("system.memory.rss_mb", memory_info.rss / 1024 / 1024)
        self.record_gauge("system.memory.vms_mb", memory_info.vms / 1024 / 1024)
        self.record_gauge("system.memory.percent", self.process.memory_percent())
        
        # Thread count
        self.record_gauge("system.threads", self.process.num_threads())
        
        # File descriptors (Unix)
        try:
            self.record_gauge("system.fds", self.process.num_fds())
        except AttributeError:
            pass  # Not available on Windows
        
        # Chrome process count
        chrome_count = sum(
            1 for p in psutil.process_iter(['name'])
            if 'chrome' in p.info['name'].lower()
        )
        self.record_gauge("browser.process_count", chrome_count)

# Global metrics instance
metrics = MetricsCollector()
```

## Monitoring Decorators

### Performance Monitoring Decorators

```python
from functools import wraps
import asyncio
from contextlib import contextmanager

def monitor_performance(metric_name: str = None):
    """Decorator to monitor function performance."""
    def decorator(func):
        name = metric_name or f"{func.__module__}.{func.__name__}"
        
        @wraps(func)
        def sync_wrapper(*args, **kwargs):
            start_time = time.time()
            error = None
            
            try:
                result = func(*args, **kwargs)
                metrics.record_counter(f"{name}.success")
                return result
            
            except Exception as e:
                error = e
                metrics.record_counter(f"{name}.error")
                metrics.record_counter(f"{name}.error.{type(e).__name__}")
                raise
            
            finally:
                duration = time.time() - start_time
                metrics.record_timing(name, duration * 1000)  # Convert to ms
                
                if error:
                    metrics.record_counter(f"{name}.total")
        
        @wraps(func)
        async def async_wrapper(*args, **kwargs):
            start_time = time.time()
            error = None
            
            try:
                result = await func(*args, **kwargs)
                metrics.record_counter(f"{name}.success")
                return result
            
            except Exception as e:
                error = e
                metrics.record_counter(f"{name}.error")
                metrics.record_counter(f"{name}.error.{type(e).__name__}")
                raise
            
            finally:
                duration = time.time() - start_time
                metrics.record_timing(name, duration * 1000)
                
                if error:
                    metrics.record_counter(f"{name}.total")
        
        return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper
    
    return decorator

@contextmanager
def monitor_operation(name: str, tags: Dict[str, str] = None):
    """Context manager for monitoring operations."""
    start_time = time.time()
    error = None
    
    metrics.record_counter(f"{name}.started", tags=tags)
    
    try:
        yield
        metrics.record_counter(f"{name}.success", tags=tags)
    
    except Exception as e:
        error = e
        metrics.record_counter(f"{name}.error", tags=tags)
        metrics.record_counter(f"{name}.error.{type(e).__name__}", tags=tags)
        raise
    
    finally:
        duration = time.time() - start_time
        metrics.record_timing(name, duration * 1000, tags=tags)
        metrics.record_counter(f"{name}.completed", tags=tags)

# Usage examples
@monitor_performance()
def fetch_page(url: str):
    with Browser() as browser:
        page = browser.new_page()
        page.goto(url)
        return page.title()

@monitor_performance("custom.metric.name")
async def async_operation():
    await asyncio.sleep(1)
    return "Done"

# Context manager usage
with monitor_operation("batch_processing", tags={"batch_id": "123"}):
    # Process batch
    pass
```

## Real-time Monitoring Dashboard

### Terminal Dashboard

```python
from rich.console import Console
from rich.table import Table
from rich.live import Live
from rich.layout import Layout
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
import threading

class MonitoringDashboard:
    """Real-time monitoring dashboard in terminal."""
    
    def __init__(self, metrics_collector: MetricsCollector):
        self.metrics = metrics_collector
        self.console = Console()
        self.running = False
        
    def create_layout(self) -> Layout:
        """Create dashboard layout."""
        layout = Layout()
        
        layout.split(
            Layout(name="header", size=3),
            Layout(name="body"),
            Layout(name="footer", size=3)
        )
        
        layout["body"].split_row(
            Layout(name="left"),
            Layout(name="right")
        )
        
        layout["left"].split(
            Layout(name="system"),
            Layout(name="browser")
        )
        
        layout["right"].split(
            Layout(name="performance"),
            Layout(name="errors")
        )
        
        return layout
    
    def create_system_panel(self) -> Panel:
        """Create system metrics panel."""
        # Collect current metrics
        self.metrics.collect_system_metrics()
        
        table = Table(show_header=False, expand=True)
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="green")
        
        # Add system metrics
        cpu = self.metrics.gauges.get("system.cpu.percent", 0)
        memory = self.metrics.gauges.get("system.memory.rss_mb", 0)
        threads = self.metrics.gauges.get("system.threads", 0)
        
        table.add_row("CPU Usage", f"{cpu:.1f}%")
        table.add_row("Memory", f"{memory:.1f} MB")
        table.add_row("Threads", str(int(threads)))
        
        # Add Chrome metrics
        chrome_count = self.metrics.gauges.get("browser.process_count", 0)
        table.add_row("Chrome Processes", str(int(chrome_count)))
        
        return Panel(table, title="System Metrics", border_style="blue")
    
    def create_performance_panel(self) -> Panel:
        """Create performance metrics panel."""
        table = Table(show_header=True, expand=True)
        table.add_column("Operation", style="cyan")
        table.add_column("Count", style="yellow")
        table.add_column("Avg (ms)", style="green")
        table.add_column("P95 (ms)", style="orange")
        
        # Get timing metrics
        for name, values in self.metrics.histograms.items():
            if name.endswith(".duration") and values:
                op_name = name.replace(".duration", "")
                summary = self.metrics.get_summary(name)
                
                if summary:
                    table.add_row(
                        op_name,
                        str(summary.count),
                        f"{summary.mean:.1f}",
                        f"{summary.p95:.1f}"
                    )
        
        return Panel(table, title="Performance Metrics", border_style="green")
    
    def create_error_panel(self) -> Panel:
        """Create error metrics panel."""
        table = Table(show_header=True, expand=True)
        table.add_column("Error Type", style="red")
        table.add_column("Count", style="yellow")
        table.add_column("Rate", style="orange")
        
        # Get error metrics
        total_errors = 0
        error_types = {}
        
        for name, value in self.metrics.counters.items():
            if ".error." in name:
                error_type = name.split(".")[-1]
                error_types[error_type] = error_types.get(error_type, 0) + value
                total_errors += value
        
        # Calculate rates
        for error_type, count in error_types.items():
            rate = (count / total_errors * 100) if total_errors > 0 else 0
            table.add_row(error_type, str(count), f"{rate:.1f}%")
        
        return Panel(table, title="Error Metrics", border_style="red")
    
    def update_display(self, layout: Layout):
        """Update dashboard display."""
        layout["header"].update(
            Panel(
                f"[bold blue]PlaywrightAuthor Monitoring Dashboard[/bold blue] - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                style="white on blue"
            )
        )
        
        layout["system"].update(self.create_system_panel())
        layout["performance"].update(self.create_performance_panel())
        layout["errors"].update(self.create_error_panel())
        
        # Browser status
        browser_status = Table(show_header=False)
        browser_status.add_column("Status", style="cyan")
        browser_status.add_column("Value", style="green")
        
        active_browsers = self.metrics.gauges.get("browser.active", 0)
        idle_browsers = self.metrics.gauges.get("browser.idle", 0)
        
        browser_status.add_row("Active Browsers", str(int(active_browsers)))
        browser_status.add_row("Idle Browsers", str(int(idle_browsers)))
        
        layout["browser"].update(
            Panel(browser_status, title="Browser Status", border_style="yellow")
        )
        
        layout["footer"].update(
            Panel(
                "[dim]Press Ctrl+C to exit[/dim]",
                style="white on black"
            )
        )
    
    def run(self):
        """Run the dashboard."""
        self.running = True
        layout = self.create_layout()
        
        with Live(layout, refresh_per_second=1, screen=True) as live:
            while self.running:
                self.update_display(layout)
                time.sleep(1)
    
    def stop(self):
        """Stop the dashboard."""
        self.running = False

# Usage
dashboard = MonitoringDashboard(metrics)

# Run in separate thread
dashboard_thread = threading.Thread(target=dashboard.run)
dashboard_thread.daemon = True
dashboard_thread.start()

# Your automation code here...
# dashboard.stop() when done
```

## Alerting System

### Alert Configuration

```python
from enum import Enum
from typing import Callable, Optional
import smtplib
from email.mime.text import MIMEText

class AlertSeverity(Enum):
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

@dataclass
class Alert:
    """Alert definition."""
    name: str
    condition: str
    threshold: float
    severity: AlertSeverity
    message_template: str
    cooldown_seconds: int = 300
    
@dataclass
class AlertEvent:
    """Alert event instance."""
    alert: Alert
    value: float
    timestamp: float
    message: str

class AlertManager:
    """Manage monitoring alerts."""
    
    def __init__(self, metrics_collector: MetricsCollector):
        self.metrics = metrics_collector
        self.alerts: List[Alert] = []
        self.alert_history: Dict[str, float] = {}
        self.handlers: List[Callable[[AlertEvent], None]] = []
        
    def add_alert(self, alert: Alert):
        """Add alert definition."""
        self.alerts.append(alert)
    
    def add_handler(self, handler: Callable[[AlertEvent], None]):
        """Add alert handler."""
        self.handlers.append(handler)
    
    def check_alerts(self):
        """Check all alert conditions."""
        current_time = time.time()
        
        for alert in self.alerts:
            # Check cooldown
            last_alert = self.alert_history.get(alert.name, 0)
            if current_time - last_alert < alert.cooldown_seconds:
                continue
            
            # Evaluate condition
            value = self._evaluate_condition(alert.condition)
            
            if value is not None and value > alert.threshold:
                # Trigger alert
                event = AlertEvent(
                    alert=alert,
                    value=value,
                    timestamp=current_time,
                    message=alert.message_template.format(
                        value=value,
                        threshold=alert.threshold,
                        name=alert.name
                    )
                )
                
                self._trigger_alert(event)
                self.alert_history[alert.name] = current_time
    
    def _evaluate_condition(self, condition: str) -> Optional[float]:
        """Evaluate alert condition."""
        # Simple condition evaluation
        if condition.startswith("gauge:"):
            metric_name = condition.replace("gauge:", "")
            return self.metrics.gauges.get(metric_name)
        
        elif condition.startswith("rate:"):
            metric_name = condition.replace("rate:", "")
            # Calculate rate over last minute
            if metric_name in self.metrics.metrics:
                recent = [
                    m for m in self.metrics.metrics[metric_name]
                    if m.timestamp > time.time() - 60
                ]
                return len(recent) / 60 if recent else 0
        
        elif condition.startswith("p95:"):
            metric_name = condition.replace("p95:", "")
            summary = self.metrics.get_summary(metric_name)
            return summary.p95 if summary else None
        
        return None
    
    def _trigger_alert(self, event: AlertEvent):
        """Trigger alert handlers."""
        for handler in self.handlers:
            try:
                handler(event)
            except Exception as e:
                print(f"Alert handler error: {e}")

# Alert handlers
def console_alert_handler(event: AlertEvent):
    """Print alerts to console."""
    severity_colors = {
        AlertSeverity.INFO: "blue",
        AlertSeverity.WARNING: "yellow",
        AlertSeverity.ERROR: "red",
        AlertSeverity.CRITICAL: "red bold"
    }
    
    color = severity_colors.get(event.alert.severity, "white")
    timestamp = datetime.fromtimestamp(event.timestamp).strftime("%H:%M:%S")
    
    print(f"[{color}][{timestamp}] {event.alert.severity.value.upper()}: {event.message}[/{color}]")

def email_alert_handler(event: AlertEvent, smtp_config: dict):
    """Send email alerts."""
    if event.alert.severity not in [AlertSeverity.ERROR, AlertSeverity.CRITICAL]:
        return
    
    msg = MIMEText(f"""
    Alert: {event.alert.name}
    Severity: {event.alert.severity.value}
    Time: {datetime.fromtimestamp(event.timestamp)}
    
    {event.message}
    
    Current Value: {event.value}
    Threshold: {event.alert.threshold}
    """)
    
    msg['Subject'] = f"[{event.alert.severity.value.upper()}] {event.alert.name}"
    msg['From'] = smtp_config['from']
    msg['To'] = smtp_config['to']
    
    with smtplib.SMTP(smtp_config['host'], smtp_config['port']) as server:
        if smtp_config.get('use_tls'):
            server.starttls()
        if smtp_config.get('username'):
            server.login(smtp_config['username'], smtp_config['password'])
        server.send_message(msg)

# Configure alerts
alert_manager = AlertManager(metrics)

# Add alert definitions
alert_manager.add_alert(Alert(
    name="high_memory_usage",
    condition="gauge:system.memory.percent",
    threshold=80.0,
    severity=AlertSeverity.WARNING,
    message_template="Memory usage {value:.1f}% exceeds threshold {threshold}%"
))

alert_manager.add_alert(Alert(
    name="high_error_rate",
    condition="rate:page.load.error",
    threshold=0.1,  # 10% error rate
    severity=AlertSeverity.ERROR,
    message_template="Error rate {value:.2f} exceeds threshold {threshold}"
))

alert_manager.add_alert(Alert(
    name="slow_response_time",
    condition="p95:page.load.duration",
    threshold=5000,  # 5 seconds
    severity=AlertSeverity.WARNING,
    message_template="P95 response time {value:.0f}ms exceeds {threshold}ms"
))

# Add handlers
alert_manager.add_handler(console_alert_handler)

# Start alert checking
def alert_check_loop():
    while True:
        alert_manager.check_alerts()
        time.sleep(10)  # Check every 10 seconds

alert_thread = threading.Thread(target=alert_check_loop)
alert_thread.daemon = True
alert_thread.start()
```

## Production Monitoring Integration

### Prometheus Exporter

```python
from prometheus_client import Counter, Gauge, Histogram, Summary
from prometheus_client import start_http_server, generate_latest
import prometheus_client

class PrometheusExporter:
    """Export metrics to Prometheus."""
    
    def __init__(self, metrics_collector: MetricsCollector, port: int = 8000):
        self.metrics = metrics_collector
        self.port = port
        
        # Define Prometheus metrics
        self.prom_counters = {}
        self.prom_gauges = {}
        self.prom_histograms = {}
        
        # System metrics
        self.cpu_gauge = Gauge('playwrightauthor_cpu_percent', 'CPU usage percentage')
        self.memory_gauge = Gauge('playwrightauthor_memory_mb', 'Memory usage in MB')
        self.threads_gauge = Gauge('playwrightauthor_threads', 'Number of threads')
        
        # Browser metrics
        self.browser_gauge = Gauge('playwrightauthor_browsers_total', 'Total browser instances')
        self.page_gauge = Gauge('playwrightauthor_pages_total', 'Total pages open')
        
        # Performance metrics
        self.request_duration = Histogram(
            'playwrightauthor_request_duration_seconds',
            'Request duration in seconds',
            ['operation']
        )
        
        self.error_counter = Counter(
            'playwrightauthor_errors_total',
            'Total errors',
            ['error_type']
        )
    
    def update_metrics(self):
        """Update Prometheus metrics from collector."""
        # Update system metrics
        self.cpu_gauge.set(self.metrics.gauges.get('system.cpu.percent', 0))
        self.memory_gauge.set(self.metrics.gauges.get('system.memory.rss_mb', 0))
        self.threads_gauge.set(self.metrics.gauges.get('system.threads', 0))
        
        # Update browser metrics
        self.browser_gauge.set(self.metrics.gauges.get('browser.process_count', 0))
        
        # Update performance metrics
        for name, values in self.metrics.histograms.items():
            if name.endswith('.duration') and values:
                op_name = name.replace('.duration', '')
                
                # Create histogram if not exists
                if op_name not in self.prom_histograms:
                    self.prom_histograms[op_name] = Histogram(
                        f'playwrightauthor_{op_name}_duration_ms',
                        f'{op_name} duration in milliseconds'
                    )
                
                # Add recent values
                for value in values[-100:]:  # Last 100 values
                    self.prom_histograms[op_name].observe(value)
    
    def start(self):
        """Start Prometheus exporter."""
        # Start HTTP server
        start_http_server(self.port)
        
        # Update loop
        def update_loop():
            while True:
                self.update_metrics()
                time.sleep(10)
        
        update_thread = threading.Thread(target=update_loop)
        update_thread.daemon = True
        update_thread.start()
        
        print(f"Prometheus metrics available at http://localhost:{self.port}/metrics")

# Start Prometheus exporter
exporter = PrometheusExporter(metrics, port=8000)
exporter.start()
```

### OpenTelemetry Integration

```python
from opentelemetry import trace, metrics as otel_metrics
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.exporter.otlp.proto.grpc.metric_exporter import OTLPMetricExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.sdk.metrics import MeterProvider
from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader

def setup_opentelemetry(service_name: str = "playwrightauthor"):
    """Setup OpenTelemetry instrumentation."""
    
    # Setup tracing
    trace.set_tracer_provider(TracerProvider())
    tracer = trace.get_tracer(service_name)
    
    # Add OTLP exporter
    otlp_exporter = OTLPSpanExporter(
        endpoint="localhost:4317",
        insecure=True
    )
    
    span_processor = BatchSpanProcessor(otlp_exporter)
    trace.get_tracer_provider().add_span_processor(span_processor)
    
    # Setup metrics
    metric_reader = PeriodicExportingMetricReader(
        exporter=OTLPMetricExporter(endpoint="localhost:4317"),
        export_interval_millis=10000
    )
    
    provider = MeterProvider(metric_readers=[metric_reader])
    otel_metrics.set_meter_provider(provider)
    meter = otel_metrics.get_meter(service_name)
    
    return tracer, meter

# Use OpenTelemetry
tracer, meter = setup_opentelemetry()

# Create metrics
page_counter = meter.create_counter(
    "pages_processed",
    description="Number of pages processed"
)

response_time_histogram = meter.create_histogram(
    "response_time",
    description="Response time in milliseconds"
)

# Instrumented function
def process_page_with_telemetry(url: str):
    with tracer.start_as_current_span("process_page") as span:
        span.set_attribute("url", url)
        
        start_time = time.time()
        
        try:
            with Browser() as browser:
                page = browser.new_page()
                page.goto(url)
                title = page.title()
                page.close()
                
            # Record success
            span.set_attribute("success", True)
            page_counter.add(1, {"status": "success"})
            
            return title
            
        except Exception as e:
            # Record error
            span.set_attribute("success", False)
            span.record_exception(e)
            page_counter.add(1, {"status": "error"})
            raise
            
        finally:
            # Record timing
            duration = (time.time() - start_time) * 1000
            response_time_histogram.record(duration, {"url": url})
```

## Debug Monitoring

### Chrome DevTools Protocol Monitoring

```python
class CDPMonitor:
    """Monitor Chrome DevTools Protocol events."""
    
    def __init__(self):
        self.events = deque(maxlen=1000)
        self.event_counts = defaultdict(int)
        
    def setup_cdp_monitoring(self, page):
        """Setup CDP event monitoring for a page."""
        client = page.context._browser._connection._transport._ws
        
        # Monitor all CDP events
        original_send = client.send
        original_recv = client.recv
        
        def monitored_send(data):
            try:
                import json
                message = json.loads(data)
                
                if 'method' in message:
                    self.event_counts[f"cdp.send.{message['method']}"] += 1
                    metrics.record_counter(f"cdp.send.{message['method']}")
                
                self.events.append({
                    'type': 'send',
                    'data': message,
                    'timestamp': time.time()
                })
                
            except:
                pass
            
            return original_send(data)
        
        def monitored_recv():
            data = original_recv()
            
            try:
                import json
                message = json.loads(data)
                
                if 'method' in message:
                    self.event_counts[f"cdp.recv.{message['method']}"] += 1
                    metrics.record_counter(f"cdp.recv.{message['method']}")
                
                self.events.append({
                    'type': 'recv',
                    'data': message,
                    'timestamp': time.time()
                })
                
            except:
                pass
            
            return data
        
        client.send = monitored_send
        client.recv = monitored_recv
    
    def get_event_summary(self) -> Dict[str, int]:
        """Get summary of CDP events."""
        return dict(self.event_counts)
    
    def get_recent_events(self, count: int = 10) -> List[dict]:
        """Get recent CDP events."""
        return list(self.events)[-count:]

# Usage
cdp_monitor = CDPMonitor()

with Browser() as browser:
    page = browser.new_page()
    cdp_monitor.setup_cdp_monitoring(page)
    
    # Your automation...
    page.goto("https://example.com")
    
    # Check CDP events
    print("CDP Event Summary:")
    for event, count in cdp_monitor.get_event_summary().items():
        print(f"  {event}: {count}")
```

## Monitoring Best Practices

1. **Start Simple**
   - Monitor key metrics first
   - Add complexity gradually
   - Avoid overwhelming metric volume

2. **Set Meaningful Alerts**
   - Alert on user-impacting symptoms
   - Use thresholds based on actual performance requirements
   - Prevent alert fatigue with cooldown periods

3. **Use Sampling**
   - Don't record every single event
   - Sample statistically significant data
   - Aggregate before storage

4. **Monitor Business Metrics**
   - Success and failure rates
   - Task completion times
   - User-facing error counts

5. **Implement SLIs/SLOs**
   - Define Service Level Indicators (what you measure)
   - Set Service Level Objectives (your targets)
   - Track error budgets (how much failure you can afford)

## Additional Resources

- [Performance Optimization](index.md)
- [Memory Management](memory-management.md)
- [Production Monitoring](../architecture/components.md#monitoring-system)
- [Prometheus Best Practices](https://prometheus.io/docs/practices/)
- [OpenTelemetry Documentation](https://opentelemetry.io/docs/)
</document_content>
</document>

<document index="33">
<source>docs/platforms/index.md</source>
<document_content>
# Platform-Specific Guides

PlaywrightAuthor works across Windows, macOS, and Linux. Each platform has its quirks.

## Choose Your Platform

### [macOS Guide](macos.md)
- M1 vs Intel setup
- Security permissions
- Homebrew notes
- Gatekeeper workarounds

### [Windows Guide](windows.md)
- UAC settings
- Antivirus exceptions
- PowerShell policies
- Windows Defender tweaks

### [Linux Guide](linux.md)
- Distribution-specific steps
- Docker use
- Desktop environments
- Headless servers

## Quick Platform Detection

```python
from playwrightauthor import Browser
import platform

system = platform.system()
print(f"Running on: {system}")

# Platform-specific config
if system == "Darwin":  # macOS
    with Browser(args=["--disable-gpu-sandbox"]) as browser:
        pass
elif system == "Windows":
    with Browser(viewport_height=900) as browser:
        pass
else:  # Linux
    with Browser(headless=True) as browser:
        pass
```

## Common Cross-Platform Issues

### Chrome Installation Paths

| Platform | Default Chrome Locations |
|----------|-------------------------|
| **macOS** | `/Applications/Google Chrome.app`<br>`~/Applications/Google Chrome.app`<br>`/Applications/Chrome for Testing.app` |
| **Windows** | `C:\Program Files\Google\Chrome\Application\chrome.exe`<br>`C:\Program Files (x86)\Google\Chrome\Application\chrome.exe`<br>`%LOCALAPPDATA%\Google\Chrome\Application\chrome.exe` |
| **Linux** | `/usr/bin/google-chrome`<br>`/usr/bin/chromium`<br>`/snap/bin/chromium`<br>`/usr/bin/google-chrome-stable` |

### Profile Storage Locations

| Platform | PlaywrightAuthor Data Directory |
|----------|--------------------------------|
| **macOS** | `~/Library/Application Support/playwrightauthor/` |
| **Windows** | `%LOCALAPPDATA%\playwrightauthor\` |
| **Linux** | `~/.local/share/playwrightauthor/` |

### Environment Variables

Supported on all platforms:

```bash
# Custom Chrome path
export PLAYWRIGHTAUTHOR_CHROME_PATH="/path/to/chrome"

# Debug port
export PLAYWRIGHTAUTHOR_DEBUG_PORT="9333"

# Verbose logging
export PLAYWRIGHTAUTHOR_VERBOSE="true"

# Data directory
export PLAYWRIGHTAUTHOR_DATA_DIR="/custom/path"
```

## Docker Support

For consistent behavior across platforms:

```dockerfile
FROM python:3.12-slim

# Install Chrome dependencies
RUN apt-get update && apt-get install -y \
    wget \
    gnupg \
    libglib2.0-0 \
    libnss3 \
    libnspr4 \
    libatk1.0-0 \
    libatk-bridge2.0-0 \
    libcups2 \
    libdrm2 \
    libdbus-1-3 \
    libxkbcommon0 \
    libxcomposite1 \
    libxdamage1 \
    libxrandr2 \
    libgbm1 \
    libpango-1.0-0 \
    libcairo2 \
    libasound2 \
    && rm -rf /var/lib/apt/lists/*

# Install PlaywrightAuthor
RUN pip install playwrightauthor

# Your application
COPY . /app
WORKDIR /app

CMD ["python", "app.py"]
```

## Security Considerations

### macOS
- Terminal/IDE needs Accessibility permissions
- Chrome code signing checks
- Keychain for credentials

### Windows
- May need Administrator rights
- Defender scanning affects performance
- Credential Manager support

### Linux
- SELinux/AppArmor rules
- X11 vs Wayland
- sudo for system Chrome

## Performance

| Platform | Cold Start | Warm Start | Memory | Best For |
|----------|------------|------------|--------|----------|
| **macOS** | 2-3s | 0.5s | ~250MB | Development |
| **Windows** | 3-5s | 1s | ~300MB | Enterprise |
| **Linux** | 1-2s | 0.3s | ~200MB | Servers |

## Platform Optimizations

### macOS
```python
# Retina display support
with Browser(device_scale_factor=2) as browser:
    pass
```

### Windows
```python
# Proxy settings
import os
os.environ['NO_PROXY'] = 'localhost,127.0.0.1'
```

### Linux
```python
# Headless mode
with Browser(
    headless=True,
    args=['--no-sandbox', '--disable-setuid-sandbox']
) as browser:
    pass
```

## Resources

- [Installation Guide](../installation.md)
- [Troubleshooting](../auth/troubleshooting.md)
- [Performance Tips](../performance/optimization.md)
- [Docker Deployment](../deployment/docker.md)
</document_content>
</document>

<document index="34">
<source>docs/platforms/linux.md</source>
<document_content>
# Linux Platform Guide

This guide covers Linux-specific setup, configuration, and troubleshooting for PlaywrightAuthor across various distributions.

## Quick Start

```bash
# Install PlaywrightAuthor
pip install playwrightauthor

# Install Chrome dependencies (Ubuntu/Debian)
sudo apt-get update
sudo apt-get install -y \
    libnss3 libnspr4 libatk1.0-0 libatk-bridge2.0-0 \
    libcups2 libdrm2 libxkbcommon0 libxcomposite1 \
    libxdamage1 libxrandr2 libgbm1 libpango-1.0-0 \
    libcairo2 libasound2

# First run
python -c "from playwrightauthor import Browser; Browser().__enter__()"
```

## Distribution-Specific Installation

### Ubuntu/Debian

```bash
# Add Google Chrome repository
wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" | \
    sudo tee /etc/apt/sources.list.d/google-chrome.list

# Install Chrome
sudo apt-get update
sudo apt-get install -y google-chrome-stable

# Or install Chromium
sudo apt-get install -y chromium-browser
```

### Fedora/CentOS/RHEL

```bash
# Add Chrome repository
sudo dnf config-manager --set-enabled google-chrome
cat << EOF | sudo tee /etc/yum.repos.d/google-chrome.repo
[google-chrome]
name=google-chrome
baseurl=http://dl.google.com/linux/chrome/rpm/stable/x86_64
enabled=1
gpgcheck=1
gpgkey=https://dl.google.com/linux/linux_signing_key.pub
EOF

# Install Chrome
sudo dnf install -y google-chrome-stable

# Or install Chromium
sudo dnf install -y chromium
```

### Arch Linux

```bash
# Install from AUR
yay -S google-chrome

# Or install Chromium
sudo pacman -S chromium
```

### Alpine Linux (Minimal/Docker)

```bash
# Install Chromium and dependencies
apk add --no-cache \
    chromium \
    nss \
    freetype \
    freetype-dev \
    harfbuzz \
    ca-certificates \
    ttf-freefont \
    font-noto-emoji
```

### Automated Distribution Detection

```python
import subprocess
import os

def detect_distribution():
    """Detect Linux distribution."""
    if os.path.exists('/etc/os-release'):
        with open('/etc/os-release') as f:
            info = dict(line.strip().split('=', 1) 
                       for line in f if '=' in line)
            return {
                'id': info.get('ID', '').strip('"'),
                'name': info.get('NAME', '').strip('"'),
                'version': info.get('VERSION_ID', '').strip('"')
            }
    return None

def install_chrome_dependencies():
    """Install Chrome dependencies based on distribution."""
    distro = detect_distribution()
    if not distro:
        print("Could not detect distribution")
        return
    
    print(f"Detected: {distro['name']} {distro['version']}")
    
    commands = {
        'ubuntu': [
            'sudo apt-get update',
            'sudo apt-get install -y libnss3 libnspr4 libatk1.0-0 libatk-bridge2.0-0 libcups2'
        ],
        'debian': [
            'sudo apt-get update',
            'sudo apt-get install -y libnss3 libnspr4 libatk1.0-0 libatk-bridge2.0-0 libcups2'
        ],
        'fedora': [
            'sudo dnf install -y nss nspr atk cups-libs'
        ],
        'centos': [
            'sudo yum install -y nss nspr atk cups-libs'
        ],
        'arch': [
            'sudo pacman -Sy --noconfirm nss nspr atk cups'
        ]
    }
    
    distro_id = distro['id'].lower()
    if distro_id in commands:
        for cmd in commands[distro_id]:
            print(f"Running: {cmd}")
            subprocess.run(cmd, shell=True)
    else:
        print(f"No automatic installation for {distro_id}")
```

## Docker Configuration

### Basic Dockerfile

```dockerfile
FROM python:3.12-slim

# Install Chrome dependencies
RUN apt-get update && apt-get install -y \
    wget \
    gnupg \
    # Chrome dependencies
    libnss3 \
    libnspr4 \
    libatk1.0-0 \
    libatk-bridge2.0-0 \
    libcups2 \
    libdrm2 \
    libxkbcommon0 \
    libxcomposite1 \
    libxdamage1 \
    libxrandr2 \
    libgbm1 \
    libpango-1.0-0 \
    libcairo2 \
    libasound2 \
    # Additional tools
    xvfb \
    x11vnc \
    fluxbox \
    && rm -rf /var/lib/apt/lists/*

# Install Chrome
RUN wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add - \
    && echo "deb http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google.list \
    && apt-get update \
    && apt-get install -y google-chrome-stable \
    && rm -rf /var/lib/apt/lists/*

# Install PlaywrightAuthor
RUN pip install playwrightauthor

# Create non-root user
RUN useradd -m -s /bin/bash automation
USER automation
WORKDIR /home/automation

# Copy your application
COPY --chown=automation:automation . .

# Run with virtual display
CMD ["xvfb-run", "-a", "--server-args=-screen 0 1280x720x24", "python", "app.py"]
```

### Docker Compose with VNC Access

```yaml
version: '3.8'

services:
  playwrightauthor:
    build: .
    environment:
      - DISPLAY=:99
      - PLAYWRIGHTAUTHOR_HEADLESS=false
    volumes:
      - ./data:/home/automation/data
      - /dev/shm:/dev/shm  # Shared memory for Chrome
    ports:
      - "5900:5900"  # VNC port
    command: |
      bash -c "
        Xvfb :99 -screen 0 1280x720x24 &
        fluxbox &
        x11vnc -display :99 -forever -usepw -create &
        python app.py
      "
    shm_size: '2gb'  # Increase shared memory
    
  # Optional: Selenium Grid compatibility
  selenium-hub:
    image: selenium/hub:latest
    ports:
      - "4444:4444"
```

### Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: playwrightauthor
spec:
  replicas: 3
  selector:
    matchLabels:
      app: playwrightauthor
  template:
    metadata:
      labels:
        app: playwrightauthor
    spec:
      containers:
      - name: automation
        image: your-registry/playwrightauthor:latest
        env:
        - name: PLAYWRIGHTAUTHOR_HEADLESS
          value: "true"
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1"
        volumeMounts:
        - name: dshm
          mountPath: /dev/shm
      volumes:
      - name: dshm
        emptyDir:
          medium: Memory
          sizeLimit: 1Gi
```

## Display Server Configuration

### X11 Setup

```python
import os
import subprocess

def setup_x11_display():
    """Setup X11 display for GUI mode."""
    # Check if display is set
    if 'DISPLAY' not in os.environ:
        # Try to detect running X server
        try:
            result = subprocess.run(['pgrep', 'Xorg'], capture_output=True)
            if result.returncode == 0:
                os.environ['DISPLAY'] = ':0'
            else:
                print("No X server detected, running headless")
                return False
        except:
            return False
    
    # Test X11 connection
    try:
        subprocess.run(['xset', 'q'], capture_output=True, check=True)
        return True
    except:
        print(f"Cannot connect to X11 display {os.environ.get('DISPLAY')}")
        return False

# Configure browser based on display availability
from playwrightauthor import Browser

has_display = setup_x11_display()
with Browser(headless=not has_display) as browser:
    # Browser runs in GUI mode if display available
    pass
```

### Wayland Support

```python
def setup_wayland():
    """Setup for Wayland display server."""
    # Check if running under Wayland
    if os.environ.get('WAYLAND_DISPLAY'):
        print("Wayland detected")
        
        # Use Xwayland if available
        if subprocess.run(['which', 'Xwayland'], capture_output=True).returncode == 0:
            os.environ['GDK_BACKEND'] = 'x11'
            return True
        else:
            # Native Wayland (experimental)
            os.environ['CHROMIUM_FLAGS'] = '--ozone-platform=wayland'
            return True
    
    return False

# Browser with Wayland support
wayland_args = []
if setup_wayland():
    wayland_args.extend([
        '--ozone-platform=wayland',
        '--enable-features=UseOzonePlatform'
    ])

with Browser(args=wayland_args) as browser:
    pass
```

### Virtual Display (Xvfb)

```python
import subprocess
import time
import atexit

class VirtualDisplay:
    """Manage Xvfb virtual display."""
    
    def __init__(self, width=1280, height=720, display_num=99):
        self.width = width
        self.height = height
        self.display_num = display_num
        self.xvfb_process = None
        
    def start(self):
        """Start Xvfb."""
        cmd = [
            'Xvfb',
            f':{self.display_num}',
            '-screen', '0',
            f'{self.width}x{self.height}x24',
            '-ac',  # Disable access control
            '+extension', 'GLX',
            '+render',
            '-noreset'
        ]
        
        self.xvfb_process = subprocess.Popen(cmd)
        time.sleep(1)  # Give Xvfb time to start
        
        # Set DISPLAY environment variable
        os.environ['DISPLAY'] = f':{self.display_num}'
        
        # Register cleanup
        atexit.register(self.stop)
        
    def stop(self):
        """Stop Xvfb."""
        if self.xvfb_process:
            self.xvfb_process.terminate()
            self.xvfb_process.wait()

# Use virtual display for headless operation
vdisplay = VirtualDisplay()
vdisplay.start()

with Browser() as browser:
    # Browser runs with virtual display
    page = browser.new_page()
    page.goto("https://example.com")
    page.screenshot(path="screenshot.png")
```

## Security Configuration

### SELinux Configuration

```bash
# Check SELinux status
sestatus

# Create custom policy for Chrome
cat > chrome_playwright.te << 'EOF'
module chrome_playwright 1.0;

require {
    type chrome_t;
    type user_home_t;
    type tmp_t;
    class file { read write create unlink };
    class dir { read write add_name remove_name };
}

# Allow Chrome to access user home
allow chrome_t user_home_t:dir { read write add_name remove_name };
allow chrome_t user_home_t:file { read write create unlink };

# Allow Chrome to use /tmp
allow chrome_t tmp_t:dir { read write add_name remove_name };
allow chrome_t tmp_t:file { read write create unlink };
EOF

# Compile and install policy
checkmodule -M -m -o chrome_playwright.mod chrome_playwright.te
semodule_package -o chrome_playwright.pp -m chrome_playwright.mod
sudo semodule -i chrome_playwright.pp
```

### AppArmor Configuration

```bash
# Create AppArmor profile for Chrome
sudo tee /etc/apparmor.d/usr.bin.google-chrome << 'EOF'
#include <tunables/global>

/usr/bin/google-chrome-stable {
  #include <abstractions/base>
  #include <abstractions/nameservice>
  #include <abstractions/user-tmp>
  
  # Chrome binary
  /usr/bin/google-chrome-stable mr,
  /opt/google/chrome/** mr,
  
  # User data
  owner @{HOME}/.local/share/playwrightauthor/** rw,
  owner @{HOME}/.config/google-chrome/** rw,
  
  # Shared memory
  /dev/shm/** rw,
  
  # System access
  /proc/*/stat r,
  /proc/*/status r,
  /sys/devices/system/cpu/** r,
}
EOF

# Load profile
sudo apparmor_parser -r /etc/apparmor.d/usr.bin.google-chrome
```

### Running as Non-Root

```python
import os
import pwd
import grp

def drop_privileges(uid_name='nobody', gid_name='nogroup'):
    """Drop root privileges."""
    if os.getuid() != 0:
        # Not running as root
        return
    
    # Get uid/gid from names
    running_uid = pwd.getpwnam(uid_name).pw_uid
    running_gid = grp.getgrnam(gid_name).gr_gid
    
    # Remove group privileges
    os.setgroups([])
    
    # Set new uid/gid
    os.setgid(running_gid)
    os.setuid(running_uid)
    
    # Verify
    print(f"Dropped privileges to {uid_name}:{gid_name}")

# Create non-privileged user for Chrome
def setup_chrome_user():
    """Create dedicated user for Chrome."""
    try:
        subprocess.run([
            'sudo', 'useradd',
            '-m',  # Create home directory
            '-s', '/bin/false',  # No shell
            '-c', 'PlaywrightAuthor Chrome User',
            'chrome-automation'
        ], check=True)
    except:
        pass  # User might already exist

# Run Chrome as non-root
if os.getuid() == 0:
    setup_chrome_user()
    drop_privileges('chrome-automation', 'chrome-automation')

with Browser() as browser:
    # Chrome runs as non-root user
    pass
```

## Performance Optimization

### Linux-Specific Chrome Flags

```python
LINUX_CHROME_FLAGS = [
    # Memory optimization
    '--memory-pressure-off',
    '--max_old_space_size=4096',
    '--disable-dev-shm-usage',  # Use /tmp instead of /dev/shm
    
    # GPU optimization
    '--disable-gpu-sandbox',
    '--disable-setuid-sandbox',
    '--no-sandbox',  # Required in Docker
    
    # Performance
    '--disable-web-security',
    '--disable-features=VizDisplayCompositor',
    '--disable-breakpad',
    '--disable-software-rasterizer',
    
    # Stability
    '--disable-features=RendererCodeIntegrity',
    '--disable-background-timer-throttling',
    
    # Linux specific
    '--no-zygote',  # Don't use zygote process
    '--single-process'  # Run in single process (containers)
]

# Additional flags for containers
if os.path.exists('/.dockerenv'):
    LINUX_CHROME_FLAGS.extend([
        '--disable-gpu',
        '--disable-features=dbus'
    ])

with Browser(args=LINUX_CHROME_FLAGS) as browser:
    # Optimized for Linux
    pass
```

### System Resource Management

```python
import resource

def set_resource_limits():
    """Set resource limits for Chrome processes."""
    # Limit memory usage to 2GB
    resource.setrlimit(resource.RLIMIT_AS, (2 * 1024 * 1024 * 1024, -1))
    
    # Limit number of open files
    resource.setrlimit(resource.RLIMIT_NOFILE, (4096, 4096))
    
    # Limit CPU time (optional)
    # resource.setrlimit(resource.RLIMIT_CPU, (300, 300))  # 5 minutes

# Apply limits before starting Chrome
set_resource_limits()

# Monitor resource usage
def get_chrome_resources():
    """Get Chrome resource usage."""
    import psutil
    
    total_cpu = 0
    total_memory = 0
    chrome_processes = []
    
    for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_info']):
        if 'chrome' in proc.info['name'].lower():
            chrome_processes.append({
                'pid': proc.info['pid'],
                'cpu': proc.info['cpu_percent'],
                'memory_mb': proc.info['memory_info'].rss / 1024 / 1024
            })
            total_cpu += proc.info['cpu_percent']
            total_memory += proc.info['memory_info'].rss
    
    return {
        'processes': chrome_processes,
        'total_cpu': total_cpu,
        'total_memory_mb': total_memory / 1024 / 1024
    }
```

## Troubleshooting

### Common Linux Issues

#### Issue 1: Missing Dependencies

```python
def check_chrome_dependencies():
    """Check for missing Chrome dependencies."""
    required_libs = [
        'libnss3.so',
        'libnspr4.so',
        'libatk-1.0.so.0',
        'libatk-bridge-2.0.so.0',
        'libcups.so.2',
        'libdrm.so.2',
        'libxkbcommon.so.0',
        'libxcomposite.so.1',
        'libxdamage.so.1',
        'libxrandr.so.2',
        'libgbm.so.1',
        'libpango-1.0.so.0',
        'libcairo.so.2',
        'libasound.so.2'
    ]
    
    missing = []
    for lib in required_libs:
        try:
            # Try to find library
            result = subprocess.run(
                ['ldconfig', '-p'], 
                capture_output=True, 
                text=True
            )
            if lib not in result.stdout:
                missing.append(lib)
        except:
            pass
    
    if missing:
        print("Missing libraries:")
        for lib in missing:
            print(f"  - {lib}")
        
        # Suggest installation commands
        distro = detect_distribution()
        if distro:
            if distro['id'] in ['ubuntu', 'debian']:
                print("\nInstall with:")
                print("sudo apt-get install libnss3 libnspr4 libatk1.0-0")
            elif distro['id'] in ['fedora', 'centos']:
                print("\nInstall with:")
                print("sudo dnf install nss nspr atk")
    else:
        print("All Chrome dependencies satisfied")

check_chrome_dependencies()
```

#### Issue 2: Chrome Crashes

```bash
# Enable core dumps for debugging
ulimit -c unlimited
echo '/tmp/core_%e_%p' | sudo tee /proc/sys/kernel/core_pattern

# Run Chrome with debugging
export CHROME_LOG_FILE=/tmp/chrome_debug.log
google-chrome --enable-logging --v=1 --dump-without-crashing
```

#### Issue 3: Permission Issues

```python
def fix_chrome_permissions():
    """Fix common permission issues."""
    import stat
    
    # Paths that need proper permissions
    paths_to_fix = [
        os.path.expanduser('~/.local/share/playwrightauthor'),
        '/tmp/playwrightauthor_cache',
        '/dev/shm'
    ]
    
    for path in paths_to_fix:
        if os.path.exists(path):
            try:
                # Ensure directory is writable
                os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IXOTH)
                print(f"Fixed permissions for {path}")
            except Exception as e:
                print(f"Could not fix {path}: {e}")

# Fix before running
fix_chrome_permissions()
```

### Systemd Service

```ini
# /etc/systemd/system/playwrightauthor.service
[Unit]
Description=PlaywrightAuthor Browser Service
After=network.target

[Service]
Type=simple
User=automation
Group=automation
WorkingDirectory=/opt/playwrightauthor
Environment="DISPLAY=:99"
Environment="PLAYWRIGHTAUTHOR_HEADLESS=true"
ExecStartPre=/usr/bin/Xvfb :99 -screen 0 1280x720x24 -ac +extension GLX +render -noreset &
ExecStart=/usr/bin/python3 /opt/playwrightauthor/app.py
Restart=always
RestartSec=10

# Security
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/playwrightauthor/data

[Install]
WantedBy=multi-user.target
```

## Distribution-Specific Tips

### Ubuntu/Debian
- Use `snap` for easy Chrome installation: `sudo snap install chromium`
- Enable proposed repository for latest packages
- Use `unattended-upgrades` for automatic security updates

### Fedora/RHEL
- SELinux is enabled by default - configure policies
- Use `dnf` module streams for different Chrome versions
- Enable RPM Fusion for additional codecs

### Arch Linux
- AUR has latest Chrome builds
- Use `makepkg` flags for optimization
- Enable multilib for 32-bit compatibility

### Alpine Linux
- Minimal footprint ideal for containers
- Use `apk` with `--no-cache` flag
- Add `ttf-freefont` for font support

## Additional Resources

- [Chrome on Linux](https://www.chromium.org/developers/how-tos/get-the-code/chromium-linux)
- [Linux Containers](https://linuxcontainers.org/)
- [X11 Documentation](https://www.x.org/releases/current/doc/)
- [Wayland Protocol](https://wayland.freedesktop.org/)
- [systemd Services](https://www.freedesktop.org/software/systemd/man/systemd.service.html)
</document_content>
</document>

<document index="35">
<source>docs/platforms/macos.md</source>
<document_content>
# macOS Platform Guide

This guide explains how to set up, configure, and troubleshoot PlaywrightAuthor on macOS.

## Quick Start

```bash
# Install PlaywrightAuthor
pip install playwrightauthor

# First run - grant permissions when prompted
python -c "from playwrightauthor import Browser; Browser().__enter__()"
```

## Architecture Differences

### Apple Silicon (M1/M2/M3) vs Intel

```mermaid
graph TD
    Start[PlaywrightAuthor Start] --> Detect{Detect Architecture}
    Detect -->|Apple Silicon| ARM[ARM64 Chrome]
    Detect -->|Intel| X86[x86_64 Chrome]
    
    ARM --> Universal[Universal Binary Check]
    X86 --> Native[Native Intel Binary]
    
    Universal --> Rosetta{Rosetta Available?}
    Rosetta -->|Yes| Run[Run Chrome]
    Rosetta -->|No| Install[Install Rosetta]
```

### Architecture Detection

```python
import platform
import subprocess

def get_mac_architecture():
    """Detect Mac architecture."""
    result = subprocess.run(['uname', '-m'], capture_output=True, text=True)
    arch = result.stdout.strip()
    
    return {
        'arm64': 'Apple Silicon',
        'x86_64': 'Intel'
    }.get(arch, 'Unknown')

print(f"Architecture: {get_mac_architecture()}")

# Architecture-specific Chrome paths
if get_mac_architecture() == 'Apple Silicon':
    chrome_paths = [
        "/Applications/Google Chrome.app",  # Universal binary
        "/Applications/Chrome for Testing.app",
        "/opt/homebrew/bin/chromium"  # Homebrew ARM64
    ]
else:
    chrome_paths = [
        "/Applications/Google Chrome.app",
        "/usr/local/bin/chromium"  # Homebrew Intel
    ]
```

## Security & Permissions

### Required Permissions

macOS requires specific permissions for browser automation:

1. **Accessibility Access**
   - System Preferences → Security & Privacy → Privacy → Accessibility
   - Add Terminal.app or your IDE (VS Code, PyCharm, etc.)

2. **Screen Recording** (for screenshots)
   - System Preferences → Security & Privacy → Privacy → Screen Recording
   - Add Terminal.app or your IDE

3. **Full Disk Access** (optional, for profile access)
   - System Preferences → Security & Privacy → Privacy → Full Disk Access
   - Add Terminal.app or your IDE

### Permission Management

```python
import subprocess
import os

def request_accessibility_permission():
    """Request accessibility permissions on macOS."""
    script = '''
    tell application "System Preferences"
        activate
        reveal anchor "Privacy_Accessibility" of pane "com.apple.preference.security"
    end tell
    '''
    
    subprocess.run(['osascript', '-e', script])
    print("Grant Accessibility access to Terminal/IDE")
    input("Press Enter after granting permission...")

def check_accessibility_permission():
    """Check if accessibility permission is granted."""
    try:
        script = 'tell application "System Events" to get name of first process'
        result = subprocess.run(['osascript', '-e', script], 
                              capture_output=True, text=True)
        return result.returncode == 0
    except:
        return False

if not check_accessibility_permission():
    request_accessibility_permission()
```

### Gatekeeper & Code Signing

macOS Gatekeeper may block unsigned Chrome binaries:

```bash
# Remove quarantine attribute from Chrome
sudo xattr -cr "/Applications/Google Chrome.app"

# Or for Chrome for Testing
sudo xattr -cr "/Applications/Chrome for Testing.app"

# Alternative: Allow in Security preferences
sudo spctl --add --label "Chrome" "/Applications/Google Chrome.app"
sudo spctl --enable --label "Chrome"
```

### Handling Gatekeeper in Python

```python
import subprocess
import os

def remove_quarantine(app_path: str):
    """Remove macOS quarantine attribute."""
    if os.path.exists(app_path):
        try:
            subprocess.run(['xattr', '-cr', app_path], 
                         capture_output=True, check=True)
            print(f"Removed quarantine from {app_path}")
        except subprocess.CalledProcessError:
            print(f"Need sudo to remove quarantine from {app_path}")
            subprocess.run(['sudo', 'xattr', '-cr', app_path])

# Apply to Chrome
remove_quarantine("/Applications/Google Chrome.app")
```

## Homebrew Integration

### Installing Chrome via Homebrew

```bash
# Intel Macs
brew install --cask google-chrome

# Apple Silicon Macs
arch -arm64 brew install --cask google-chrome

# Or use Chromium
brew install chromium
```

### Homebrew Chrome Detection

```python
def find_homebrew_chrome():
    """Find Chrome installed via Homebrew."""
    homebrew_paths = [
        # Apple Silicon
        "/opt/homebrew/Caskroom/google-chrome/latest/Google Chrome.app",
        "/opt/homebrew/bin/chromium",
        # Intel
        "/usr/local/Caskroom/google-chrome/latest/Google Chrome.app",
        "/usr/local/bin/chromium"
    ]
    
    for path in homebrew_paths:
        if os.path.exists(path):
            return path
    
    return None

# Use Homebrew Chrome if available
homebrew_chrome = find_homebrew_chrome()
if homebrew_chrome:
    os.environ['PLAYWRIGHTAUTHOR_CHROME_PATH'] = homebrew_chrome
```

## Display & Graphics

### Retina Display Support

```python
from playwrightauthor import Browser

# High-DPI screenshot support
with Browser(device_scale_factor=2) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    
    # Take high-resolution screenshot
    page.screenshot(path="retina-screenshot.png")
```

### Multiple Display Handling

```python
import subprocess
import json

def get_display_info():
    """Get macOS display configuration."""
    script = '''
    tell application "System Events"
        set displayList to {}
        repeat with i from 1 to count of desktops
            set end of displayList to {index:i, bounds:(bounds of desktop i)}
        end repeat
        return displayList
    end tell
    '''
    
    result = subprocess.run(['osascript', '-e', script], 
                          capture_output=True, text=True)
    return result.stdout

# Position browser on specific display
with Browser(
    args=[
        '--window-position=1920,0',  # Second monitor
        '--window-size=1280,720'
    ]
) as browser:
    # Browser opens on second display
    pass
```

## Performance Optimization

### macOS-Specific Chrome Flags

```python
# Optimal Chrome flags for macOS
MACOS_CHROME_FLAGS = [
    # Graphics optimization
    '--disable-gpu-sandbox',
    '--enable-accelerated-2d-canvas',
    '--enable-accelerated-video-decode',
    
    # Memory optimization
    '--max_old_space_size=4096',
    '--memory-pressure-off',
    
    # Stability
    '--disable-background-timer-throttling',
    '--disable-renderer-backgrounding',
    
    # macOS specific
    '--disable-features=RendererCodeIntegrity',
    '--disable-smooth-scrolling'  # Better performance
]

with Browser(args=MACOS_CHROME_FLAGS) as browser:
    # Optimized for macOS
    pass
```

### Activity Monitor Integration

```python
import psutil
import subprocess

def get_chrome_metrics():
    """Get Chrome process metrics on macOS."""
    metrics = {
        'processes': [],
        'total_memory_mb': 0,
        'total_cpu_percent': 0
    }
    
    for proc in psutil.process_iter(['pid', 'name', 'memory_info', 'cpu_percent']):
        if 'chrome' in proc.info['name'].lower():
            memory_mb = proc.info['memory_info'].rss / 1024 / 1024
            metrics['processes'].append({
                'pid': proc.info['pid'],
                'memory_mb': round(memory_mb, 2),
                'cpu_percent': proc.info['cpu_percent']
            })
            metrics['total_memory_mb'] += memory_mb
            metrics['total_cpu_percent'] += proc.info['cpu_percent']
    
    return metrics

# Monitor Chrome resource usage
print(json.dumps(get_chrome_metrics(), indent=2))
```

## Troubleshooting

### Common macOS Issues

#### Issue 1: "Chrome.app is damaged"

```bash
# Solution 1: Remove quarantine
sudo xattr -cr "/Applications/Google Chrome.app"

# Solution 2: Re-sign the app
sudo codesign --force --deep --sign - "/Applications/Google Chrome.app"

# Solution 3: Allow in Security preferences
sudo spctl --master-disable  # Temporarily disable Gatekeeper
# Install/run Chrome
sudo spctl --master-enable   # Re-enable Gatekeeper
```

#### Issue 2: Chrome Won't Launch

```python
def diagnose_chrome_launch():
    """Diagnose Chrome launch issues on macOS."""
    checks = []
    
    # Check if Chrome exists
    chrome_path = "/Applications/Google Chrome.app"
    checks.append({
        'check': 'Chrome installed',
        'passed': os.path.exists(chrome_path)
    })
    
    # Check quarantine
    try:
        result = subprocess.run(['xattr', '-l', chrome_path], 
                              capture_output=True, text=True)
        has_quarantine = 'com.apple.quarantine' in result.stdout
        checks.append({
            'check': 'No quarantine flag',
            'passed': not has_quarantine
        })
    except:
        pass
    
    # Check code signature
    try:
        result = subprocess.run(['codesign', '-v', chrome_path], 
                              capture_output=True, text=True)
        checks.append({
            'check': 'Valid code signature',
            'passed': result.returncode == 0
        })
    except:
        pass
    
    # Check accessibility permission
    checks.append({
        'check': 'Accessibility permission',
        'passed': check_accessibility_permission()
    })
    
    # Print results
    print("Chrome Launch Diagnostics:")
    for check in checks:
        status = "✓" if check['passed'] else "✗"
        print(f"{status} {check['check']}")
    
    return all(check['passed'] for check in checks)

# Run diagnostics
if not diagnose_chrome_launch():
    print("\nFix the issues above before proceeding")
```

#### Issue 3: Slow Performance

```python
# Clear Chrome cache and temporary files
def clear_chrome_cache():
    """Clear Chrome cache on macOS."""
    cache_paths = [
        "~/Library/Caches/Google/Chrome",
        "~/Library/Caches/com.google.Chrome",
        "~/Library/Application Support/Google/Chrome/Default/Cache"
    ]
    
    for path in cache_paths:
        expanded_path = os.path.expanduser(path)
        if os.path.exists(expanded_path):
            try:
                shutil.rmtree(expanded_path)
                print(f"Cleared {path}")
            except Exception as e:
                print(f"Could not clear {path}: {e}")
```

### System Integration

#### LaunchAgents for Background Operation

Create `~/Library/LaunchAgents/com.playwrightauthor.chrome.plist`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" 
  "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.playwrightauthor.chrome</string>
    <key>ProgramArguments</key>
    <array>
        <string>/Applications/Google Chrome.app/Contents/MacOS/Google Chrome</string>
        <string>--remote-debugging-port=9222</string>
        <string>--user-data-dir=/Users/YOUR_USERNAME/Library/Application Support/playwrightauthor/profiles/default</string>
        <string>--no-first-run</string>
        <string>--no-default-browser-check</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
</dict>
</plist>
```

Load with:
```bash
launchctl load ~/Library/LaunchAgents/com.playwrightauthor.chrome.plist
```

## Security Best Practices

1. **Use macOS Keychain for Credentials**
   ```python
   import subprocess
   
   def save_to_keychain(service: str, account: str, password: str):
       """Save credentials to macOS Keychain."""
       subprocess.run([
           'security', 'add-generic-password',
           '-s', service,
           '-a', account,
           '-w', password,
           '-U'  # Update if exists
       ])
   
   def get_from_keychain(service: str, account: str) -> str:
       """Retrieve password from macOS Keychain."""
       result = subprocess.run([
           'security', 'find-generic-password',
           '-s', service,
           '-a', account,
           '-w'
       ], capture_output=True, text=True)
       
       return result.stdout.strip() if result.returncode == 0 else None
   ```

2. **Sandboxing Chrome**
   ```python
   # Run Chrome with enhanced sandboxing
   with Browser(args=[
       '--enable-sandbox',
       '--disable-setuid-sandbox',  # Not needed on macOS
       '--enable-features=NetworkService,NetworkServiceInProcess'
   ]) as browser:
       pass
   ```

3. **Privacy Settings**
   - Disable location services for Chrome
   - Disable camera/microphone access unless needed
   - Use separate profiles for different security contexts

## Additional Resources

- [Apple Developer - Security](https://developer.apple.com/security/)
- [Chrome Enterprise on macOS](https://support.google.com/chrome/a/answer/7550274)
- [macOS Security Guide](https://support.apple.com/guide/security/welcome/web)
- [Homebrew Chrome Formula](https://formulae.brew.sh/cask/google-chrome)
</document_content>
</document>

<document index="36">
<source>docs/platforms/windows.md</source>
<document_content>
# Windows Platform Guide

This guide covers Windows-specific setup, configuration, and troubleshooting for PlaywrightAuthor.

## Quick Start

```powershell
# Install PlaywrightAuthor
pip install playwrightauthor

# First run - may prompt for UAC elevation
python -c "from playwrightauthor import Browser; Browser().__enter__()"
```

## Security & Permissions

### User Account Control (UAC)

PlaywrightAuthor may require elevated permissions for:
- Installing Chrome for Testing
- Accessing protected directories
- Modifying system settings

#### Running with Elevation

```python
import ctypes
import sys
import os

def is_admin():
    """Check if running with admin privileges."""
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

def run_as_admin():
    """Re-run the current script with admin privileges."""
    if is_admin():
        return True
    else:
        # Re-run the program with admin rights
        ctypes.windll.shell32.ShellExecuteW(
            None, 
            "runas", 
            sys.executable, 
            " ".join(sys.argv), 
            None, 
            1
        )
        return False

# Use in your script
if not is_admin():
    print("Requesting administrator privileges...")
    if run_as_admin():
        sys.exit(0)

# Your PlaywrightAuthor code here
from playwrightauthor import Browser
with Browser() as browser:
    # Elevated browser session
    pass
```

### Windows Defender & Antivirus

#### Adding Exclusions

```powershell
# PowerShell (Run as Administrator)

# Add PlaywrightAuthor data directory to exclusions
Add-MpPreference -ExclusionPath "$env:LOCALAPPDATA\playwrightauthor"

# Add Chrome for Testing to exclusions
Add-MpPreference -ExclusionPath "$env:LOCALAPPDATA\ms-playwright"

# Add Python scripts directory
Add-MpPreference -ExclusionPath "$env:USERPROFILE\AppData\Local\Programs\Python"

# Add specific process exclusions
Add-MpPreference -ExclusionProcess "chrome.exe"
Add-MpPreference -ExclusionProcess "python.exe"
```

#### Programmatic Exclusion Management

```python
import subprocess
import os

def add_defender_exclusion(path: str):
    """Add path to Windows Defender exclusions."""
    try:
        cmd = [
            'powershell', '-ExecutionPolicy', 'Bypass',
            '-Command', f'Add-MpPreference -ExclusionPath "{path}"'
        ]
        
        # Run with elevation
        result = subprocess.run(
            cmd, 
            capture_output=True, 
            text=True,
            shell=True
        )
        
        if result.returncode == 0:
            print(f"Added {path} to Windows Defender exclusions")
        else:
            print(f"Failed to add exclusion: {result.stderr}")
            
    except Exception as e:
        print(f"Error adding exclusion: {e}")

# Add PlaywrightAuthor directories
playwrightauthor_dir = os.path.join(os.environ['LOCALAPPDATA'], 'playwrightauthor')
add_defender_exclusion(playwrightauthor_dir)
```

### PowerShell Execution Policies

#### Setting Execution Policy

```powershell
# Check current policy
Get-ExecutionPolicy

# Set policy for current user (recommended)
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

# Or bypass for single session
powershell -ExecutionPolicy Bypass -File script.ps1
```

#### Python Integration

```python
import subprocess

def run_powershell_script(script: str, bypass_policy: bool = True):
    """Run PowerShell script with optional policy bypass."""
    cmd = ['powershell']
    
    if bypass_policy:
        cmd.extend(['-ExecutionPolicy', 'Bypass'])
    
    cmd.extend(['-Command', script])
    
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        shell=True
    )
    
    return result.stdout, result.stderr

# Example: Check Chrome installation
script = '''
    $chrome = Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | 
              Where-Object { $_.DisplayName -like "*Google Chrome*" }
    if ($chrome) {
        Write-Output "Chrome installed at: $($chrome.InstallLocation)"
    } else {
        Write-Output "Chrome not found in registry"
    }
'''

output, error = run_powershell_script(script)
print(output)
```

## Windows-Specific Paths

### Chrome Installation Locations

```python
import os
import winreg

def find_chrome_windows():
    """Find Chrome installation on Windows."""
    potential_paths = [
        # 64-bit Chrome on 64-bit Windows
        r"C:\Program Files\Google\Chrome\Application\chrome.exe",
        r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe",
        
        # User-specific installation
        os.path.expandvars(r"%LOCALAPPDATA%\Google\Chrome\Application\chrome.exe"),
        
        # Chrome for Testing
        os.path.expandvars(r"%LOCALAPPDATA%\ms-playwright\chromium-*\chrome-win\chrome.exe"),
        
        # Chocolatey installation
        r"C:\ProgramData\chocolatey\bin\chrome.exe",
        
        # Scoop installation  
        os.path.expandvars(r"%USERPROFILE%\scoop\apps\googlechrome\current\chrome.exe")
    ]
    
    # Check registry for Chrome location
    try:
        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 
                           r"SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe") as key:
            chrome_path = winreg.QueryValue(key, None)
            if os.path.exists(chrome_path):
                return chrome_path
    except:
        pass
    
    # Check standard paths
    for path in potential_paths:
        expanded = os.path.expandvars(path)
        if os.path.exists(expanded):
            return expanded
        
        # Handle wildcards
        if '*' in expanded:
            import glob
            matches = glob.glob(expanded)
            if matches:
                return matches[0]
    
    return None
```

### Profile Storage

```python
def get_windows_profile_paths():
    """Get Windows-specific profile paths."""
    return {
        'playwrightauthor_data': os.path.expandvars(r'%LOCALAPPDATA%\playwrightauthor'),
        'playwrightauthor_cache': os.path.expandvars(r'%LOCALAPPDATA%\playwrightauthor\Cache'),
        'chrome_user_data': os.path.expandvars(r'%LOCALAPPDATA%\Google\Chrome\User Data'),
        'temp_profiles': os.path.expandvars(r'%TEMP%\playwrightauthor_profiles')
    }

# Create profile directory with proper permissions
import win32security
import win32api

def create_secure_directory(path: str):
    """Create directory with restricted permissions."""
    os.makedirs(path, exist_ok=True)
    
    # Get current user SID
    username = win32api.GetUserName()
    domain = win32api.GetDomainName()
    
    # Set permissions to current user only
    sd = win32security.GetFileSecurity(path, win32security.DACL_SECURITY_INFORMATION)
    dacl = win32security.ACL()
    
    # Add permission for current user
    user_sid = win32security.LookupAccountName(domain, username)[0]
    dacl.AddAccessAllowedAce(
        win32security.ACL_REVISION,
        win32security.FILE_ALL_ACCESS,
        user_sid
    )
    
    sd.SetSecurityDescriptorDacl(1, dacl, 0)
    win32security.SetFileSecurity(path, win32security.DACL_SECURITY_INFORMATION, sd)
```

## Display & DPI Handling

### High DPI Support

```python
import ctypes

def enable_dpi_awareness():
    """Enable DPI awareness for high-resolution displays."""
    try:
        # Windows 10 version 1703+
        ctypes.windll.shcore.SetProcessDpiAwareness(2)  # PROCESS_PER_MONITOR_DPI_AWARE
    except:
        try:
            # Windows 8.1+
            ctypes.windll.shcore.SetProcessDpiAwareness(1)  # PROCESS_SYSTEM_DPI_AWARE
        except:
            # Windows Vista+
            ctypes.windll.user32.SetProcessDPIAware()

# Enable before creating browser
enable_dpi_awareness()

from playwrightauthor import Browser

# Get current DPI scale
def get_dpi_scale():
    """Get current DPI scaling factor."""
    hdc = ctypes.windll.user32.GetDC(0)
    dpi = ctypes.windll.gdi32.GetDeviceCaps(hdc, 88)  # LOGPIXELSX
    ctypes.windll.user32.ReleaseDC(0, hdc)
    return dpi / 96.0  # 96 is standard DPI

scale_factor = get_dpi_scale()

with Browser(device_scale_factor=scale_factor) as browser:
    # Browser with proper DPI scaling
    pass
```

### Multi-Monitor Setup

```python
import win32api
import win32con

def get_monitor_info():
    """Get information about all monitors."""
    monitors = []
    
    def monitor_enum_proc(hMonitor, hdcMonitor, lprcMonitor, dwData):
        info = win32api.GetMonitorInfo(hMonitor)
        monitors.append({
            'name': info['Device'],
            'work_area': info['Work'],
            'monitor_area': info['Monitor'],
            'is_primary': info['Flags'] & win32con.MONITORINFOF_PRIMARY
        })
        return True
    
    win32api.EnumDisplayMonitors(None, None, monitor_enum_proc, 0)
    return monitors

# Position browser on specific monitor
monitors = get_monitor_info()
if len(monitors) > 1:
    # Use second monitor
    second_monitor = monitors[1]
    x = second_monitor['work_area'][0]
    y = second_monitor['work_area'][1]
    
    with Browser(args=[f'--window-position={x},{y}']) as browser:
        # Browser opens on second monitor
        pass
```

## Performance Optimization

### Windows-Specific Chrome Flags

```python
WINDOWS_CHROME_FLAGS = [
    # GPU acceleration
    '--enable-gpu-rasterization',
    '--enable-features=VaapiVideoDecoder',
    '--ignore-gpu-blocklist',
    
    # Memory management
    '--max_old_space_size=4096',
    '--disable-background-timer-throttling',
    
    # Windows-specific
    '--disable-features=RendererCodeIntegrity',
    '--no-sandbox',  # May be needed on some Windows configs
    
    # Network
    '--disable-features=NetworkService',
    '--disable-web-security',  # For local file access
    
    # Performance
    '--disable-logging',
    '--disable-gpu-sandbox',
    '--disable-software-rasterizer'
]

with Browser(args=WINDOWS_CHROME_FLAGS) as browser:
    # Optimized for Windows
    pass
```

### Process Priority Management

```python
import psutil
import win32api
import win32process
import win32con

def set_chrome_priority(priority_class=win32process.NORMAL_PRIORITY_CLASS):
    """Set Chrome process priority."""
    for proc in psutil.process_iter(['pid', 'name']):
        if 'chrome' in proc.info['name'].lower():
            try:
                handle = win32api.OpenProcess(
                    win32con.PROCESS_ALL_ACCESS, 
                    True, 
                    proc.info['pid']
                )
                win32process.SetPriorityClass(handle, priority_class)
                win32api.CloseHandle(handle)
            except:
                pass

# Set Chrome to high priority
set_chrome_priority(win32process.HIGH_PRIORITY_CLASS)
```

## Troubleshooting

### Common Windows Issues

#### Issue 1: Chrome Won't Launch

```python
def diagnose_chrome_windows():
    """Diagnose Chrome issues on Windows."""
    import subprocess
    
    diagnostics = []
    
    # Check if Chrome is installed
    chrome_path = find_chrome_windows()
    diagnostics.append({
        'check': 'Chrome installed',
        'passed': chrome_path is not None,
        'details': chrome_path or 'Not found'
    })
    
    # Check Windows Defender
    try:
        result = subprocess.run(
            ['powershell', '-Command', 'Get-MpPreference | Select-Object ExclusionPath'],
            capture_output=True,
            text=True
        )
        has_exclusion = 'playwrightauthor' in result.stdout
        diagnostics.append({
            'check': 'Windows Defender exclusion',
            'passed': has_exclusion,
            'details': 'Excluded' if has_exclusion else 'Not excluded'
        })
    except:
        pass
    
    # Check if port 9222 is available
    import socket
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(('127.0.0.1', 9222))
        sock.close()
        port_available = result != 0
        diagnostics.append({
            'check': 'Debug port available',
            'passed': port_available,
            'details': 'Available' if port_available else 'In use'
        })
    except:
        pass
    
    # Check UAC level
    try:
        result = subprocess.run(
            ['reg', 'query', r'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System',
             '/v', 'ConsentPromptBehaviorAdmin'],
            capture_output=True,
            text=True
        )
        uac_level = 'Unknown'
        if '0x0' in result.stdout:
            uac_level = 'Never notify'
        elif '0x5' in result.stdout:
            uac_level = 'Always notify'
        
        diagnostics.append({
            'check': 'UAC level',
            'passed': True,
            'details': uac_level
        })
    except:
        pass
    
    # Print results
    print("Chrome Diagnostics for Windows:")
    print("-" * 50)
    for diag in diagnostics:
        status = "PASS" if diag['passed'] else "FAIL"
        print(f"{status} {diag['check']}: {diag['details']}")
    
    return all(d['passed'] for d in diagnostics)

# Run diagnostics
diagnose_chrome_windows()
```

#### Issue 2: Permission Denied Errors

```python
import tempfile
import shutil

def fix_permission_issues():
    """Fix common permission issues on Windows."""
    
    # Option 1: Use temp directory
    temp_profile = os.path.join(tempfile.gettempdir(), 'playwrightauthor_temp')
    os.makedirs(temp_profile, exist_ok=True)
    
    # Option 2: Take ownership of directory
    def take_ownership(path):
        """Take ownership of a directory."""
        try:
            subprocess.run([
                'takeown', '/f', path, '/r', '/d', 'y'
            ], capture_output=True)
            
            subprocess.run([
                'icacls', path, '/grant', f'{os.environ["USERNAME"]}:F', '/t'
            ], capture_output=True)
            
            print(f"Took ownership of {path}")
        except Exception as e:
            print(f"Failed to take ownership: {e}")
    
    # Apply to PlaywrightAuthor directory
    pa_dir = os.path.join(os.environ['LOCALAPPDATA'], 'playwrightauthor')
    if os.path.exists(pa_dir):
        take_ownership(pa_dir)
```

#### Issue 3: Corporate Proxy Issues

```python
def setup_corporate_proxy():
    """Configure Chrome for corporate proxy."""
    import urllib.request
    
    # Get system proxy
    proxy = urllib.request.getproxies()
    
    proxy_args = []
    if 'http' in proxy:
        proxy_args.append(f'--proxy-server={proxy["http"]}')
    
    # Bypass proxy for local addresses
    proxy_args.append('--proxy-bypass-list=localhost,127.0.0.1,*.local')
    
    # Use with Browser
    with Browser(args=proxy_args) as browser:
        # Browser with proxy configuration
        pass
```

### Windows Services Integration

#### Running as Windows Service

```python
import win32serviceutil
import win32service
import win32event
import servicemanager

class PlaywrightAuthorService(win32serviceutil.ServiceFramework):
    _svc_name_ = 'PlaywrightAuthorService'
    _svc_display_name_ = 'PlaywrightAuthor Browser Service'
    _svc_description_ = 'Manages Chrome browser for automation'
    
    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.browser = None
    
    def SvcStop(self):
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        win32event.SetEvent(self.hWaitStop)
        
    def SvcDoRun(self):
        servicemanager.LogMsg(
            servicemanager.EVENTLOG_INFORMATION_TYPE,
            servicemanager.PYS_SERVICE_STARTED,
            (self._svc_name_, '')
        )
        
        # Start browser
        from playwrightauthor import Browser
        self.browser = Browser().__enter__()
        
        # Wait for stop signal
        win32event.WaitForSingleObject(self.hWaitStop, win32event.INFINITE)
        
        # Cleanup
        if self.browser:
            self.browser.__exit__(None, None, None)

if __name__ == '__main__':
    win32serviceutil.HandleCommandLine(PlaywrightAuthorService)
```

## Security Best Practices

### Windows Credential Manager

```python
import win32cred

def save_credential(target: str, username: str, password: str):
    """Save credential to Windows Credential Manager."""
    credential = {
        'Type': win32cred.CRED_TYPE_GENERIC,
        'TargetName': target,
        'UserName': username,
        'CredentialBlob': password.encode('utf-16-le'),
        'Persist': win32cred.CRED_PERSIST_LOCAL_MACHINE,
        'Attributes': [],
        'Comment': 'Stored by PlaywrightAuthor'
    }
    
    win32cred.CredWrite(credential)
    print(f"Credential saved for {target}")

def get_credential(target: str):
    """Retrieve credential from Windows Credential Manager."""
    try:
        cred = win32cred.CredRead(target, win32cred.CRED_TYPE_GENERIC)
        username = cred['UserName']
        password = cred['CredentialBlob'].decode('utf-16-le')
        return username, password
    except:
        return None, None

# Example usage
save_credential('github.com', 'username', 'token')
username, password = get_credential('github.com')
```

### AppLocker Considerations

```powershell
# Check AppLocker policies
Get-AppLockerPolicy -Effective | Format-List

# Add Chrome to allowed applications
$rule = New-AppLockerPolicy -RuleType Exe -AllowRule -UserOrGroupSid S-1-1-0 `
    -Condition (New-AppLockerCondition -Path "%PROGRAMFILES%\Google\Chrome\Application\chrome.exe")
    
Set-AppLockerPolicy -PolicyObject $rule
```

## Additional Resources

- [Chrome Enterprise on Windows](https://support.google.com/chrome/a/answer/7587273)
- [Windows Security Baselines](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-security-baselines)
- [PowerShell Documentation](https://docs.microsoft.com/en-us/powershell/)
- [Windows Service Development](https://docs.microsoft.com/en-us/windows/win32/services/services)
</document_content>
</document>

<document index="37">
<source>examples/README.md</source>
<document_content>
# PlaywrightAuthor Examples

This directory contains example scripts demonstrating how to use PlaywrightAuthor for various automation tasks.

## Scraping Examples

### GitHub Notifications Scraper
**File:** `scrape_github_notifications.py`

Scrapes your GitHub notifications after a single login.

```bash
python examples/scrape_github_notifications.py
```

**Features:**
- Automatic session persistence (log in once, stay logged in)
- Extracts notification titles and repository names
- Handles logout states without crashing

### LinkedIn Feed Scraper
**File:** `scrape_linkedin_feed.py`

Scrapes posts from your LinkedIn feed, including infinite scroll support.

```bash
python examples/scrape_linkedin_feed.py
```

**Features:**
- Extracts post headlines, authors, and timestamps
- Loads additional posts via infinite scroll
- Prevents duplicate posts during scrolling
- Adjustable post count limit

## First Time Setup

1. Install PlaywrightAuthor:
   ```bash
   pip install playwrightauthor
   ```

2. Run any example:
   ```bash
   python examples/scrape_github_notifications.py
   ```

3. **First run:** A browser window opens. Log into the service manually.

4. **Future runs:** The script uses your saved session automatically.

## Tips

- Use `Browser(verbose=True)` to troubleshoot connection problems
- Sessions save locally and persist across executions
- Create separate profiles for different accounts: `Browser(profile="work")`
- Session storage location varies by platform (typically `~/.playwrightauthor/` on macOS/Linux)

## Test Examples

The `pytest/` directory contains examples of automated tests using PlaywrightAuthor with pytest.

## FastAPI Integration

The `fastapi/` directory shows how to build web scraping APIs with PlaywrightAuthor and FastAPI.
</document_content>
</document>

<document index="38">
<source>examples/fastapi/README.md</source>
<document_content>
# PlaywrightAuthor + FastAPI Integration

This example shows how to build a web scraping API using PlaywrightAuthor and FastAPI.

## Features

- **Async API Endpoints**: Non-blocking scraping operations
- **Browser Pool Management**: Reuse browser instances for efficiency
- **Error Handling**: Proper HTTP error responses
- **Rate Limiting**: Throttle requests per minute
- **Data Extraction**: Extract titles, links, text, or custom elements
- **Authentication Handling**: Scrape pages that require login
- **Caching**: Cache results to reduce redundant work

## Installation

```bash
pip install playwrightauthor fastapi uvicorn python-multipart
```

## Running the API

```bash
# Development
uvicorn main:app --reload --host 0.0.0.0 --port 8000

# Production
uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4
```

## API Endpoints

### Basic Scraping
- `GET /scrape?url={url}` - Scrape a single page
- `POST /scrape/batch` - Scrape multiple URLs
- `GET /scrape/screenshot?url={url}` - Take a screenshot

### Content Extraction
- `GET /extract/title?url={url}` - Get page title
- `GET /extract/links?url={url}` - Get all links
- `GET /extract/text?url={url}` - Get visible text
- `POST /extract/custom` - Extract using CSS selectors

### Advanced Features
- `GET /scrape/authenticated?url={url}&profile={profile}` - Scrape with login
- `GET /scrape/wait?url={url}&selector={selector}` - Wait for an element
- `GET /health` - Health check endpoint

## Example Usage

```bash
# Basic scraping
curl "http://localhost:8000/scrape?url=https://example.com"

# Extract title
curl "http://localhost:8000/extract/title?url=https://github.com"

# Custom extraction
curl -X POST "http://localhost:8000/extract/custom" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://github.com",
    "selectors": {
      "title": "h1",
      "description": "meta[name=description]"
    }
  }'

# Batch scraping
curl -X POST "http://localhost:8000/scrape/batch" \
  -H "Content-Type: application/json" \
  -d '{
    "urls": ["https://example.com", "https://github.com"],
    "extract": ["title", "url"]
  }'
```

## Configuration

Environment variables:
- `BROWSER_POOL_SIZE`: Number of browser instances (default: 3)
- `REQUEST_TIMEOUT`: Timeout in seconds (default: 30)
- `RATE_LIMIT_REQUESTS`: Requests per minute (default: 60)
- `CACHE_TTL`: Cache expiry in seconds (default: 300)
</document_content>
</document>

<document index="39">
<source>examples/pytest/README.md</source>
<document_content>
# PlaywrightAuthor + pytest Integration

This example shows how to integrate PlaywrightAuthor with pytest for browser automation testing.

## Features

- **Pytest Fixtures**: Reusable browser setup with proper teardown
- **Profile Management**: Testing with different user profiles
- **Error Handling**: Error handling and recovery
- **Parallel Testing**: Concurrent test execution with different profiles
- **Authentication Testing**: Login flows and authenticated scenarios
- **Performance Testing**: Basic performance assertions

## Installation

```bash
pip install playwrightauthor pytest pytest-asyncio pytest-xdist
```

## Running Tests

```bash
# Run all tests
pytest

# Run tests with verbose output
pytest -v

# Run tests in parallel (requires pytest-xdist)
pytest -n 4

# Run specific test categories
pytest -m "smoke"
pytest -m "auth"
pytest -m "performance"
```

## Test Structure

- `conftest.py` - Pytest fixtures and configuration
- `test_basic.py` - Basic browser automation tests
- `test_authentication.py` - Login and authentication testing
- `test_profiles.py` - Multi-profile testing scenarios
- `test_performance.py` - Performance and reliability tests
- `test_async.py` - Async browser testing patterns

## Best Practices

1. **Use Fixtures**: Use pytest fixtures for browser setup
2. **Profile Isolation**: Use different profiles for different test categories
3. **Error Recovery**: Implement error handling and cleanup
4. **Timeouts**: Set appropriate timeouts for network operations
5. **Parallel Safe**: Ensure tests can run in parallel without conflicts
</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/examples/pytest/conftest.py
# Language: python

import asyncio
from contextlib import contextmanager
import pytest
from playwrightauthor import AsyncBrowser, Browser
import time

def pytest_configure((config)):
    """Configure pytest markers for test categorization."""

def browser_config(()):
    """ Session-scoped browser configuration...."""

def browser((browser_config)):
    """ Function-scoped browser fixture for synchronous tests...."""

def async_browser((browser_config)):
    """ Function-scoped async browser fixture for asynchronous tests...."""

def profile_browser(()):
    """ Fixture factory for creating browsers with specific profiles...."""

def _create_profile_browser((profile_name: str, verbose: bool = True)):
    """Create a browser with the specified profile."""

def test_urls(()):
    """ Session-scoped fixture providing common test URLs...."""

def wait_for_element(()):
    """ Utility fixture for waiting for elements with timeout...."""

def _wait_for_element((page, selector: str, timeout: int = 30000)):
    """ Wait for element to be visible with timeout...."""

def event_loop(()):
    """ Session-scoped event loop for async tests...."""

def pytest_runtest_makereport((item, call)):
    """ Custom test report generation with browser context information...."""

def performance_timer(()):
    """ Fixture for measuring test execution time and browser operations...."""

def start_timer((name: str = "default")):
    """Start timing a specific operation."""

def end_timer((name: str = "default")) -> float:
    """End timing and return duration in seconds."""

def assert_duration_under((name: str, max_seconds: float)):
    """Assert that an operation completed within the specified time."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/examples/pytest/test_async.py
# Language: python

import asyncio
import pytest
from playwright.async_api import expect

def test_async_browser_initialization((async_browser)):
    """ Test that async browser initializes correctly and is ready for automation...."""

def test_async_navigation((async_browser, test_urls)):
    """ Test basic async page navigation and content verification...."""

def test_concurrent_page_operations((async_browser, test_urls)):
    """ Test concurrent operations on multiple pages simultaneously...."""

def test_async_form_interaction((async_browser, test_urls)):
    """ Test async form filling and submission patterns...."""

def test_async_javascript_execution((async_browser, test_urls)):
    """ Test async JavaScript execution and evaluation...."""

def test_async_performance_timing((async_browser, test_urls)):
    """ Test async performance measurement and timing analysis...."""

def test_async_element_waiting((async_browser, test_urls)):
    """ Test async element waiting and interaction patterns...."""

def test_async_screenshot_generation((async_browser, test_urls, tmp_path)):
    """ Test async screenshot generation and file operations...."""

def test_async_error_handling((async_browser)):
    """ Test async error handling patterns and exception management...."""

def test_async_concurrent_automation_workflow((async_browser, test_urls)):
    """ Test complex concurrent automation workflow...."""

def analyze_page((url, page_name)):
    """Analyze a single page and return metrics."""

def test_async_context_manager_cleanup((async_browser)):
    """ Test proper async context manager cleanup and resource management...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/examples/pytest/test_authentication.py
# Language: python

import pytest
from playwright.sync_api import expect
import time

def test_github_login_form_exists((browser, test_urls)):
    """ Test that GitHub login form is accessible and has expected elements...."""

def test_authentication_persistence_check((browser)):
    """ Test checking for existing authentication state...."""

def test_cookie_based_authentication_check((browser)):
    """ Test authentication state detection using cookies...."""

def test_manual_authentication_guidance((browser)):
    """ Test that provides guidance for manual authentication setup...."""

def test_authentication_required_endpoints((browser)):
    """ Test accessing endpoints that require authentication...."""

def test_logout_functionality((browser)):
    """ Test logout functionality and session cleanup...."""

def test_session_timeout_handling((browser)):
    """ Test handling of session timeouts and expired authentication...."""

def test_multi_factor_authentication_detection((browser)):
    """ Test detection of multi-factor authentication requirements...."""

def test_authentication_state_preservation((profile_browser)):
    """ Test that authentication state is preserved across browser sessions...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/examples/pytest/test_basic.py
# Language: python

import pytest
from playwright.sync_api import expect

def test_browser_initialization((browser)):
    """ Test that browser initializes correctly and is ready for automation...."""

def test_simple_navigation((browser, test_urls)):
    """ Test basic page navigation and title verification...."""

def test_github_homepage((browser, test_urls)):
    """ Test GitHub homepage navigation and basic elements...."""

def test_form_interaction((browser, test_urls)):
    """ Test form filling and submission using httpbin.org...."""

def test_javascript_execution((browser, test_urls)):
    """ Test JavaScript execution and evaluation in the browser...."""

def test_screenshot_capture((browser, test_urls, tmp_path)):
    """ Test screenshot capture functionality...."""

def test_wait_for_element((browser, wait_for_element, test_urls)):
    """ Test element waiting functionality using custom fixture...."""

def test_multiple_pages((browser, test_urls)):
    """ Test handling multiple browser pages simultaneously...."""

def test_error_handling((browser)):
    """ Test proper error handling for common failure scenarios...."""

def test_performance_timing((browser, test_urls, performance_timer)):
    """ Test page load performance and timing measurements...."""

def test_browser_context_isolation((browser)):
    """ Test that browser context provides proper isolation between tests...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/examples/scrape_github_notifications.py
# Language: python

from playwrightauthor import Browser

def scrape_github_notifications(()):
    """Scrape notification titles from GitHub."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/examples/scrape_linkedin_feed.py
# Language: python

import time
from playwrightauthor import Browser

def scrape_linkedin_feed((max_posts=10)):
    """Scrape recent posts from LinkedIn feed."""


<document index="40">
<source>publish.sh</source>
<document_content>
#!/usr/bin/env bash
llms . "*.txt"
uvx hatch clean
gitnextver .
uvx hatch build
uv publish

</document_content>
</document>

<document index="41">
<source>pyproject.toml</source>
<document_content>
[build-system]
requires = ["hatchling", "hatch-vcs"]
build-backend = "hatchling.build"

[project]
name = "playwrightauthor"
dynamic = ["version"]
authors = [
    { name = "Adam Twardoch", email = "adam+github@twardoch.com" },
]
description = "Your personal, authenticated browser for Playwright, ready in one line of code."
readme = "README.md"
requires-python = ">=3.12"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]
dependencies = [
    "playwright",
    "rich",
    "fire",
    "loguru",
    "platformdirs",
    "requests",
    "psutil",
    "prompt_toolkit>=3.0.0",
]

[project.urls]
"Homepage" = "https://github.com/twardoch/playwrightauthor"
"Bug Tracker" = "https://github.com/twardoch/playwrightauthor/issues"

[project.scripts]
playwrightauthor = "playwrightauthor.cli:main"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "guess-next-dev"
write_to = "src/playwrightauthor/_version.py"

[tool.hatch.build.targets.wheel]
packages = ["src/playwrightauthor"]

[tool.uv]
dev-dependencies = [
    "pytest",
    "ruff",
    "mypy",
]

[tool.ruff]
target-version = "py312"
line-length = 88
extend-exclude = ["_version.py"]

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "B",  # flake8-bugbear
    "C4", # flake8-comprehensions
    "UP", # pyupgrade
]
ignore = [
    "E501", # line too long, handled by formatter
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"

[tool.ruff.lint.isort]
known-first-party = ["playwrightauthor"]

</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/scripts/check_accessibility.py
# Language: python

import argparse
import json
import re
import sys
import time
from collections import defaultdict
from dataclasses import asdict, dataclass
from pathlib import Path

class AccessibilityIssue:
    """Represents a single accessibility issue found in documentation."""

class AccessibilitySummary:
    """Summary of accessibility check results."""

class DocumentationAccessibilityChecker:
    """Comprehensive accessibility checker for markdown documentation."""
    def __init__((self, docs_root: Path)):
    def find_markdown_files((self)) -> list[Path]:
        """Find all markdown files in the documentation directory."""
    def add_issue((
        self,
        file_path: Path,
        line_number: int,
        issue_type: str,
        severity: str,
        description: str,
        recommendation: str,
        element_content: str | None = None,
        wcag_guideline: str | None = None,
    )):
        """Add an accessibility issue to the results."""
    def check_heading_structure((self, file_path: Path, content: str)):
        """Check heading hierarchy and structure."""
    def check_image_alt_text((self, file_path: Path, content: str)):
        """Check image alt text quality."""
    def check_link_text_quality((self, file_path: Path, content: str)):
        """Check link text for accessibility issues."""
    def check_table_accessibility((self, file_path: Path, content: str)):
        """Check table structure for accessibility."""
    def check_language_clarity((self, file_path: Path, content: str)):
        """Check for language clarity issues."""
    def check_list_structure((self, file_path: Path, content: str)):
        """Check list structure and formatting."""
    def check_file_accessibility((self, file_path: Path)) -> list[AccessibilityIssue]:
        """Check all accessibility issues in a single file."""
    def check_all_files((self)) -> AccessibilitySummary:
        """Check accessibility for all documentation files."""
    def generate_report((
        self, summary: AccessibilitySummary, output_file: Path | None = None
    )) -> str:
        """Generate a detailed accessibility report."""

def __init__((self, docs_root: Path)):

def find_markdown_files((self)) -> list[Path]:
    """Find all markdown files in the documentation directory."""

def add_issue((
        self,
        file_path: Path,
        line_number: int,
        issue_type: str,
        severity: str,
        description: str,
        recommendation: str,
        element_content: str | None = None,
        wcag_guideline: str | None = None,
    )):
    """Add an accessibility issue to the results."""

def check_heading_structure((self, file_path: Path, content: str)):
    """Check heading hierarchy and structure."""

def check_image_alt_text((self, file_path: Path, content: str)):
    """Check image alt text quality."""

def check_link_text_quality((self, file_path: Path, content: str)):
    """Check link text for accessibility issues."""

def check_table_accessibility((self, file_path: Path, content: str)):
    """Check table structure for accessibility."""

def check_language_clarity((self, file_path: Path, content: str)):
    """Check for language clarity issues."""

def check_list_structure((self, file_path: Path, content: str)):
    """Check list structure and formatting."""

def check_file_accessibility((self, file_path: Path)) -> list[AccessibilityIssue]:
    """Check all accessibility issues in a single file."""

def check_all_files((self)) -> AccessibilitySummary:
    """Check accessibility for all documentation files."""

def generate_report((
        self, summary: AccessibilitySummary, output_file: Path | None = None
    )) -> str:
    """Generate a detailed accessibility report."""

def main(()):
    """Main entry point for the accessibility checker."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/scripts/check_links.py
# Language: python

import argparse
import json
import re
import sys
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import asdict, dataclass
from pathlib import Path
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

class LinkResult:
    """Result of checking a single link."""

class CheckSummary:
    """Summary of all link checking results."""

class DocumentationLinkChecker:
    """Comprehensive link checker for markdown documentation."""
    def __init__((self, docs_root: Path, timeout: int = 10, max_workers: int = 10)):
    def find_markdown_files((self)) -> list[Path]:
        """Find all markdown files in the documentation directory."""
    def extract_links_from_file((self, file_path: Path)) -> list[tuple[str, str, int]]:
        """Extract all links from a markdown file."""
    def is_internal_link((self, url: str)) -> bool:
        """Check if a URL is an internal link."""
    def resolve_internal_link((
        self, url: str, source_file: Path
    )) -> tuple[bool, str | None]:
        """Resolve and validate an internal link."""
    def check_section_exists((
        self, anchor: str, file_path: Path
    )) -> tuple[bool, str | None]:
        """Check if a section anchor exists in a markdown file."""
    def check_external_link((self, url: str)) -> LinkResult:
        """Check if an external URL is accessible."""
    def check_file_links((self, file_path: Path)) -> list[LinkResult]:
        """Check all links in a single file."""
    def check_all_links((self)) -> CheckSummary:
        """Check all links in all documentation files."""
    def generate_report((
        self, summary: CheckSummary, output_file: Path | None = None
    )) -> str:
        """Generate a detailed report of link checking results."""

def __init__((self, docs_root: Path, timeout: int = 10, max_workers: int = 10)):

def find_markdown_files((self)) -> list[Path]:
    """Find all markdown files in the documentation directory."""

def extract_links_from_file((self, file_path: Path)) -> list[tuple[str, str, int]]:
    """Extract all links from a markdown file."""

def is_internal_link((self, url: str)) -> bool:
    """Check if a URL is an internal link."""

def resolve_internal_link((
        self, url: str, source_file: Path
    )) -> tuple[bool, str | None]:
    """Resolve and validate an internal link."""

def check_section_exists((
        self, anchor: str, file_path: Path
    )) -> tuple[bool, str | None]:
    """Check if a section anchor exists in a markdown file."""

def check_external_link((self, url: str)) -> LinkResult:
    """Check if an external URL is accessible."""

def check_file_links((self, file_path: Path)) -> list[LinkResult]:
    """Check all links in a single file."""

def check_all_links((self)) -> CheckSummary:
    """Check all links in all documentation files."""

def generate_report((
        self, summary: CheckSummary, output_file: Path | None = None
    )) -> str:
    """Generate a detailed report of link checking results."""

def main(()):
    """Main entry point for the link checker."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/__init__.py
# Language: python

from .author import AsyncBrowser, Browser


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/__main__.py
# Language: python

from .cli import main


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/author.py
# Language: python

from datetime import datetime
from typing import TYPE_CHECKING
from .browser.process import get_chrome_process
from .browser_manager import ensure_browser
from .config import get_config
from .connection import async_connect_with_retry, connect_with_retry
from .lazy_imports import get_async_playwright, get_sync_playwright
from .monitoring import AsyncBrowserMonitor, BrowserMonitor
from .state_manager import get_state_manager
from .utils.logger import configure as configure_logger
from playwright.async_api import Browser as AsyncPlaywrightBrowser
from playwright.async_api import Playwright as AsyncPlaywright
from playwright.sync_api import Browser as PlaywrightBrowser
from playwright.sync_api import Playwright

class Browser:
    """ A sync context manager for an authenticated Playwright Browser...."""
    def __init__((self, verbose: bool = False, profile: str = "default")):
    def __enter__((self)) -> "PlaywrightBrowser":
        """ Enter the context manager and return an authenticated Playwright Browser instance...."""
    def __exit__((self, exc_type, exc_val, exc_tb)):
        """ Exit the context manager and clean up browser resources...."""
    def _get_timestamp((self)) -> str:
        """ Get current timestamp in ISO 8601 format...."""
    def _start_monitoring((self)) -> None:
        """Start browser health monitoring with crash detection."""
    def _handle_browser_crash((self)) -> None:
        """Handle browser crash with automatic restart if enabled."""

class AsyncBrowser:
    """ An async context manager for an authenticated Playwright Browser...."""
    def __init__((self, verbose: bool = False, profile: str = "default")):
    def __aenter__((self)) -> "AsyncPlaywrightBrowser":
        """ Enter the async context manager and return an authenticated Playwright Browser instance...."""
    def __aexit__((self, exc_type, exc_val, exc_tb)):
        """ Exit the async context manager and clean up browser resources...."""
    def _start_monitoring((self)) -> None:
        """Start browser health monitoring with crash detection."""
    def _handle_browser_crash((self)) -> None:
        """Handle browser crash with automatic restart if enabled."""

def __init__((self, verbose: bool = False, profile: str = "default")):

def __enter__((self)) -> "PlaywrightBrowser":
    """ Enter the context manager and return an authenticated Playwright Browser instance...."""

def get_page(()):
    """Get a page from the existing browser context to reuse sessions."""

def __exit__((self, exc_type, exc_val, exc_tb)):
    """ Exit the context manager and clean up browser resources...."""

def _get_timestamp((self)) -> str:
    """ Get current timestamp in ISO 8601 format...."""

def _start_monitoring((self)) -> None:
    """Start browser health monitoring with crash detection."""

def _handle_browser_crash((self)) -> None:
    """Handle browser crash with automatic restart if enabled."""

def __init__((self, verbose: bool = False, profile: str = "default")):

def __aenter__((self)) -> "AsyncPlaywrightBrowser":
    """ Enter the async context manager and return an authenticated Playwright Browser instance...."""

def __aexit__((self, exc_type, exc_val, exc_tb)):
    """ Exit the async context manager and clean up browser resources...."""

def _start_monitoring((self)) -> None:
    """Start browser health monitoring with crash detection."""

def _handle_browser_crash((self)) -> None:
    """Handle browser crash with automatic restart if enabled."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser/__init__.py
# Language: python

from .finder import find_chrome_executable, get_chrome_version
from .installer import install_from_lkgv
from .launcher import launch_chrome, launch_chrome_with_retry
from .process import get_chrome_process, kill_chrome_process, wait_for_process_start


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser/finder.py
# Language: python

import os
import platform
import subprocess
import sys
from collections.abc import Generator
from pathlib import Path
from ..utils.paths import install_dir
from ..state_manager import get_state_manager
from ..state_manager import get_state_manager

def _get_windows_chrome_paths(()) -> Generator[Path, None, None]:
    """Generate possible Chrome for Testing paths on Windows."""

def _get_linux_chrome_paths(()) -> Generator[Path, None, None]:
    """Generate possible Chrome for Testing paths on Linux."""

def _get_macos_chrome_paths(()) -> Generator[Path, None, None]:
    """Generate possible Chrome for Testing paths on macOS."""

def find_chrome_executable((logger=None, use_cache: bool = True)) -> Path | None:
    """ Find the Chrome for Testing executable on the system...."""

def get_chrome_version((chrome_path: Path, logger=None)) -> str | None:
    """ Get the version of Chrome at the given path...."""

def _cache_chrome_path((path: Path, logger=None)) -> None:
    """Cache the Chrome executable path for future use."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser/installer.py
# Language: python

import hashlib
import json
import os
import platform
import shutil
import stat
import time
from pathlib import Path
import requests
from ..exceptions import BrowserInstallationError, NetworkError
from ..utils.paths import install_dir

def _get_platform_key(()) -> str:
    """Determine the platform key for Chrome for Testing downloads."""

def _validate_lkgv_data((data: dict)) -> None:
    """Validate the structure of LKGV JSON data."""

def _fetch_lkgv_data((logger, timeout: int = 30)) -> dict:
    """ Fetch and validate LKGV data from Chrome for Testing API...."""

def _download_with_progress((
    url: str, dest_path: Path, logger, timeout: int = 300
)) -> None:
    """ Download a file with progress reporting and integrity checks...."""

def _extract_archive((archive_path: Path, extract_path: Path, logger)) -> None:
    """ Extract downloaded archive with error handling...."""

def _fix_executable_permissions((extract_path: Path, logger)) -> None:
    """ Fix executable permissions for Chrome for Testing on Unix-like systems...."""

def install_from_lkgv((logger, max_retries: int = 3, retry_delay: int = 5)) -> None:
    """ Download and extract Chrome for Testing from the LKGV JSON...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser/launcher.py
# Language: python

import subprocess
import time
from pathlib import Path
import psutil
from ..exceptions import BrowserLaunchError, TimeoutError
from .process import wait_for_process_start

def launch_chrome((
    browser_path: Path, data_dir: Path, port: int, logger, timeout: int = 30
)) -> psutil.Process:
    """ Launch Chrome for Testing executable as a detached process with verification...."""

def launch_chrome_with_retry((
    browser_path: Path,
    data_dir: Path,
    port: int,
    logger,
    max_retries: int = 3,
    retry_delay: int = 2,
)) -> psutil.Process:
    """ Launch Chrome for Testing with retry logic...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser/process.py
# Language: python

import time
import psutil
from ..exceptions import ProcessKillError, TimeoutError

def get_chrome_process((port: int | None = None)) -> psutil.Process | None:
    """Find a running Chrome for Testing process, optionally filtered by debug port."""

def kill_chrome_process((proc: psutil.Process, timeout: int = 10, logger=None)) -> None:
    """ Kill a Chrome process gracefully with fallback to force kill...."""

def wait_for_process_start((
    port: int, timeout: int = 30, check_interval: float = 0.5
)) -> psutil.Process:
    """ Wait for a Chrome for Testing process with debug port to start...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser_manager.py
# Language: python

import time
from rich.console import Console
from .browser.finder import find_chrome_executable
from .browser.installer import install_from_lkgv
from .browser.launcher import launch_chrome_with_retry
from .browser.process import get_chrome_process, kill_chrome_process
from .config import get_config
from .exceptions import (
    BrowserInstallationError,
    BrowserLaunchError,
    BrowserManagerError,
    NetworkError,
    ProcessKillError,
)
from .exceptions import TimeoutError as PATimeoutError
from .state_manager import get_state_manager
from .utils.logger import configure as configure_logger
from .utils.paths import install_dir, data_dir as get_data_dir

def launch_browser((
    verbose: bool = False, max_retries: int | None = None, profile: str = "default"
)) -> tuple[str, str]:
    """ Launch Chrome for Testing with remote debugging, or return existing instance info...."""

def ensure_browser((
    verbose: bool = False, max_retries: int | None = None, profile: str = "default"
)) -> tuple[str, str]:
    """ Ensures a Chrome for Testing instance is running with remote debugging...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/cli.py
# Language: python

import json
import shutil
import sys
from difflib import get_close_matches
import fire
from rich.console import Console
from rich.table import Table
from .browser.process import get_chrome_process
from .browser_manager import ensure_browser, launch_browser
from .config import get_config
from .connection import check_connection_health
from .exceptions import BrowserManagerError, CLIError
from .state_manager import get_state_manager
from .utils.logger import configure as configure_logger
from .utils.paths import install_dir
import importlib.metadata
import playwright
import platform
from .browser.finder import find_chrome_executable
from .lazy_imports import get_sync_playwright
import platform
import os
from .repl import ReplEngine
from .onboarding import get_setup_recommendations
import asyncio
from .browser_manager import ensure_browser
from .lazy_imports import get_async_playwright
from .onboarding import interactive_setup_wizard
from .config import get_config
import traceback
from .browser.process import get_chrome_process
import traceback

class Cli:
    """ Command-line interface for PlaywrightAuthor browser and profile management...."""
    def status((self, verbose: bool = False)):
        """ Check browser installation and connection status...."""
    def clear_cache((self)):
        """ Remove all browser installations, profiles, and cached data...."""
    def profile((
        self, action: str = "list", name: str = "default", format: str = "table"
    )):
        """ Manage browser profiles for session isolation and multi-account automation...."""
    def config((
        self,
        action: str = "show",
        key: str = "",
        value: str = "",
        format: str = "table",
    )):
        """ Manage configuration settings...."""
    def diagnose((self, verbose: bool = False, format: str = "table")):
        """ Run diagnostic checks and display system information...."""
    def version((self)):
        """Display version information."""
    def health((self, verbose: bool = False, format: str = "table")):
        """ Perform comprehensive health check of PlaywrightAuthor setup...."""
    def repl((self, verbose: bool = False)):
        """ Start interactive REPL mode for browser automation...."""
    def setup((self, verbose: bool = False)):
        """ Launch interactive setup wizard for first-time users...."""
    def browse((self, verbose: bool = False, profile: str = "default")):
        """ Launch Chrome for Testing in CDP mode and exit...."""

def status((self, verbose: bool = False)):
    """ Check browser installation and connection status...."""

def clear_cache((self)):
    """ Remove all browser installations, profiles, and cached data...."""

def profile((
        self, action: str = "list", name: str = "default", format: str = "table"
    )):
    """ Manage browser profiles for session isolation and multi-account automation...."""

def config((
        self,
        action: str = "show",
        key: str = "",
        value: str = "",
        format: str = "table",
    )):
    """ Manage configuration settings...."""

def diagnose((self, verbose: bool = False, format: str = "table")):
    """ Run diagnostic checks and display system information...."""

def version((self)):
    """Display version information."""

def health((self, verbose: bool = False, format: str = "table")):
    """ Perform comprehensive health check of PlaywrightAuthor setup...."""

def add_result((check_name: str, is_ok: bool, details: str, fix_cmd: str = None)):

def repl((self, verbose: bool = False)):
    """ Start interactive REPL mode for browser automation...."""

def setup((self, verbose: bool = False)):
    """ Launch interactive setup wizard for first-time users...."""

def run_wizard(()):

def browse((self, verbose: bool = False, profile: str = "default")):
    """ Launch Chrome for Testing in CDP mode and exit...."""

def main(()) -> None:
    """Main entry point with enhanced error handling for mistyped commands."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/config.py
# Language: python

import json
import os
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any
from loguru import logger
from .utils.paths import config_dir

class BrowserConfig:
    """ Configuration for browser behavior and Chrome debugging settings...."""

class NetworkConfig:
    """ Configuration for network operations and retry behavior...."""

class PathsConfig:
    """ Configuration for file system paths and directory locations...."""

class MonitoringConfig:
    """ Configuration for browser health monitoring and automatic recovery...."""

class LoggingConfig:
    """ Configuration for logging behavior and output formatting...."""

class PlaywrightAuthorConfig:
    """ Main configuration class for PlaywrightAuthor...."""

class ConfigManager:
    """Manages configuration loading and validation."""
    def __init__((self, config_path: Path | None = None)):
        """Initialize the configuration manager."""
    def _default_config_path((self)) -> Path:
        """Get the default configuration file path."""
    def load((self)) -> PlaywrightAuthorConfig:
        """Load configuration from all sources."""
    def save((self, config: PlaywrightAuthorConfig | None = None)) -> None:
        """Save configuration to file."""
    def _load_from_file((self, config: PlaywrightAuthorConfig)) -> None:
        """Load configuration from file."""
    def _load_from_env((self, config: PlaywrightAuthorConfig)) -> None:
        """Load configuration from environment variables."""
    def _validate((self, config: PlaywrightAuthorConfig)) -> None:
        """Validate configuration values."""
    def _to_dict((self, config: PlaywrightAuthorConfig)) -> dict[str, Any]:
        """Convert configuration to dictionary."""

def __init__((self, config_path: Path | None = None)):
    """Initialize the configuration manager."""

def _default_config_path((self)) -> Path:
    """Get the default configuration file path."""

def load((self)) -> PlaywrightAuthorConfig:
    """Load configuration from all sources."""

def save((self, config: PlaywrightAuthorConfig | None = None)) -> None:
    """Save configuration to file."""

def _load_from_file((self, config: PlaywrightAuthorConfig)) -> None:
    """Load configuration from file."""

def _load_from_env((self, config: PlaywrightAuthorConfig)) -> None:
    """Load configuration from environment variables."""

def _validate((self, config: PlaywrightAuthorConfig)) -> None:
    """Validate configuration values."""

def _to_dict((self, config: PlaywrightAuthorConfig)) -> dict[str, Any]:
    """Convert configuration to dictionary."""

def get_config((config_path: Path | None = None)) -> PlaywrightAuthorConfig:
    """Get the global configuration."""

def save_config((config: PlaywrightAuthorConfig)) -> None:
    """Save configuration to file."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/connection.py
# Language: python

import json
import time
from typing import Any
import requests
from loguru import logger
from .exceptions import ConnectionError as PAConnectionError
import asyncio

class ConnectionHealthChecker:
    """Checks and monitors Chrome DevTools Protocol connection health."""
    def __init__((self, debug_port: int)):
        """Initialize the connection health checker."""
    def is_cdp_available((self, timeout: float = 5.0)) -> bool:
        """Check if Chrome DevTools Protocol is available."""
    def get_browser_info((self, timeout: float = 5.0)) -> dict[str, Any] | None:
        """Get browser information via CDP."""
    def wait_for_cdp_available((
        self, timeout: float = 30.0, check_interval: float = 0.5
    )) -> bool:
        """Wait for CDP to become available."""
    def get_connection_diagnostics((self)) -> dict[str, Any]:
        """Get detailed connection diagnostics."""

def __init__((self, debug_port: int)):
    """Initialize the connection health checker."""

def is_cdp_available((self, timeout: float = 5.0)) -> bool:
    """Check if Chrome DevTools Protocol is available."""

def get_browser_info((self, timeout: float = 5.0)) -> dict[str, Any] | None:
    """Get browser information via CDP."""

def wait_for_cdp_available((
        self, timeout: float = 30.0, check_interval: float = 0.5
    )) -> bool:
    """Wait for CDP to become available."""

def get_connection_diagnostics((self)) -> dict[str, Any]:
    """Get detailed connection diagnostics."""

def check_connection_health((
    debug_port: int, timeout: float = 5.0
)) -> tuple[bool, dict[str, Any]]:
    """Quick connection health check with diagnostics."""

def connect_with_retry((
    playwright_browser,
    debug_port: int,
    max_retries: int = 3,
    retry_delay: float = 1.0,
    timeout: float = 10.0,
)):
    """Connect to browser with retry logic and health checks."""

def async_connect_with_retry((
    playwright_browser,
    debug_port: int,
    max_retries: int = 3,
    retry_delay: float = 1.0,
    timeout: float = 10.0,
)):
    """Async version of connect_with_retry."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/exceptions.py
# Language: python

class PlaywrightAuthorError(E, x, c, e, p, t, i, o, n):
    """ Base exception for all PlaywrightAuthor errors...."""
    def __init__((
        self,
        message: str,
        suggestion: str = None,
        command: str = None,
        did_you_mean: list[str] | None = None,
        help_link: str = None,
    )):
        """ Initialize the exception with helpful context...."""

class BrowserManagerError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """ Raised for errors related to browser management...."""

class BrowserInstallationError(B, r, o, w, s, e, r, M, a, n, a, g, e, r, E, r, r, o, r):
    """ Raised when Chrome for Testing installation fails...."""
    def __init__((
        self,
        message: str,
        suggestion: str = None,
        command: str = None,
        did_you_mean: list[str] | None = None,
    )):

class BrowserLaunchError(B, r, o, w, s, e, r, M, a, n, a, g, e, r, E, r, r, o, r):
    """ Raised when Chrome for Testing fails to launch...."""
    def __init__((
        self,
        message: str,
        suggestion: str = None,
        command: str = None,
        did_you_mean: list[str] | None = None,
    )):

class ProcessKillError(B, r, o, w, s, e, r, M, a, n, a, g, e, r, E, r, r, o, r):
    """ Raised when Chrome process termination fails...."""
    def __init__((self, message: str, suggestion: str = None, command: str = None)):

class NetworkError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """ Raised for network-related errors...."""
    def __init__((self, message: str, suggestion: str = None, command: str = None)):

class TimeoutError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """ Raised when operations exceed configured timeout...."""
    def __init__((self, message: str, suggestion: str = None, command: str = None)):

class ConfigurationError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """ Raised for configuration-related errors...."""
    def __init__((self, message: str, suggestion: str = None, command: str = None)):

class AuthenticationError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """ Raised for authentication-related errors...."""
    def __init__((self, message: str, suggestion: str = None, command: str = None)):

class ConnectionError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """ Raised when connection to Chrome fails...."""
    def __init__((
        self,
        message: str,
        suggestion: str = None,
        command: str = None,
        did_you_mean: list[str] | None = None,
    )):

class ProfileError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """ Raised for browser profile management errors...."""
    def __init__((
        self,
        message: str,
        profile_name: str = None,
        suggestion: str = None,
        command: str = None,
    )):

class CLIError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """ Raised for CLI-specific errors...."""
    def __init__((
        self,
        message: str,
        command_used: str = None,
        suggestion: str = None,
        command: str = None,
        did_you_mean: list[str] | None = None,
    )):

def __init__((
        self,
        message: str,
        suggestion: str = None,
        command: str = None,
        did_you_mean: list[str] | None = None,
        help_link: str = None,
    )):
    """ Initialize the exception with helpful context...."""

def __init__((
        self,
        message: str,
        suggestion: str = None,
        command: str = None,
        did_you_mean: list[str] | None = None,
    )):

def __init__((
        self,
        message: str,
        suggestion: str = None,
        command: str = None,
        did_you_mean: list[str] | None = None,
    )):

def __init__((self, message: str, suggestion: str = None, command: str = None)):

def __init__((self, message: str, suggestion: str = None, command: str = None)):

def __init__((self, message: str, suggestion: str = None, command: str = None)):

def __init__((self, message: str, suggestion: str = None, command: str = None)):

def __init__((self, message: str, suggestion: str = None, command: str = None)):

def __init__((
        self,
        message: str,
        suggestion: str = None,
        command: str = None,
        did_you_mean: list[str] | None = None,
    )):

def __init__((
        self,
        message: str,
        profile_name: str = None,
        suggestion: str = None,
        command: str = None,
    )):

def __init__((
        self,
        message: str,
        command_used: str = None,
        suggestion: str = None,
        command: str = None,
        did_you_mean: list[str] | None = None,
    )):


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/lazy_imports.py
# Language: python

import importlib
import sys
from typing import TYPE_CHECKING, Any
from loguru import logger
from playwright.sync_api import sync_playwright
from playwright.async_api import async_playwright
import psutil
import requests

class LazyModule:
    """A lazy module that imports on first attribute access."""
    def __init__((self, module_name: str)):
        """Initialize the lazy module."""
    def _load((self)) -> Any:
        """Load the module if not already loaded."""
    def __getattr__((self, name: str)) -> Any:
        """Get attribute from the loaded module."""
    def __dir__((self)) -> list[str]:
        """List attributes of the loaded module."""

class LazyPlaywright:
    """Lazy loader for Playwright with both sync and async APIs."""
    def __init__((self)):
        """Initialize the lazy Playwright loader."""
    def sync_playwright((self)):
        """Get the sync_playwright context manager."""
    def async_playwright((self)):
        """Get the async_playwright context manager."""

def __init__((self, module_name: str)):
    """Initialize the lazy module."""

def _load((self)) -> Any:
    """Load the module if not already loaded."""

def __getattr__((self, name: str)) -> Any:
    """Get attribute from the loaded module."""

def __dir__((self)) -> list[str]:
    """List attributes of the loaded module."""

def __init__((self)):
    """Initialize the lazy Playwright loader."""

def sync_api((self)):
    """Get the synchronous Playwright API."""

def async_api((self)):
    """Get the asynchronous Playwright API."""

def sync_playwright((self)):
    """Get the sync_playwright context manager."""

def async_playwright((self)):
    """Get the async_playwright context manager."""

def get_sync_playwright(()):
    """Get the sync_playwright context manager lazily."""

def get_async_playwright(()):
    """Get the async_playwright context manager lazily."""

def get_sync_api(()):
    """Get the synchronous Playwright API module lazily."""

def get_async_api(()):
    """Get the asynchronous Playwright API module lazily."""

def get_psutil(()):
    """Get psutil module lazily."""

def get_requests(()):
    """Get requests module lazily."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/monitoring.py
# Language: python

import asyncio
import threading
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from typing import Any
import psutil
from loguru import logger
from .connection import ConnectionHealthChecker

class BrowserMetrics:
    """Container for browser performance metrics."""
    def to_dict((self)) -> dict[str, Any]:
        """Convert metrics to dictionary for logging/reporting."""

class BrowserMonitor:
    """Monitors browser health and performance metrics."""
    def __init__((
        self,
        debug_port: int,
        check_interval: float = 30.0,
        on_crash: Callable[[], None] | None = None,
    )):
        """Initialize browser monitor."""
    def start_monitoring((self, browser_pid: int | None = None)) -> None:
        """Start monitoring browser health in background thread."""
    def stop_monitoring((self)) -> None:
        """Stop monitoring browser health."""
    def _monitor_loop((self)) -> None:
        """Main monitoring loop running in background thread."""
    def _perform_health_check((self)) -> None:
        """Perform a single health check."""
    def _is_process_alive((self, pid: int)) -> bool:
        """Check if process is still running."""
    def _collect_resource_metrics((self)) -> None:
        """Collect CPU and memory metrics for browser process."""
    def _handle_crash((self)) -> None:
        """Handle detected browser crash."""
    def get_metrics((self)) -> BrowserMetrics:
        """Get current browser metrics."""
    def force_health_check((self)) -> bool:
        """Force immediate health check and return status."""

class AsyncBrowserMonitor:
    """Async version of BrowserMonitor for AsyncBrowser."""
    def __init__((
        self,
        debug_port: int,
        check_interval: float = 30.0,
        on_crash: Callable[[], None] | None = None,
    )):
        """Initialize async browser monitor."""
    def start_monitoring((self, browser_pid: int | None = None)) -> None:
        """Start monitoring browser health in background task."""
    def stop_monitoring((self)) -> None:
        """Stop monitoring browser health."""
    def _monitor_loop((self)) -> None:
        """Main monitoring loop running in background task."""
    def _perform_health_check((self)) -> None:
        """Perform a single health check."""
    def _is_process_alive((self, pid: int)) -> bool:
        """Check if process is still running."""
    def _collect_resource_metrics((self)) -> None:
        """Collect CPU and memory metrics for browser process."""
    def _handle_crash((self)) -> None:
        """Handle detected browser crash."""
    def get_metrics((self)) -> BrowserMetrics:
        """Get current browser metrics."""
    def force_health_check((self)) -> bool:
        """Force immediate health check and return status."""

def to_dict((self)) -> dict[str, Any]:
    """Convert metrics to dictionary for logging/reporting."""

def __init__((
        self,
        debug_port: int,
        check_interval: float = 30.0,
        on_crash: Callable[[], None] | None = None,
    )):
    """Initialize browser monitor."""

def start_monitoring((self, browser_pid: int | None = None)) -> None:
    """Start monitoring browser health in background thread."""

def stop_monitoring((self)) -> None:
    """Stop monitoring browser health."""

def _monitor_loop((self)) -> None:
    """Main monitoring loop running in background thread."""

def _perform_health_check((self)) -> None:
    """Perform a single health check."""

def _is_process_alive((self, pid: int)) -> bool:
    """Check if process is still running."""

def _collect_resource_metrics((self)) -> None:
    """Collect CPU and memory metrics for browser process."""

def _handle_crash((self)) -> None:
    """Handle detected browser crash."""

def get_metrics((self)) -> BrowserMetrics:
    """Get current browser metrics."""

def force_health_check((self)) -> bool:
    """Force immediate health check and return status."""

def __init__((
        self,
        debug_port: int,
        check_interval: float = 30.0,
        on_crash: Callable[[], None] | None = None,
    )):
    """Initialize async browser monitor."""

def start_monitoring((self, browser_pid: int | None = None)) -> None:
    """Start monitoring browser health in background task."""

def stop_monitoring((self)) -> None:
    """Stop monitoring browser health."""

def _monitor_loop((self)) -> None:
    """Main monitoring loop running in background task."""

def _perform_health_check((self)) -> None:
    """Perform a single health check."""

def _is_process_alive((self, pid: int)) -> bool:
    """Check if process is still running."""

def _collect_resource_metrics((self)) -> None:
    """Collect CPU and memory metrics for browser process."""

def _collect_sync(()):

def _handle_crash((self)) -> None:
    """Handle detected browser crash."""

def get_metrics((self)) -> BrowserMetrics:
    """Get current browser metrics."""

def force_health_check((self)) -> bool:
    """Force immediate health check and return status."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/onboarding.py
# Language: python

import asyncio
import platform
from pathlib import Path
from playwright.async_api import Browser as AsyncBrowser
from playwright.async_api import Page
import os

def _detect_login_activity((page: Page, logger)) -> bool:
    """ Detect if the user has performed login activities...."""

def _wait_for_user_action((page: Page, logger, timeout: int = 300)) -> str:
    """ Wait for user to either navigate away or perform login activities...."""

def _detect_setup_issues((page: Page, logger)) -> list[dict[str, str]]:
    """ Auto-detect common authentication and setup issues...."""

def _provide_service_guidance((logger)) -> dict[str, str]:
    """ Provide specific guidance for common authentication services...."""

def _check_browser_permissions((logger)) -> list[dict[str, str]]:
    """ Check for browser permission issues that might affect automation...."""

def _generate_setup_report((page: Page, logger)) -> dict:
    """ Generate comprehensive setup report with issues and recommendations...."""

def show((browser: AsyncBrowser, logger, timeout: int = 300)) -> None:
    """ Shows the enhanced onboarding page with intelligent setup guidance...."""

def show_with_retry((
    browser: AsyncBrowser, logger, max_retries: int = 2, timeout: int = 300
)) -> None:
    """ Show onboarding with retry logic for error resilience...."""

def interactive_setup_wizard((browser: AsyncBrowser, logger)) -> bool:
    """ Interactive setup wizard for first-time users...."""

def get_setup_recommendations(()) -> list[str]:
    """ Get platform-specific setup recommendations for first-time users...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/repl/__init__.py
# Language: python

from .engine import ReplEngine


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/repl/completion.py
# Language: python

from prompt_toolkit.completion import Completer, Completion

class PlaywrightCompleter(C, o, m, p, l, e, t, e, r):
    """Advanced completer for PlaywrightAuthor REPL with contextual awareness."""
    def __init__((self)):
    def get_completions((self, document, complete_event)):
        """Generate completions based on current context."""

def __init__((self)):

def get_completions((self, document, complete_event)):
    """Generate completions based on current context."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/repl/engine.py
# Language: python

import ast
from typing import Any
from prompt_toolkit import PromptSession
from prompt_toolkit.history import FileHistory
from prompt_toolkit.lexers import PygmentsLexer
from prompt_toolkit.styles import Style
from pygments.lexers import PythonLexer
from rich.console import Console
from rich.pretty import Pretty
from rich.syntax import Syntax
from rich.traceback import Traceback
from ..author import AsyncBrowser, Browser
from ..utils.logger import configure as configure_logger
from ..utils.paths import config_dir
from .completion import PlaywrightCompleter
from ..cli import Cli

class ReplEngine:
    """Interactive REPL engine for PlaywrightAuthor."""
    def __init__((self, verbose: bool = False)):
    def print_banner((self)):
        """Print the REPL welcome banner."""
    def print_help((self)):
        """Print REPL-specific help."""
    def execute_cli_command((self, command: str)) -> None:
        """Execute a CLI command from within the REPL."""
    def execute_code((self, code: str)) -> Any:
        """Execute Python code and return the result."""
    def format_result((self, result: Any)) -> None:
        """Format and display the result."""
    def run((self)) -> None:
        """Run the interactive REPL loop."""

def __init__((self, verbose: bool = False)):

def print_banner((self)):
    """Print the REPL welcome banner."""

def print_help((self)):
    """Print REPL-specific help."""

def execute_cli_command((self, command: str)) -> None:
    """Execute a CLI command from within the REPL."""

def execute_code((self, code: str)) -> Any:
    """Execute Python code and return the result."""

def format_result((self, result: Any)) -> None:
    """Format and display the result."""

def run((self)) -> None:
    """Run the interactive REPL loop."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/state_manager.py
# Language: python

import json
from datetime import datetime
from pathlib import Path
from typing import Any, TypedDict
from loguru import logger
from .exceptions import BrowserManagerError
from .utils.paths import data_dir

class BrowserState(T, y, p, e, d, D, i, c, t, ,,  , t, o, t, a, l, =, F, a, l, s, e):
    """Type definition for browser state data."""

class StateManager:
    """Manages browser state persistence and migration."""
    def __init__((self, state_dir: Path | None = None)):
        """Initialize the state manager."""
    def _ensure_state_dir((self)) -> None:
        """Ensure the state directory exists."""
    def load_state((self)) -> BrowserState:
        """Load browser state from disk."""
    def save_state((self, state: BrowserState)) -> None:
        """Save browser state to disk."""
    def get_chrome_path((self)) -> Path | None:
        """Get the cached Chrome executable path."""
    def set_chrome_path((self, path: Path)) -> None:
        """Cache the Chrome executable path."""
    def get_profile((self, name: str = "default")) -> dict[str, Any]:
        """Get a browser profile by name."""
    def set_profile((self, name: str, profile_data: dict[str, Any])) -> None:
        """Save a browser profile."""
    def list_profiles((self)) -> list[str]:
        """List all available profile names."""
    def delete_profile((self, name: str)) -> None:
        """Delete a browser profile."""
    def clear_state((self)) -> None:
        """Clear all saved state."""
    def _default_state((self)) -> BrowserState:
        """Create a default browser state."""
    def _default_profile((self)) -> dict[str, Any]:
        """Create a default profile."""
    def _migrate_state((self, state: dict[str, Any])) -> BrowserState:
        """Migrate state to the current version."""

def __init__((self, state_dir: Path | None = None)):
    """Initialize the state manager."""

def _ensure_state_dir((self)) -> None:
    """Ensure the state directory exists."""

def load_state((self)) -> BrowserState:
    """Load browser state from disk."""

def save_state((self, state: BrowserState)) -> None:
    """Save browser state to disk."""

def get_chrome_path((self)) -> Path | None:
    """Get the cached Chrome executable path."""

def set_chrome_path((self, path: Path)) -> None:
    """Cache the Chrome executable path."""

def get_profile((self, name: str = "default")) -> dict[str, Any]:
    """Get a browser profile by name."""

def set_profile((self, name: str, profile_data: dict[str, Any])) -> None:
    """Save a browser profile."""

def list_profiles((self)) -> list[str]:
    """List all available profile names."""

def delete_profile((self, name: str)) -> None:
    """Delete a browser profile."""

def clear_state((self)) -> None:
    """Clear all saved state."""

def _default_state((self)) -> BrowserState:
    """Create a default browser state."""

def _default_profile((self)) -> dict[str, Any]:
    """Create a default profile."""

def _migrate_state((self, state: dict[str, Any])) -> BrowserState:
    """Migrate state to the current version."""

def get_state_manager((state_dir: Path | None = None)) -> StateManager:
    """Get the global StateManager instance."""


<document index="42">
<source>src/playwrightauthor/templates/onboarding.html</source>
<document_content>
<!-- this_file: src/playwrightauthor/templates/onboarding.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PlaywrightAuthor Onboarding</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 700px;
            margin: 40px auto;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 28px;
            color: #111;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 16px;
            color: #666;
            margin-bottom: 30px;
        }
        
        .step {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 4px solid #007aff;
        }
        
        .step-number {
            background: #007aff;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            margin-right: 12px;
        }
        
        .step-title {
            font-weight: 600;
            color: #111;
            margin-bottom: 8px;
        }
        
        .step-description {
            color: #555;
            margin-bottom: 0;
        }
        
        .tips {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .tips-title {
            font-weight: 600;
            color: #1565c0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .tips-title::before {
            content: "💡";
            margin-right: 8px;
        }
        
        .tip-list {
            margin: 0;
            padding-left: 20px;
        }
        
        .tip-list li {
            margin-bottom: 8px;
            color: #1565c0;
        }
        
        .status {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
        }
        
        .status-text {
            color: #856404;
            font-weight: 500;
            margin: 0;
        }
        
        strong {
            color: #007aff;
        }
        
        .keyboard-shortcut {
            background: #f1f3f4;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 14px;
        }
        
        @media (max-width: 600px) {
            body {
                margin: 20px auto;
                padding: 20px;
            }
            
            h1 {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🎭 PlaywrightAuthor Setup</h1>
        <p class="subtitle">Your personal, authenticated browser is almost ready!</p>
    </div>
    
    <div class="step">
        <div class="step-title">
            <span class="step-number">1</span>
            Open a new tab or navigate to a website
        </div>
        <p class="step-description">
            Use <span class="keyboard-shortcut">Ctrl+T</span> (or <span class="keyboard-shortcut">Cmd+T</span> on Mac) to open a new tab, 
            or type a URL in the address bar above.
        </p>
    </div>
    
    <div class="step">
        <div class="step-title">
            <span class="step-number">2</span>
            Log into any websites you need
        </div>
        <p class="step-description">
            Sign in to Google, GitHub, social media, or any other services you'll be automating. 
            Your login sessions will be preserved for future use.
        </p>
    </div>
    
    <div class="step">
        <div class="step-title">
            <span class="step-number">3</span>
            That's it!
        </div>
        <p class="step-description">
            Once you navigate away from this page or log into any service, 
            PlaywrightAuthor will automatically detect the activity and your browser will be ready to use.
        </p>
    </div>
    
    <div class="tips">
        <div class="tips-title">Pro Tips</div>
        <ul class="tip-list">
            <li>You can log into multiple services at once - open several tabs!</li>
            <li>Your browser data is stored locally and securely on your machine</li>
            <li>You won't need to do this setup again unless you clear your browser data</li>
            <li>Close this tab anytime if you don't need to log into anything right now</li>
        </ul>
    </div>
    
    <div class="status">
        <p class="status-text">
            ⏳ Waiting for you to navigate away from this page or complete a login...
        </p>
    </div>
    
    <script>
        // Add some interactivity to show the page is responsive
        document.addEventListener('DOMContentLoaded', function() {
            const status = document.querySelector('.status-text');
            let dots = 0;
            
            setInterval(function() {
                dots = (dots + 1) % 4;
                const dotString = '.'.repeat(dots);
                status.textContent = `⏳ Waiting for you to navigate away from this page or complete a login${dotString}`;
            }, 500);
        });
        
        // Detect when user starts typing in address bar or opens new tab
        window.addEventListener('beforeunload', function() {
            console.log('PlaywrightAuthor: User is navigating away from onboarding page');
        });
    </script>
</body>
</html>
</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/typing.py
# Language: python



# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/utils/logger.py
# Language: python

from loguru import logger

def configure((verbose: bool = False)):


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/utils/paths.py
# Language: python

from pathlib import Path
from platformdirs import user_cache_dir, user_config_dir, user_data_dir

def install_dir(()) -> Path:
    """Get the directory for browser installations."""

def data_dir(()) -> Path:
    """Get the directory for persistent data storage."""

def config_dir(()) -> Path:
    """Get the directory for configuration files."""


<document index="43">
<source>src_docs/md/advanced-features.md</source>
<document_content>
# Advanced Features

PlaywrightAuthor provides advanced features for complex automation scenarios, including async operations, performance monitoring, custom configurations, and browser management.

## Asynchronous Operations

### Basic Async Usage

```python
import asyncio
from playwrightauthor import AsyncBrowser

async def async_automation():
    async with AsyncBrowser() as browser:
        page = await browser.new_page()
        await page.goto("https://example.com")
        title = await page.title()
        print(f"Page title: {title}")

# Run async automation
asyncio.run(async_automation())
```

### Concurrent Page Operations

```python
import asyncio
from playwrightauthor import AsyncBrowser

async def process_page(browser, url: str):
    """Process a single page"""
    page = await browser.new_page()
    await page.goto(url)
    title = await page.title()
    await page.close()
    return {"url": url, "title": title}

async def concurrent_automation():
    """Process multiple pages concurrently"""
    urls = [
        "https://github.com",
        "https://stackoverflow.com",
        "https://python.org",
        "https://playwright.dev"
    ]
    
    async with AsyncBrowser() as browser:
        # Process all URLs concurrently
        tasks = [process_page(browser, url) for url in urls]
        results = await asyncio.gather(*tasks)
        
        for result in results:
            print(f"{result['url']}: {result['title']}")

asyncio.run(concurrent_automation())
```

### Async Context Managers

```python
from playwrightauthor import AsyncBrowser
from contextlib import asynccontextmanager

@asynccontextmanager
async def managed_page(browser):
    """Custom async context manager for pages"""
    page = await browser.new_page()
    try:
        yield page
    finally:
        await page.close()

async def advanced_async():
    async with AsyncBrowser() as browser:
        async with managed_page(browser) as page:
            await page.goto("https://example.com")
            # Page automatically closed when exiting context

asyncio.run(advanced_async())
```

## Performance Monitoring

### Built-in Monitoring

```python
from playwrightauthor import Browser
from playwrightauthor.monitoring import PerformanceMonitor

with Browser() as browser:
    monitor = PerformanceMonitor(browser)
    
    # Start monitoring
    monitor.start()
    
    page = browser.new_page()
    page.goto("https://example.com")
    
    # Get performance metrics
    metrics = monitor.get_metrics()
    print(f"Page load time: {metrics['navigation_time']}ms")
    print(f"Memory usage: {metrics['memory_usage']}MB")
    print(f"CPU usage: {metrics['cpu_usage']}%")
    
    monitor.stop()
```

### Custom Performance Tracking

```python
from playwrightauthor import Browser
import time
from typing import Dict, Any

class CustomPerformanceTracker:
    def __init__(self):
        self.metrics: Dict[str, Any] = {}
        self.start_time = None
    
    def start_tracking(self):
        """Start performance tracking"""
        self.start_time = time.time()
        self.metrics = {
            "operations": [],
            "errors": [],
            "timings": {}
        }
    
    def track_operation(self, name: str, duration: float):
        """Track individual operation"""
        self.metrics["operations"].append({
            "name": name,
            "duration": duration,
            "timestamp": time.time()
        })
    
    def track_error(self, error: Exception, context: str):
        """Track errors with context"""
        self.metrics["errors"].append({
            "error": str(error),
            "context": context,
            "timestamp": time.time()
        })
    
    def get_summary(self) -> Dict[str, Any]:
        """Get performance summary"""
        total_time = time.time() - self.start_time
        operations = self.metrics["operations"]
        
        return {
            "total_time": total_time,
            "operation_count": len(operations),
            "error_count": len(self.metrics["errors"]),
            "avg_operation_time": sum(op["duration"] for op in operations) / len(operations) if operations else 0,
            "slowest_operation": max(operations, key=lambda x: x["duration"]) if operations else None
        }

# Usage
tracker = CustomPerformanceTracker()
tracker.start_tracking()

with Browser() as browser:
    page = browser.new_page()
    
    # Track page navigation
    start = time.time()
    page.goto("https://example.com")
    tracker.track_operation("navigation", time.time() - start)
    
    # Track form interaction
    start = time.time()
    try:
        page.fill("#search", "playwright")
        page.click("#submit")
        tracker.track_operation("form_submit", time.time() - start)
    except Exception as e:
        tracker.track_error(e, "form_interaction")

summary = tracker.get_summary()
print(f"Performance Summary: {summary}")
```

## Advanced Browser Configuration

### Custom Browser Factory

```python
from playwrightauthor import BrowserConfig
from playwrightauthor.browser_manager import BrowserManager
from typing import Optional

class AdvancedBrowserFactory:
    """Factory for creating specialized browser configurations"""
    
    @staticmethod
    def create_headless_config() -> BrowserConfig:
        """Optimized headless configuration"""
        return BrowserConfig(
            headless=True,
            chrome_args=[
                "--no-sandbox",
                "--disable-dev-shm-usage",
                "--disable-gpu",
                "--disable-extensions",
                "--disable-plugins",
                "--disable-images",  # Faster loading
                "--disable-javascript",  # If JS not needed
            ]
        )
    
    @staticmethod
    def create_mobile_config(device: str = "iPhone 12") -> BrowserConfig:
        """Mobile device emulation configuration"""
        mobile_args = [
            "--user-agent=Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X)",
            "--window-size=390,844",
            "--device-scale-factor=3"
        ]
        
        return BrowserConfig(
            headless=False,
            chrome_args=mobile_args,
            viewport={"width": 390, "height": 844}
        )
    
    @staticmethod
    def create_debug_config() -> BrowserConfig:
        """Development and debugging configuration"""
        return BrowserConfig(
            headless=False,
            timeout=60000,
            chrome_args=[
                "--auto-open-devtools-for-tabs",
                "--disable-web-security",
                "--allow-running-insecure-content",
                "--remote-debugging-port=9223"  # Different port for debugging
            ]
        )
    
    @staticmethod
    def create_stealth_config() -> BrowserConfig:
        """Stealth configuration to avoid detection"""
        return BrowserConfig(
            headless=True,
            chrome_args=[
                "--disable-blink-features=AutomationControlled",
                "--exclude-switches=enable-automation",
                "--disable-extensions-except=",
                "--disable-plugins-discovery",
                "--no-first-run",
                "--no-service-autorun",
                "--password-store=basic",
                "--use-mock-keychain"
            ]
        )

# Usage
from playwrightauthor import Browser

# Use mobile configuration
mobile_config = AdvancedBrowserFactory.create_mobile_config()
with Browser(config=mobile_config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")

# Use stealth configuration
stealth_config = AdvancedBrowserFactory.create_stealth_config()
with Browser(config=stealth_config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

### Dynamic Configuration

```python
import os
from playwrightauthor import BrowserConfig

class DynamicConfig:
    """Dynamic configuration based on environment and runtime conditions"""
    
    def __init__(self):
        self.base_config = BrowserConfig()
    
    def get_config(self) -> BrowserConfig:
        """Get configuration based on current environment"""
        config = self.base_config
        
        # CI/CD environment
        if os.getenv("CI"):
            config = self._apply_ci_settings(config)
        
        # Docker environment
        if os.path.exists("/.dockerenv"):
            config = self._apply_docker_settings(config)
        
        # Development environment
        if os.getenv("NODE_ENV") == "development":
            config = self._apply_dev_settings(config)
        
        # Production environment
        if os.getenv("NODE_ENV") == "production":
            config = self._apply_prod_settings(config)
        
        return config
    
    def _apply_ci_settings(self, config: BrowserConfig) -> BrowserConfig:
        """Apply CI-specific settings"""
        config.headless = True
        config.timeout = 15000  # Faster timeouts in CI
        config.chrome_args.extend([
            "--no-sandbox",
            "--disable-dev-shm-usage",
            "--disable-gpu"
        ])
        return config
    
    def _apply_docker_settings(self, config: BrowserConfig) -> BrowserConfig:
        """Apply Docker-specific settings"""
        config.chrome_args.extend([
            "--no-sandbox",
            "--disable-dev-shm-usage",
            "--disable-setuid-sandbox"
        ])
        return config
    
    def _apply_dev_settings(self, config: BrowserConfig) -> BrowserConfig:
        """Apply development settings"""
        config.headless = False
        config.timeout = 60000  # Longer timeouts for debugging
        config.chrome_args.append("--auto-open-devtools-for-tabs")
        return config
    
    def _apply_prod_settings(self, config: BrowserConfig) -> BrowserConfig:
        """Apply production settings"""
        config.headless = True
        config.timeout = 30000
        config.chrome_args.extend([
            "--disable-logging",
            "--silent",
            "--no-default-browser-check"
        ])
        return config

# Usage
dynamic_config = DynamicConfig()
config = dynamic_config.get_config()

with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

## Custom Extension System

### Plugin Architecture

```python
from abc import ABC, abstractmethod
from playwrightauthor import Browser
from typing import Any, Dict

class BrowserPlugin(ABC):
    """Base class for browser plugins"""
    
    def __init__(self, browser: Browser):
        self.browser = browser
    
    @abstractmethod
    def setup(self) -> None:
        """Setup plugin"""
        pass
    
    @abstractmethod
    def teardown(self) -> None:
        """Cleanup plugin"""
        pass

class ScreenshotPlugin(BrowserPlugin):
    """Plugin for automatic screenshot capture"""
    
    def __init__(self, browser: Browser, output_dir: str = "screenshots"):
        super().__init__(browser)
        self.output_dir = Path(output_dir)
        self.screenshot_count = 0
    
    def setup(self):
        """Setup screenshot directory"""
        self.output_dir.mkdir(exist_ok=True)
    
    def capture_screenshot(self, name: str = None) -> str:
        """Capture screenshot with auto-naming"""
        if not name:
            name = f"screenshot_{self.screenshot_count:04d}"
        
        screenshot_path = self.output_dir / f"{name}.png"
        
        # Get active page
        pages = self.browser.contexts[0].pages
        if pages:
            pages[0].screenshot(path=str(screenshot_path))
            self.screenshot_count += 1
            return str(screenshot_path)
        
        return None
    
    def teardown(self):
        """Cleanup if needed"""
        pass

class NetworkMonitorPlugin(BrowserPlugin):
    """Plugin for network request monitoring"""
    
    def __init__(self, browser: Browser):
        super().__init__(browser)
        self.requests = []
        self.responses = []
    
    def setup(self):
        """Setup network monitoring"""
        def handle_request(request):
            self.requests.append({
                "url": request.url,
                "method": request.method,
                "headers": request.headers,
                "timestamp": time.time()
            })
        
        def handle_response(response):
            self.responses.append({
                "url": response.url,
                "status": response.status,
                "headers": response.headers,
                "timestamp": time.time()
            })
        
        # Attach listeners to all contexts
        for context in self.browser.contexts:
            context.on("request", handle_request)
            context.on("response", handle_response)
    
    def get_network_summary(self) -> Dict[str, Any]:
        """Get network activity summary"""
        return {
            "total_requests": len(self.requests),
            "total_responses": len(self.responses),
            "failed_requests": len([r for r in self.responses if r["status"] >= 400]),
            "domains": list(set(urllib.parse.urlparse(r["url"]).netloc for r in self.requests))
        }
    
    def teardown(self):
        """Cleanup listeners"""
        pass

# Plugin Manager
class PluginManager:
    def __init__(self, browser: Browser):
        self.browser = browser
        self.plugins: Dict[str, BrowserPlugin] = {}
    
    def register_plugin(self, name: str, plugin: BrowserPlugin):
        """Register a plugin"""
        self.plugins[name] = plugin
        plugin.setup()
    
    def get_plugin(self, name: str) -> BrowserPlugin:
        """Get plugin by name"""
        return self.plugins.get(name)
    
    def teardown_all(self):
        """Teardown all plugins"""
        for plugin in self.plugins.values():
            plugin.teardown()

# Usage
with Browser() as browser:
    plugin_manager = PluginManager(browser)
    
    # Register plugins
    plugin_manager.register_plugin("screenshots", ScreenshotPlugin(browser))
    plugin_manager.register_plugin("network", NetworkMonitorPlugin(browser))
    
    # Use browser with plugins
    page = browser.new_page()
    page.goto("https://example.com")
    
    # Use screenshot plugin
    screenshot_plugin = plugin_manager.get_plugin("screenshots")
    screenshot_plugin.capture_screenshot("homepage")
    
    # Use network plugin
    network_plugin = plugin_manager.get_plugin("network")
    summary = network_plugin.get_network_summary()
    print(f"Network summary: {summary}")
    
    # Cleanup
    plugin_manager.teardown_all()
```

## Advanced Error Handling and Recovery

### Robust Error Recovery

```python
from playwrightauthor import Browser
from playwrightauthor.exceptions import BrowserError, ConnectionError
import time
from typing import Callable, Any

class RobustAutomation:
    """Automation class with advanced error handling and recovery"""
    
    def __init__(self, max_retries: int = 3, retry_delay: float = 2.0):
        self.max_retries = max_retries
        self.retry_delay = retry_delay
    
    def with_retry(self, func: Callable, *args, **kwargs) -> Any:
        """Execute function with retry logic"""
        last_exception = None
        
        for attempt in range(self.max_retries + 1):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                
                if attempt < self.max_retries:
                    print(f"Attempt {attempt + 1} failed: {e}")
                    print(f"Retrying in {self.retry_delay} seconds...")
                    time.sleep(self.retry_delay)
                    self.retry_delay *= 1.5  # Exponential backoff
                else:
                    print(f"All {self.max_retries + 1} attempts failed")
                    raise last_exception
    
    def safe_goto(self, page, url: str, timeout: int = 30000):
        """Navigate with error recovery"""
        def _goto():
            page.goto(url, timeout=timeout, wait_until="networkidle")
            return page.url
        
        return self.with_retry(_goto)
    
    def safe_click(self, page, selector: str, timeout: int = 10000):
        """Click with error recovery"""
        def _click():
            page.wait_for_selector(selector, timeout=timeout)
            page.click(selector)
            return True
        
        return self.with_retry(_click)
    
    def safe_fill(self, page, selector: str, text: str, timeout: int = 10000):
        """Fill form field with error recovery"""
        def _fill():
            page.wait_for_selector(selector, timeout=timeout)
            page.fill(selector, text)
            return True
        
        return self.with_retry(_fill)

# Usage
robust = RobustAutomation(max_retries=3)

with Browser() as browser:
    page = browser.new_page()
    
    # Robust navigation
    robust.safe_goto(page, "https://example.com")
    
    # Robust interactions
    robust.safe_click(page, "#submit-button")
    robust.safe_fill(page, "#search-input", "playwright automation")
```

### Circuit Breaker Pattern

```python
import time
from enum import Enum
from typing import Callable, Any

class CircuitState(Enum):
    CLOSED = "closed"      # Normal operation
    OPEN = "open"          # Failing, don't attempt
    HALF_OPEN = "half_open"  # Testing if recovered

class CircuitBreaker:
    """Circuit breaker for browser operations"""
    
    def __init__(self, failure_threshold: int = 5, timeout: float = 60.0):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = CircuitState.CLOSED
    
    def call(self, func: Callable, *args, **kwargs) -> Any:
        """Execute function through circuit breaker"""
        if self.state == CircuitState.OPEN:
            if self._should_attempt_reset():
                self.state = CircuitState.HALF_OPEN
            else:
                raise Exception("Circuit breaker is OPEN")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e
    
    def _should_attempt_reset(self) -> bool:
        """Check if enough time has passed to attempt reset"""
        return (time.time() - self.last_failure_time) >= self.timeout
    
    def _on_success(self):
        """Handle successful operation"""
        self.failure_count = 0
        self.state = CircuitState.CLOSED
    
    def _on_failure(self):
        """Handle failed operation"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.OPEN

# Usage
circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=30.0)

def risky_browser_operation():
    """Some operation that might fail"""
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://unreliable-site.com")
        return page.title()

try:
    result = circuit_breaker.call(risky_browser_operation)
    print(f"Result: {result}")
except Exception as e:
    print(f"Operation failed: {e}")
```

## Advanced Scraping Patterns

### Pagination Handler

```python
from playwrightauthor import Browser
from typing import Generator, Dict, Any

class PaginationScraper:
    """Advanced pagination handling"""
    
    def __init__(self, browser: Browser):
        self.browser = browser
    
    def scrape_paginated_data(
        self,
        start_url: str,
        data_selector: str,
        next_button_selector: str,
        max_pages: int = None
    ) -> Generator[Dict[str, Any], None, None]:
        """Scrape data from paginated results"""
        page = self.browser.new_page()
        page.goto(start_url)
        
        page_count = 0
        
        while True:
            # Scrape current page
            elements = page.query_selector_all(data_selector)
            
            for element in elements:
                yield self._extract_data(element)
            
            page_count += 1
            
            # Check if we've reached max pages
            if max_pages and page_count >= max_pages:
                break
            
            # Try to navigate to next page
            next_button = page.query_selector(next_button_selector)
            if not next_button or not next_button.is_enabled():
                break
            
            # Click next button and wait for navigation
            next_button.click()
            page.wait_for_load_state("networkidle")
        
        page.close()
    
    def _extract_data(self, element) -> Dict[str, Any]:
        """Extract data from a single element"""
        return {
            "text": element.text_content(),
            "html": element.inner_html(),
            "attributes": element.evaluate("el => Object.fromEntries(Array.from(el.attributes).map(attr => [attr.name, attr.value]))")
        }

# Usage
with Browser() as browser:
    scraper = PaginationScraper(browser)
    
    for item in scraper.scrape_paginated_data(
        start_url="https://example.com/search?q=playwright",
        data_selector=".search-result",
        next_button_selector=".next-page",
        max_pages=5
    ):
        print(f"Item: {item}")
```

### Infinite Scroll Handler

```python
class InfiniteScrollScraper:
    """Handle infinite scroll pages"""
    
    def __init__(self, browser: Browser):
        self.browser = browser
    
    def scrape_infinite_scroll(
        self,
        url: str,
        item_selector: str,
        scroll_pause_time: float = 2.0,
        max_scrolls: int = None
    ) -> Generator[Dict[str, Any], None, None]:
        """Scrape data from infinite scroll page"""
        page = self.browser.new_page()
        page.goto(url)
        
        last_height = 0
        scroll_count = 0
        
        while True:
            # Get current items
            items = page.query_selector_all(item_selector)
            
            # Yield new items
            for item in items:
                yield self._extract_data(item)
            
            # Scroll to bottom
            page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
            
            # Wait for new content to load
            time.sleep(scroll_pause_time)
            
            # Check if new content loaded
            new_height = page.evaluate("document.body.scrollHeight")
            
            if new_height == last_height:
                # No new content, we've reached the end
                break
            
            last_height = new_height
            scroll_count += 1
            
            # Check max scrolls limit
            if max_scrolls and scroll_count >= max_scrolls:
                break
        
        page.close()

# Usage
with Browser() as browser:
    scraper = InfiniteScrollScraper(browser)
    
    for item in scraper.scrape_infinite_scroll(
        url="https://example.com/infinite-feed",
        item_selector=".feed-item",
        max_scrolls=10
    ):
        print(f"Feed item: {item}")
```

## Next Steps

- Check [Troubleshooting](troubleshooting.md) for advanced debugging techniques
- Review [API Reference](api-reference.md) for detailed method documentation
- Learn about [Contributing](contributing.md) to extend PlaywrightAuthor
- Explore real-world examples in the project repository
</document_content>
</document>

<document index="44">
<source>src_docs/md/api-reference.md</source>
<document_content>
# API Reference

Documentation for PlaywrightAuthor classes, methods, and configuration options.

## Core Classes

### Browser

Synchronous browser context manager.

```python
class Browser:
    """Synchronous browser context manager for PlaywrightAuthor."""
    
    def __init__(self, config: BrowserConfig = None, **kwargs):
        """
        Initialize Browser instance.
        
        Args:
            config: Browser configuration object
            **kwargs: Configuration overrides (headless, timeout, etc.)
        """
    
    def __enter__(self) -> playwright.sync_api.Browser:
        """Enter context manager and return Playwright Browser object."""
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Exit context manager and cleanup resources."""
```

**Example Usage**:
```python
from playwrightauthor import Browser, BrowserConfig

# Basic usage
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")

# With configuration
config = BrowserConfig(headless=False, timeout=60000)
with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")

# With keyword arguments
with Browser(headless=True, debug_port=9223) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

### AsyncBrowser

Asynchronous browser context manager.

```python
class AsyncBrowser:
    """Asynchronous browser context manager for PlaywrightAuthor."""
    
    def __init__(self, config: BrowserConfig = None, **kwargs):
        """
        Initialize AsyncBrowser instance.
        
        Args:
            config: Browser configuration object
            **kwargs: Configuration overrides
        """
    
    async def __aenter__(self) -> playwright.async_api.Browser:
        """Enter async context manager and return Playwright Browser object."""
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Exit async context manager and cleanup resources."""
```

**Example Usage**:
```python
import asyncio
from playwrightauthor import AsyncBrowser

async def main():
    async with AsyncBrowser() as browser:
        page = await browser.new_page()
        await page.goto("https://example.com")
        title = await page.title()
        print(title)

asyncio.run(main())
```

## Configuration

### BrowserConfig

Main configuration class for browser settings.

```python
class BrowserConfig:
    """Configuration class for browser settings."""
    
    def __init__(
        self,
        # Display settings
        headless: bool = True,
        viewport: dict = None,
        
        # Timing settings
        timeout: int = 30000,
        navigation_timeout: int = 30000,
        
        # Chrome settings
        chrome_path: str = None,
        chrome_args: list[str] = None,
        user_data_dir: str = None,
        debug_port: int = 9222,
        
        # Connection settings
        connect_timeout: int = 10000,
        connect_retries: int = 3,
        
        # Feature flags
        ignore_https_errors: bool = False,
        bypass_csp: bool = False,
        
        # Logging
        log_level: str = "INFO",
        log_file: str = None,
        verbose: bool = False,
        
        # Advanced settings
        download_timeout: int = 300,
        install_dir: str = None,
        auto_restart: bool = True,
        health_check_interval: int = 60
    ):
        """
        Initialize browser configuration.
        
        Args:
            headless: Run browser in headless mode
            viewport: Default viewport size {"width": int, "height": int}
            timeout: Default timeout for operations in milliseconds
            navigation_timeout: Timeout for page navigation in milliseconds
            chrome_path: Path to Chrome executable (auto-detected if None)
            chrome_args: Additional Chrome command line arguments
            user_data_dir: Chrome user data directory path
            debug_port: Chrome remote debugging port
            connect_timeout: Timeout for connecting to Chrome in milliseconds
            connect_retries: Number of connection retry attempts
            ignore_https_errors: Ignore SSL certificate errors
            bypass_csp: Bypass Content Security Policy
            log_level: Logging level (DEBUG, INFO, WARNING, ERROR)
            log_file: Path to log file (stdout if None)
            verbose: Enable verbose logging
            download_timeout: Timeout for Chrome downloads in seconds
            install_dir: Directory for Chrome installation
            auto_restart: Automatically restart Chrome if it crashes
            health_check_interval: Health check interval in seconds
        """
```

**Properties**:
```python
@property
def chrome_executable(self) -> str:
    """Get the Chrome executable path."""

@property
def profile_directory(self) -> str:
    """Get the user profile directory path."""

@property
def cache_directory(self) -> str:
    """Get the cache directory path."""

def to_dict(self) -> dict:
    """Convert configuration to dictionary."""

def update(self, **kwargs) -> 'BrowserConfig':
    """Update configuration with new values."""

def validate(self) -> bool:
    """Validate configuration settings."""
```

**Example Usage**:
```python
from playwrightauthor import BrowserConfig

# Basic configuration
config = BrowserConfig(
    headless=False,
    timeout=60000,
    viewport={"width": 1920, "height": 1080}
)

# Mobile device emulation
mobile_config = BrowserConfig(
    headless=False,
    viewport={"width": 390, "height": 844},
    chrome_args=[
        "--user-agent=Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X)"
    ]
)

# Development configuration
dev_config = BrowserConfig(
    headless=False,
    timeout=120000,
    log_level="DEBUG",
    chrome_args=["--auto-open-devtools-for-tabs"]
)

# Production configuration
prod_config = BrowserConfig(
    headless=True,
    timeout=30000,
    chrome_args=[
        "--no-sandbox",
        "--disable-dev-shm-usage",
        "--disable-gpu"
    ]
)
```

## Browser Management

### BrowserManager

Core browser management functionality.

```python
class BrowserManager:
    """Manages Chrome browser lifecycle and connections."""
    
    def __init__(self, config: BrowserConfig):
        """Initialize browser manager with configuration."""
    
    def ensure_browser_available(self) -> str:
        """Ensure Chrome is available and return executable path."""
    
    def launch_browser(self) -> subprocess.Popen:
        """Launch Chrome with debugging enabled."""
    
    def connect_to_browser(self) -> playwright.sync_api.Browser:
        """Connect to Chrome via Playwright."""
    
    def cleanup(self):
        """Cleanup browser resources."""
    
    def is_browser_running(self) -> bool:
        """Check if browser is currently running."""
    
    def restart_browser(self):
        """Restart the browser process."""
```

### ChromeFinder

Chrome installation discovery.

```python
class ChromeFinder:
    """Finds Chrome installations across platforms."""
    
    @staticmethod
    def find_chrome() -> str:
        """Find Chrome executable path."""
    
    @staticmethod
    def get_chrome_locations() -> list[str]:
        """Get list of possible Chrome locations for current platform."""
    
    @staticmethod
    def is_chrome_executable(path: str) -> bool:
        """Check if path is a valid Chrome executable."""
    
    @staticmethod
    def get_chrome_version(path: str) -> str:
        """Get Chrome version from executable."""
```

**Platform-specific locations**:
```python
# Windows locations
WINDOWS_CHROME_PATHS = [
    r"C:\Program Files\Google\Chrome\Application\chrome.exe",
    r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe",
    r"%LOCALAPPDATA%\Google\Chrome\Application\chrome.exe",
    # ... more paths
]

# macOS locations  
MACOS_CHROME_PATHS = [
    "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
    "/Applications/Chromium.app/Contents/MacOS/Chromium",
    "~/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
    # ... more paths
]

# Linux locations
LINUX_CHROME_PATHS = [
    "/usr/bin/google-chrome",
    "/usr/bin/google-chrome-stable", 
    "/usr/bin/chromium",
    "/usr/bin/chromium-browser",
    # ... more paths
]
```

### ChromeInstaller

Chrome for Testing download and installation.

```python
class ChromeInstaller:
    """Downloads and installs Chrome for Testing."""
    
    def __init__(self, install_dir: str = None):
        """Initialize installer with optional install directory."""
    
    def install_latest(self, progress_callback: callable = None) -> str:
        """Download and install latest Chrome for Testing."""
    
    def install_version(self, version: str, progress_callback: callable = None) -> str:
        """Download and install specific Chrome version."""
    
    def get_available_versions(self) -> list[str]:
        """Get list of available Chrome for Testing versions."""
    
    def get_installed_versions(self) -> list[str]:
        """Get list of locally installed Chrome versions."""
    
    def uninstall_version(self, version: str):
        """Remove installed Chrome version."""
    
    def cleanup_old_versions(self, keep_count: int = 3):
        """Remove old Chrome installations, keeping specified count."""
```

**Example Usage**:
```python
from playwrightauthor.browser.installer import ChromeInstaller

installer = ChromeInstaller()

# Install latest Chrome
def progress(downloaded: int, total: int):
    percent = (downloaded / total) * 100
    print(f"Download progress: {percent:.1f}%")

chrome_path = installer.install_latest(progress_callback=progress)
print(f"Chrome installed to: {chrome_path}")

# Install specific version
chrome_path = installer.install_version("119.0.6045.105")

# List available versions
versions = installer.get_available_versions()
print(f"Available versions: {versions[:10]}")  # Show first 10

# Cleanup old installations
installer.cleanup_old_versions(keep_count=2)
```

## Process Management

### ChromeProcessManager

Chrome process lifecycle management.

```python
class ChromeProcessManager:
    """Manages Chrome process lifecycle."""
    
    def __init__(self):
        """Initialize process manager."""
    
    def get_chrome_processes(self) -> list[psutil.Process]:
        """Get list of running Chrome processes."""
    
    def is_chrome_debug_running(self, port: int = 9222) -> bool:
        """Check if Chrome is running with debugging enabled on port."""
    
    def kill_chrome_instances(self, graceful: bool = True):
        """Kill Chrome instances."""
    
    def launch_chrome(
        self, 
        executable_path: str,
        debug_port: int = 9222,
        user_data_dir: str = None,
        args: list[str] = None
    ) -> subprocess.Popen:
        """Launch Chrome with specified parameters."""
    
    def wait_for_chrome_ready(self, port: int = 9222, timeout: int = 30):
        """Wait for Chrome debug server to be ready."""
    
    def is_port_available(self, port: int) -> bool:
        """Check if port is available for use."""
    
    def find_available_port(self, start_port: int = 9222) -> int:
        """Find next available port starting from start_port."""
```

**Example Usage**:
```python
from playwrightauthor.browser.process import ChromeProcessManager

manager = ChromeProcessManager()

# Check running Chrome processes
processes = manager.get_chrome_processes()
for proc in processes:
    print(f"Chrome PID: {proc.pid}")

# Check if debug Chrome is running
if manager.is_chrome_debug_running():
    print("Chrome debug server is running")
else:
    print("No Chrome debug server found")

# Launch Chrome
proc = manager.launch_chrome(
    executable_path="/path/to/chrome",
    debug_port=9222,
    user_data_dir="/path/to/profile"
)

# Wait for Chrome to be ready
manager.wait_for_chrome_ready(port=9222, timeout=30)
```

## Authentication

### Authentication Base Classes

```python
class BaseAuth:
    """Base class for authentication handlers."""
    
    def __init__(self, browser: Browser):
        """Initialize with browser instance."""
    
    def is_authenticated(self) -> bool:
        """Check if user is authenticated."""
        raise NotImplementedError
    
    def authenticate(self) -> bool:
        """Perform authentication workflow."""
        raise NotImplementedError
    
    def logout(self) -> bool:
        """Perform logout workflow."""
        raise NotImplementedError
```

### Site-Specific Authentication

```python
class GitHubAuth(BaseAuth):
    """GitHub authentication handler."""
    
    def is_authenticated(self) -> bool:
        """Check GitHub authentication status."""
    
    def authenticate(self) -> bool:
        """Guide through GitHub authentication."""
    
    def get_user_info(self) -> dict:
        """Get authenticated user information."""

class GmailAuth(BaseAuth):
    """Gmail authentication handler."""
    
    def is_authenticated(self) -> bool:
        """Check Gmail authentication status."""
    
    def authenticate(self) -> bool:
        """Guide through Gmail authentication."""

class LinkedInAuth(BaseAuth):
    """LinkedIn authentication handler."""
    
    def is_authenticated(self) -> bool:
        """Check LinkedIn authentication status."""
    
    def authenticate(self) -> bool:
        """Guide through LinkedIn authentication."""
```

**Example Usage**:
```python
from playwrightauthor import Browser
from playwrightauthor.auth import GitHubAuth

with Browser() as browser:
    github_auth = GitHubAuth(browser)
    
    if not github_auth.is_authenticated():
        success = github_auth.authenticate()
        if success:
            print("Successfully authenticated with GitHub")
    
    # Use authenticated session
    page = browser.new_page()
    page.goto("https://github.com/settings")
```

### OnboardingManager

Interactive authentication guidance.

```python
class OnboardingManager:
    """Manages user onboarding and authentication guidance."""
    
    def __init__(self, browser: Browser):
        """Initialize with browser instance."""
    
    def guide_authentication(
        self, 
        site: str, 
        target_url: str = None,
        timeout: int = 300
    ) -> bool:
        """Guide user through authentication process."""
    
    def serve_guidance_page(self, port: int = 8080):
        """Serve local guidance HTML page."""
    
    def wait_for_authentication(self, page, timeout: int = 300) -> bool:
        """Wait for user to complete authentication."""
```

## Monitoring and Performance

### PerformanceMonitor

Browser performance monitoring.

```python
class PerformanceMonitor:
    """Monitors browser performance metrics."""
    
    def __init__(self, browser: Browser):
        """Initialize with browser instance."""
    
    def start(self):
        """Start performance monitoring."""
    
    def stop(self):
        """Stop performance monitoring."""
    
    def get_metrics(self) -> dict:
        """Get current performance metrics."""
    
    def get_summary(self) -> dict:
        """Get performance summary since monitoring started."""
    
    def reset(self):
        """Reset performance counters."""
```

**Metrics returned**:
```python
{
    "memory_usage": 150.5,  # MB
    "cpu_usage": 12.3,      # Percentage
    "navigation_time": 1250, # Milliseconds
    "dom_content_loaded": 800, # Milliseconds
    "page_load_time": 1500,  # Milliseconds
    "network_requests": 45,   # Count
    "failed_requests": 2,     # Count
    "cache_hits": 23,        # Count
    "total_bytes": 1024000   # Bytes downloaded
}
```

### ConnectionMonitor

Browser connection health monitoring.

```python
class ConnectionMonitor:
    """Monitors browser connection health."""
    
    def __init__(self, browser: Browser):
        """Initialize with browser instance."""
    
    def start_monitoring(self, interval: int = 30):
        """Start connection health monitoring."""
    
    def stop_monitoring(self):
        """Stop connection monitoring."""
    
    def is_healthy(self) -> bool:
        """Check if connection is healthy."""
    
    def get_connection_stats(self) -> dict:
        """Get connection statistics."""
    
    def on_connection_lost(self, callback: callable):
        """Register callback for connection loss events."""
    
    def on_connection_restored(self, callback: callable):
        """Register callback for connection restoration events."""
```

## State Management

### StateManager

Browser state persistence.

```python
class StateManager:
    """Manages browser state persistence."""
    
    def __init__(self, state_file: str = None):
        """Initialize with optional state file path."""
    
    def save_state(self, state: dict):
        """Save browser state to disk."""
    
    def load_state(self) -> dict:
        """Load browser state from disk."""
    
    def clear_state(self):
        """Clear saved state."""
    
    def is_state_valid(self, state: dict) -> bool:
        """Validate state data."""
```

**State structure**:
```python
{
    "chrome_path": "/path/to/chrome",
    "chrome_version": "119.0.6045.105",
    "profile_path": "/path/to/profile", 
    "debug_port": 9222,
    "last_used": "2024-01-15T10:30:00Z",
    "process_id": 12345,
    "health_status": "healthy"
}
```

## Utilities

### Logger

Logging utilities with structured logging support.

```python
class Logger:
    """Structured logging for PlaywrightAuthor."""
    
    def __init__(self, name: str, level: str = "INFO"):
        """Initialize logger with name and level."""
    
    def debug(self, message: str, **kwargs):
        """Log debug message with optional context."""
    
    def info(self, message: str, **kwargs):
        """Log info message with optional context."""
    
    def warning(self, message: str, **kwargs):
        """Log warning message with optional context."""
    
    def error(self, message: str, **kwargs):
        """Log error message with optional context."""
    
    def set_level(self, level: str):
        """Set logging level."""
    
    def add_handler(self, handler):
        """Add custom log handler."""
```

### PathUtils

Cross-platform path utilities.

```python
class PathUtils:
    """Cross-platform path utilities."""
    
    @staticmethod
    def get_cache_dir() -> Path:
        """Get platform-specific cache directory."""
    
    @staticmethod
    def get_config_dir() -> Path:
        """Get platform-specific config directory."""
    
    @staticmethod
    def get_data_dir() -> Path:
        """Get platform-specific data directory."""
    
    @staticmethod
    def ensure_dir(path: Path) -> Path:
        """Ensure directory exists and return path."""
    
    @staticmethod
    def safe_path(path: str) -> Path:
        """Convert string to safe Path object."""
```

## Exceptions

### Custom Exceptions

```python
class PlaywrightAuthorError(Exception):
    """Base exception for PlaywrightAuthor."""

class BrowserError(PlaywrightAuthorError):
    """Browser-related errors."""

class ConnectionError(PlaywrightAuthorError):
    """Connection-related errors."""

class InstallationError(PlaywrightAuthorError):
    """Installation-related errors."""

class ConfigurationError(PlaywrightAuthorError):
    """Configuration-related errors."""

class AuthenticationError(PlaywrightAuthorError):
    """Authentication-related errors."""

class TimeoutError(PlaywrightAuthorError):
    """Timeout-related errors."""
```

**Exception handling**:
```python
from playwrightauthor import Browser
from playwrightauthor.exceptions import BrowserError, ConnectionError

try:
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://example.com")
except BrowserError as e:
    print(f"Browser error: {e}")
except ConnectionError as e:
    print(f"Connection error: {e}")
except Exception as e:
    print(f"Unexpected error: {e}")
```

## Environment Variables

### Configuration Environment Variables

| Variable | Type | Default | Description |
|----------|------|---------|-------------|
| `PLAYWRIGHTAUTHOR_HEADLESS` | bool | `True` | Run browser in headless mode |
| `PLAYWRIGHTAUTHOR_TIMEOUT` | int | `30000` | Default timeout in milliseconds |
| `PLAYWRIGHTAUTHOR_USER_DATA_DIR` | str | `~/.cache/playwrightauthor/profile` | Browser profile directory |
| `PLAYWRIGHTAUTHOR_CHROME_PATH` | str | `auto` | Custom Chrome executable path |
| `PLAYWRIGHTAUTHOR_DEBUG_PORT` | int | `9222` | Chrome remote debugging port |
| `PLAYWRIGHTAUTHOR_LOG_LEVEL` | str | `INFO` | Logging level |
| `PLAYWRIGHTAUTHOR_LOG_FILE` | str | `None` | Log file path |
| `PLAYWRIGHTAUTHOR_INSTALL_DIR` | str | `~/.cache/playwrightauthor/chrome` | Chrome installation directory |

### Development Environment Variables

| Variable | Description |
|----------|-------------|
| `DEBUG` | Enable Playwright debug logging |
| `PWDEBUG` | Enable Playwright debug mode |
| `HTTP_PROXY` | HTTP proxy server |
| `HTTPS_PROXY` | HTTPS proxy server |
| `NO_PROXY` | Hosts to bypass proxy |

## Type Definitions

### TypeScript-style Type Definitions

```python
from typing import Dict, List, Optional, Union, Callable
from pathlib import Path

# Basic types
URL = str
FilePath = Union[str, Path]
Timeout = int  # milliseconds
Port = int

# Configuration types
ViewportDict = Dict[str, int]  # {"width": int, "height": int}
ChromeArgs = List[str]
LogLevel = str  # "DEBUG" | "INFO" | "WARNING" | "ERROR"

# Callback types
ProgressCallback = Callable[[int, int], None]  # (downloaded, total)
ErrorCallback = Callable[[Exception], None]
ConnectionCallback = Callable[[], None]

# Browser types (from Playwright)
BrowserType = Union[
    'playwright.sync_api.Browser',
    'playwright.async_api.Browser'
]

PageType = Union[
    'playwright.sync_api.Page', 
    'playwright.async_api.Page'
]

ContextType = Union[
    'playwright.sync_api.BrowserContext',
    'playwright.async_api.BrowserContext'  
]
```

## Version Information

```python
# Version access
from playwrightauthor import __version__
print(f"PlaywrightAuthor version: {__version__}")

# Dependency versions
from playwrightauthor.version import get_version_info
version_info = get_version_info()
print(version_info)
# {
#     "playwrightauthor": "1.0.0",
#     "playwright": "1.40.0", 
#     "python": "3.11.0",
#     "chrome": "119.0.6045.105"
# }
```

## Next Steps

- Check [Troubleshooting](troubleshooting.md) for common issues
- Review [Contributing](contributing.md) to extend the API
- Explore examples in the project repository
- Join community discussions for API questions
</document_content>
</document>

<document index="45">
<source>src_docs/md/authentication.md</source>
<document_content>
# Authentication

PlaywrightAuthor handles authentication through persistent browser profiles and guided workflows. No need to log in every time you run automation.

## How Authentication Works

PlaywrightAuthor stores login sessions in Chrome user profiles:

1. **Profile Persistence**: Login data saves to a Chrome user profile
2. **Session Reuse**: Later runs use the existing session
3. **Guided Setup**: Interactive help for first-time authentication
4. **Cross-Site Support**: Works with any site that uses persistent cookies

## Basic Authentication Setup

### First-Time Setup

```python
from playwrightauthor import Browser

# First run - will guide you through login
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://github.com/login")
    
    # PlaywrightAuthor detects if you're logged in
    # and shows login guidance if needed
```

### Check Authentication Status

```python
from playwrightauthor import Browser
from playwrightauthor.auth import is_authenticated

with Browser() as browser:
    page = browser.new_page()
    page.goto("https://github.com")
    
    if is_authenticated(page, site="github"):
        print("Already logged in")
    else:
        print("Login required")
        # Start setup flow
```

## Onboarding Workflow

### Interactive Setup

When login is needed, PlaywrightAuthor walks you through it:

```python
from playwrightauthor import Browser
from playwrightauthor.onboarding import OnboardingManager

with Browser() as browser:
    onboarding = OnboardingManager(browser)
    
    # Start GitHub login guide
    success = onboarding.guide_authentication(
        site="github",
        target_url="https://github.com/settings/profile"
    )
    
    if success:
        print("Login saved")
```

### Onboarding Page Template

PlaywrightAuthor serves this local page for setup:

```html
<!-- http://localhost:8080/onboarding -->
<!DOCTYPE html>
<html>
<head>
    <title>PlaywrightAuthor - Authentication Setup</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .step { margin: 20px 0; padding: 15px; border-left: 4px solid #007acc; }
        .success { border-color: #28a745; background: #f8fff9; }
    </style>
</head>
<body>
    <h1>Authentication Setup</h1>
    <div class="step">
        <h3>Step 1: Login</h3>
        <p>A browser window opens. Log in normally.</p>
    </div>
    <div class="step">
        <h3>Step 2: Verify</h3>
        <p>Go to a protected page to confirm login.</p>
    </div>
    <div class="step success">
        <h3>Step 3: Done</h3>
        <p>Your session saves for future runs.</p>
    </div>
</body>
</html>
```

## Site-Specific Authentication

### GitHub

```python
from playwrightauthor import Browser
from playwrightauthor.auth.github import GitHubAuth

with Browser() as browser:
    github_auth = GitHubAuth(browser)
    
    if not github_auth.is_authenticated():
        github_auth.authenticate()
    
    page = browser.new_page()
    page.goto("https://github.com/settings/profile")
    
    name = page.input_value("#user_profile_name")
    print(f"GitHub user: {name}")
```

### Gmail

```python
from playwrightauthor import Browser
from playwrightauthor.auth.gmail import GmailAuth

with Browser() as browser:
    gmail_auth = GmailAuth(browser)
    
    if not gmail_auth.is_authenticated():
        gmail_auth.authenticate()
    
    page = browser.new_page()
    page.goto("https://mail.google.com")
    
    page.wait_for_selector("[data-tooltip='Compose']")
    page.click("[data-tooltip='Compose']")
```

### LinkedIn

```python
from playwrightauthor import Browser
from playwrightauthor.auth.linkedin import LinkedInAuth

with Browser() as browser:
    linkedin_auth = LinkedInAuth(browser)
    
    if not linkedin_auth.is_authenticated():
        linkedin_auth.authenticate()
    
    page = browser.new_page()
    page.goto("https://www.linkedin.com/feed/")
    
    page.wait_for_selector("[data-test-id='feed-tab']")
```

## Custom Authentication

### Custom Site Handler

```python
from playwrightauthor import Browser
from playwrightauthor.auth import BaseAuth

class CustomSiteAuth(BaseAuth):
    def __init__(self, browser, site_url: str):
        super().__init__(browser)
        self.site_url = site_url
    
    def is_authenticated(self) -> bool:
        page = self.browser.new_page()
        page.goto(self.site_url)
        
        login_button = page.query_selector("text=Login")
        user_menu = page.query_selector("[data-testid='user-menu']")
        
        page.close()
        return user_menu is not None and login_button is None
    
    def authenticate(self) -> bool:
        if self.is_authenticated():
            return True
        
        page = self.browser.new_page()
        page.goto(f"{self.site_url}/login")
        
        self._wait_for_authentication(page)
        return self.is_authenticated()
    
    def _wait_for_authentication(self, page):
        print("Complete login in browser...")
        
        try:
            page.wait_for_selector("[data-testid='user-menu']", timeout=300000)
            print("Login successful")
        except TimeoutError:
            print("Login timed out")

with Browser() as browser:
    auth = CustomSiteAuth(browser, "https://example.com")
    auth.authenticate()
```

### Multi-Factor Authentication

```python
from playwrightauthor import Browser
from playwrightauthor.auth import MFAHandler

class MFAAuth:
    def __init__(self, browser):
        self.browser = browser
        self.mfa_handler = MFAHandler()
    
    def handle_mfa_flow(self, page):
        if page.query_selector("text=Enter verification code"):
            return self._handle_code_verification(page)
        elif page.query_selector("text=Use your authenticator app"):
            return self._handle_app_verification(page)
        elif page.query_selector("text=Check your phone"):
            return self._handle_sms_verification(page)
        return True
    
    def _handle_code_verification(self, page):
        print("Enter verification code in browser")
        
        page.wait_for_function(
            "document.querySelector('[name=verification_code]').value.length >= 6"
        )
        
        page.click("button[type=submit]")
        return True
    
    def _handle_app_verification(self, page):
        print("Use authenticator app")
        page.wait_for_url("**/dashboard", timeout=120000)
        return True

with Browser() as browser:
    mfa_auth = MFAAuth(browser)
    
    page = browser.new_page()
    page.goto("https://secure-site.com/login")
    
    page.fill("#username", "your_username")
    page.fill("#password", "your_password")
    page.click("#login-button")
    
    mfa_auth.handle_mfa_flow(page)
```

## Profile Management

### Named Profiles

```python
from playwrightauthor import Browser, BrowserConfig
from pathlib import Path

def create_auth_profile(profile_name: str):
    profile_dir = Path.home() / ".playwrightauthor" / "profiles" / profile_name
    profile_dir.mkdir(parents=True, exist_ok=True)
    return BrowserConfig(user_data_dir=str(profile_dir))

github_config = create_auth_profile("github_work")
gmail_config = create_auth_profile("gmail_personal")

with Browser(config=github_config) as browser:
    page = browser.new_page()
    page.goto("https://github.com/settings")

with Browser(config=gmail_config) as browser:
    page = browser.new_page()
    page.goto("https://mail.google.com")
```

### Switch Profiles

```python
from playwrightauthor.auth import ProfileManager

profile_manager = ProfileManager()

profiles = {
    "work": "/path/to/work/profile",
    "personal": "/path/to/personal/profile"
}

for name, path in profiles.items():
    config = BrowserConfig(user_data_dir=path)
    
    with Browser(config=config) as browser:
        print(f"Using {name} profile")
        page = browser.new_page()
        page.goto("https://github.com")
        
        if page.query_selector("[data-testid='header-user-menu']"):
            user = page.text_content("[data-testid='header-user-menu'] img")
            print(f"Logged in as: {user}")
```

## Session Validation

### Check Session Health

```python
from playwrightauthor.auth import SessionValidator

class SessionValidator:
    def __init__(self, browser):
        self.browser = browser
    
    def validate_session(self, site: str) -> bool:
        validators = {
            "github": self._validate_github_session,
            "gmail": self._validate_gmail_session
        }
        
        validator = validators.get(site)
        return validator() if validator else False
    
    def _validate_github_session(self) -> bool:
        page = self.browser.new_page()
        page.goto("https://api.github.com/user")
        
        is_valid = "login" in page.text_content("body")
        page.close()
        return is_valid
    
    def refresh_session_if_needed(self, site: str):
        if not self.validate_session(site):
            print(f"Session expired for {site}, re-authenticating...")
            
            auth_handlers = {
                "github": GitHubAuth,
                "gmail": GmailAuth
            }
            
            auth_class = auth_handlers.get(site)
            if auth_class:
                auth = auth_class(self.browser)
                auth.authenticate()

with Browser() as browser:
    validator = SessionValidator(browser)
    validator.refresh_session_if_needed("github")
    
    page = browser.new_page()
    page.goto("https://github.com/settings")
```

## Security Practices

### Secure Profile Storage

```python
import os
from pathlib import Path
from playwrightauthor import BrowserConfig

def create_secure_profile(profile_name: str):
    profile_dir = Path.home() / ".playwrightauthor" / "profiles" / profile_name
    profile_dir.mkdir(parents=True, exist_ok=True)
    os.chmod(profile_dir, 0o700)  # Owner read/write only
    return BrowserConfig(user_data_dir=str(profile_dir))
```

### Environment Configuration

```python
import os
from playwrightauthor import Browser, BrowserConfig

def get_auth_config():
    profile_path = os.getenv("PLAYWRIGHT_PROFILE_PATH")
    if not profile_path:
        raise ValueError("PLAYWRIGHT_PROFILE_PATH required")
    return BrowserConfig(user_data_dir=profile_path)

config = get_auth_config()
with Browser(config=config) as browser:
    pass
```

### Credential Management

```python
from playwrightauthor.auth import CredentialManager

class CredentialManager:
    def __init__(self):
        self.credentials = {}
    
    def store_credential(self, site: str, username: str, encrypted_token: str):
        self.credentials[site] = {
            "username": username,
            "token": encrypted_token,
            "expires_at": None
        }
    
    def get_credential(self, site: str):
        return self.credentials.get(site)
    
    def is_credential_valid(self, site: str) -> bool:
        cred = self.get_credential(site)
        if not cred:
            return False
        
        if cred.get("expires_at"):
            from datetime import datetime
            return datetime.now() < cred["expires_at"]
        
        return True
```

## Troubleshooting

### Common Issues

1. **Session Expired**:
```python
try:
    page.goto("https://secure-site.com/protected")
    if "login" in page.url:
        auth.authenticate()
        page.goto("https://secure-site.com/protected")
except Exception as e:
    print(f"Auth error: {e}")
```

2. **Profile Corrupted**:
```python
from playwrightauthor.auth import ProfileRepair

repair = ProfileRepair()
if repair.is_profile_corrupted(profile_path):
    repair.backup_profile(profile_path)
    repair.create_fresh_profile(profile_path)
```

3. **Cookie Problems**:
```python
# Clear cookies for specific site
page.context.clear_cookies(url="https://problematic-site.com")

# Or clear all cookies
page.context.clear_cookies()
```

## Next Steps

- See [Advanced Features](advanced-features.md) for complex auth cases
- Check [Troubleshooting](troubleshooting.md) for auth issues
- Review [API Reference](api-reference.md) for auth methods
- Learn [Browser Management](browser-management.md) for profile handling
</document_content>
</document>

<document index="46">
<source>src_docs/md/basic-usage.md</source>
<document_content>
# Basic Usage

## Core Concepts

PlaywrightAuthor provides two classes for browser automation:

- **`Browser()`** - Synchronous context manager
- **`AsyncBrowser()`** - Asynchronous context manager

Both return authenticated Playwright browser objects ready for automation.

## Browser Context Manager

### Synchronous Usage

```python
from playwrightauthor import Browser

with Browser() as browser:
    page = browser.new_page()
    page.goto("https://github.com")
    print(page.title())
```

### Asynchronous Usage

```python
import asyncio
from playwrightauthor import AsyncBrowser

async def automate():
    async with AsyncBrowser() as browser:
        page = await browser.new_page()
        await page.goto("https://github.com")
        title = await page.title()
        print(title)

asyncio.run(automate())
```

## Common Patterns

### Multiple Pages

```python
with Browser() as browser:
    page1 = browser.new_page()
    page2 = browser.new_page()
    
    page1.goto("https://github.com")
    page2.goto("https://stackoverflow.com")
    
    print(f"Page 1: {page1.title()}")
    print(f"Page 2: {page2.title()}")
```

### Form Interaction

```python
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com/login")
    
    page.fill("#username", "your_username")
    page.fill("#password", "your_password")
    page.click("#login-button")
    
    page.wait_for_url("**/dashboard")
```

### Element Interaction

```python
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    
    page.click("button")
    page.click("text=Submit")
    page.click("#submit-btn")
    
    page.type("#search", "playwright automation")
    page.select_option("#dropdown", "option1")
```

### Screenshots and PDFs

```python
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    
    page.screenshot(path="screenshot.png")
    page.pdf(path="page.pdf")
    page.screenshot(path="fullpage.png", full_page=True)
```

## Configuration Options

### Browser Configuration

```python
from playwrightauthor import Browser, BrowserConfig

config = BrowserConfig(
    headless=False,
    timeout=30000,
    user_data_dir="/custom/path"
)

with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

### Viewport and Device Emulation

```python
with Browser() as browser:
    # Custom viewport
    page = browser.new_page(viewport={"width": 1920, "height": 1080})
    
    # Device emulation
    iphone = browser.devices["iPhone 12"]
    page = browser.new_page(**iphone)
    
    page.goto("https://example.com")
```

## Error Handling

### Basic Error Handling

```python
from playwrightauthor import Browser
from playwrightauthor.exceptions import BrowserError

try:
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://example.com")
        page.click("#non-existent-button")
except BrowserError as e:
    print(f"Browser error: {e}")
except Exception as e:
    print(f"Unexpected error: {e}")
```

### Timeout Handling

```python
from playwright.sync_api import TimeoutError

with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    
    try:
        page.click("#slow-button", timeout=5000)
    except TimeoutError:
        print("Button not found within 5 seconds")
```

## Best Practices

### Resource Management

```python
# ✅ Use context managers
with Browser() as browser:
    page = browser.new_page()
    # Automatic cleanup

# ❌ Avoid manual management
browser = Browser()
# Risk of resource leaks
```

### Page Lifecycle

```python
with Browser() as browser:
    page = browser.new_page()
    
    page.goto("https://example.com")
    page.wait_for_load_state("networkidle")
    
    page.click("button")
    page.close()
```

### Element Waiting

```python
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    
    # Wait for element visibility
    page.wait_for_selector("#content", state="visible")
    
    # Wait for element attachment
    page.wait_for_selector("button", state="attached")
    
    page.click("button")
```

## Debugging Tips

### Enable Verbose Logging

```python
from playwrightauthor import Browser
import logging

logging.basicConfig(level=logging.DEBUG)

with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

### Slow Down Actions

```python
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    
    page.click("button")
    page.wait_for_timeout(2000)
    
    page.fill("#input", "text")
    page.wait_for_timeout(1000)
```

### Inspect Elements

```python
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    
    page.pause()  # Opens Playwright Inspector
```

## Next Steps

- [Configuration](configuration.md) options
- [Browser Management](browser-management.md) details
- [Authentication](authentication.md) workflows
- [Advanced Features](advanced-features.md) for complex scenarios
</document_content>
</document>

<document index="47">
<source>src_docs/md/browser-management.md</source>
<document_content>
# Browser Management

PlaywrightAuthor automates the full browser lifecycle—from locating or installing Chrome to managing processes and connections. This chapter explains how it works under the hood.

## Browser Lifecycle

### 1. Browser Discovery

PlaywrightAuthor looks for Chrome in this order:

1. **Environment variable**: `PLAYWRIGHTAUTHOR_CHROME_PATH`
2. **System installations**: Standard Chrome/Chromium locations
3. **Downloaded instances**: Previously downloaded Chrome for Testing
4. **Fresh download**: Latest Chrome for Testing

```python
from playwrightauthor.browser import finder

# Find Chrome executable
chrome_path = finder.find_chrome()
print(f"Found Chrome at: {chrome_path}")

# List search locations
locations = finder.get_chrome_locations()
for location in locations:
    print(f"Checking: {location}")
```

### 2. Chrome Installation

If no suitable Chrome is found, PlaywrightAuthor downloads Chrome for Testing:

```python
from playwrightauthor.browser import installer

# Download latest Chrome for Testing
chrome_path = installer.download_chrome()
print(f"Downloaded Chrome to: {chrome_path}")

# Show available versions
versions = installer.get_available_versions()
print(f"Available versions: {versions[:5]}")  # Latest 5
```

### 3. Process Management

PlaywrightAuthor handles Chrome processes:

```python
from playwrightauthor.browser import process

# Launch Chrome with debugging enabled
proc = process.launch_chrome(
    executable_path="/path/to/chrome",
    debug_port=9222,
    user_data_dir="/path/to/profile"
)

# Check if Chrome is running on port
is_running = process.is_chrome_debug_running(port=9222)
print(f"Chrome debug running: {is_running}")

# Kill existing Chrome processes
process.kill_chrome_instances()
```

### 4. Connection Establishment

Playwright connects to the launched Chrome instance:

```python
from playwrightauthor.connection import connect_to_chrome

# Connect via debug port
browser = connect_to_chrome(debug_port=9222)
print(f"Connected to browser: {browser}")
```

## Browser Discovery Details

### Chrome Search Locations

PlaywrightAuthor checks over 20 locations per platform.

#### Windows
```
C:\Program Files\Google\Chrome\Application\chrome.exe
C:\Program Files (x86)\Google\Chrome\Application\chrome.exe
%LOCALAPPDATA%\Google\Chrome\Application\chrome.exe
%PROGRAMFILES%\Google\Chrome\Application\chrome.exe
C:\Program Files\Chromium\Application\chrome.exe
```

#### macOS
```
/Applications/Google Chrome.app/Contents/MacOS/Google Chrome
/Applications/Chromium.app/Contents/MacOS/Chromium
~/Applications/Google Chrome.app/Contents/MacOS/Google Chrome
/usr/bin/google-chrome
/usr/local/bin/chrome
```

#### Linux
```
/usr/bin/google-chrome
/usr/bin/google-chrome-stable
/usr/bin/chromium
/usr/bin/chromium-browser
/snap/bin/chromium
/opt/google/chrome/chrome
```

### Custom Chrome Path

Specify a custom Chrome path using `BrowserConfig`:

```python
from playwrightauthor import Browser, BrowserConfig

config = BrowserConfig(
    chrome_path="/opt/google/chrome/chrome"
)

with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

## Chrome for Testing

### Automatic Downloads

Chrome for Testing offers stable builds for automation:

```python
from playwrightauthor.browser.installer import ChromeInstaller

installer = ChromeInstaller()

# Install specific version
chrome_path = installer.install_version("119.0.6045.105")

# Install latest version
chrome_path = installer.install_latest()

# Install with progress callback
def progress(downloaded: int, total: int):
    percent = (downloaded / total) * 100
    print(f"Progress: {percent:.1f}%")

chrome_path = installer.install_latest(progress_callback=progress)
```

### Version Management

```python
from playwrightauthor.browser.installer import get_chrome_versions

# List all versions
versions = get_chrome_versions()
print(f"Latest version: {versions[0]}")
print(f"Total versions: {len(versions)}")

# Filter by milestone
v119 = [v for v in versions if v.startswith("119.")]
print(f"Chrome 119 builds: {v119}")
```

### Cache Management

```python
from playwrightauthor.browser.installer import ChromeCache

cache = ChromeCache()

# List installed versions
installed = cache.list_installed()
print(f"Installed versions: {installed}")

# Keep last 3, remove the rest
cache.cleanup_old_versions(keep_count=3)

# Clear entire cache
cache.clear_all()

# Show cache size in MB
size_mb = cache.get_cache_size() / (1024 * 1024)
print(f"Cache size: {size_mb:.1f} MB")
```

## Process Management

### Launch Parameters

Chrome starts with automation-friendly flags:

```python
DEFAULT_CHROME_ARGS = [
    "--remote-debugging-port=9222",
    "--no-first-run",
    "--no-default-browser-check",
    "--disable-background-networking",
    "--disable-background-timer-throttling",
    "--disable-renderer-backgrounding",
    "--disable-backgrounding-occluded-windows",
    "--disable-client-side-phishing-detection",
    "--disable-default-apps",
    "--disable-dev-shm-usage",
    "--disable-extensions",
    "--disable-features=TranslateUI",
    "--disable-hang-monitor",
    "--disable-ipc-flooding-protection",
    "--disable-popup-blocking",
    "--disable-prompt-on-repost",
    "--disable-sync",
    "--disable-web-resources",
    "--enable-automation",
    "--enable-logging",
    "--log-level=0",
    "--password-store=basic",
    "--use-mock-keychain",
]
```

### Process Monitoring

```python
from playwrightauthor.browser.process import ChromeProcessManager

manager = ChromeProcessManager()

# List Chrome processes
processes = manager.get_chrome_processes()
for proc in processes:
    print(f"PID: {proc.pid}, Command: {' '.join(proc.cmdline())}")

# Check if port is free
port_available = manager.is_port_available(9222)
print(f"Port 9222 available: {port_available}")

# Wait for Chrome to start
manager.wait_for_chrome_ready(port=9222, timeout=30)
```

### Graceful Shutdown

```python
from playwrightauthor.browser.process import shutdown_chrome

# Try clean shutdown
shutdown_chrome(graceful=True, timeout=10)

# Force kill if needed
shutdown_chrome(graceful=False)
```

## Connection Management

### WebSocket Connection

Playwright connects to Chrome over WebSocket:

```python
from playwrightauthor.connection import ChromeConnection

connection = ChromeConnection(debug_port=9222)

# Connect
browser = connection.connect()

# Check connection health
healthy = connection.is_healthy()
print(f"Connection healthy: {healthy}")

# Reconnect if broken
if not healthy:
    browser = connection.reconnect()
```

### Connection Pooling

```python
from playwrightauthor.connection import ConnectionPool

pool = ConnectionPool(max_connections=5)

# Get a connection
conn = pool.get_connection()

# Return it when done
pool.return_connection(conn)

# Close all connections
pool.close_all()
```

## Browser State Management

### Persistent State

```python
from playwrightauthor.state_manager import BrowserStateManager

state_manager = BrowserStateManager()

# Save browser state
state_manager.save_state({
    "chrome_path": "/path/to/chrome",
    "version": "119.0.6045.105",
    "profile_path": "/path/to/profile",
    "last_used": "2024-01-15T10:30:00Z"
})

# Load state
state = state_manager.load_state()
print(f"Last used Chrome: {state.get('chrome_path')}")

# Validate state
valid = state_manager.is_state_valid(state)
```

### Profile Management

```python
from playwrightauthor.browser.profile import ProfileManager

profile_manager = ProfileManager()

# Create profile
profile_path = profile_manager.create_profile("automation_profile")

# List profiles
profiles = profile_manager.list_profiles()
print(f"Available profiles: {profiles}")

# Clone profile
new_profile = profile_manager.clone_profile(
    source="automation_profile",
    target="backup_profile"
)

# Delete profile
profile_manager.delete_profile("old_profile")
```

## Advanced Browser Management

### Custom Browser Launcher

```python
from playwrightauthor.browser.launcher import BrowserLauncher

class CustomLauncher(BrowserLauncher):
    def get_launch_args(self) -> list[str]:
        args = super().get_launch_args()
        args.extend([
            "--custom-flag=value",
            "--another-custom-flag"
        ])
        return args
    
    def pre_launch_hook(self):
        print("Launching Chrome...")

    def post_launch_hook(self, process):
        print(f"Chrome PID: {process.pid}")

launcher = CustomLauncher()
browser = launcher.launch()
```

### Browser Health Monitoring

```python
from playwrightauthor.monitoring import BrowserMonitor

monitor = BrowserMonitor()

# Start periodic checks
monitor.start_monitoring(interval=30)

# Get health status
health = monitor.get_health_status()
print(f"Browser health: {health}")

# Get metrics
metrics = monitor.get_metrics()
print(f"Memory: {metrics['memory_mb']} MB")
print(f"CPU: {metrics['cpu_percent']}%")

# Stop monitoring
monitor.stop_monitoring()
```

### Error Recovery

```python
from playwrightauthor.browser.recovery import BrowserRecovery

recovery = BrowserRecovery()

# Try to recover browser
try:
    browser = recovery.recover_browser()
except Exception as e:
    print(f"Recovery failed: {e}")
    browser = recovery.create_fresh_browser()
```

## Configuration for Browser Management

### Browser Manager Configuration

```python
from playwrightauthor import BrowserConfig

config = BrowserConfig(
    # Installation
    install_dir="~/.cache/playwrightauthor/chrome",
    download_timeout=300,  # 5 minutes
    
    # Process
    launch_timeout=30,
    debug_port=9222,
    kill_existing=True,
    
    # Connection
    connect_timeout=10,
    connect_retries=3,
    
    # Monitoring
    health_check_interval=60,
    auto_restart=True,
)
```

## Troubleshooting Browser Management

### Common Issues

1. **Port already in use**:
```python
from playwrightauthor.browser.process import find_available_port

# Get an open port
port = find_available_port(start_port=9222)
config = BrowserConfig(debug_port=port)
```

2. **Permission errors**:
```bash
# Fix on Linux/macOS
chmod +x ~/.cache/playwrightauthor/chrome/*/chrome
```

3. **Download failures**:
```python
from playwrightauthor.browser.installer import ChromeInstaller

installer = ChromeInstaller()
# Use alternative download URL
installer.set_download_url("https://mirror.example.com/chrome/")
```

## Next Steps

- Set up [Authentication](authentication.md) for persistent sessions
- Learn about [Advanced Features](advanced-features.md)
- Review [Troubleshooting](troubleshooting.md) for browser errors
- Check [API Reference](api-reference.md) for method details
</document_content>
</document>

<document index="48">
<source>src_docs/md/configuration.md</source>
<document_content>
# Configuration

PlaywrightAuthor supports flexible configuration through environment variables, Python objects, and runtime parameters.

## Configuration Methods

### 1. Environment Variables

Set environment variables for default settings:

```bash
# Browser settings
export PLAYWRIGHTAUTHOR_HEADLESS=false
export PLAYWRIGHTAUTHOR_TIMEOUT=30000
export PLAYWRIGHTAUTHOR_USER_DATA_DIR=/custom/profile

# Chrome settings
export PLAYWRIGHTAUTHOR_CHROME_PATH=/opt/chrome/chrome
export PLAYWRIGHTAUTHOR_DEBUG_PORT=9222

# Logging
export PLAYWRIGHTAUTHOR_LOG_LEVEL=DEBUG
export PLAYWRIGHTAUTHOR_LOG_FILE=/var/log/playwright.log
```

### 2. Configuration Objects

Use `BrowserConfig` for programmatic control:

```python
from playwrightauthor import Browser, BrowserConfig

config = BrowserConfig(
    headless=False,
    timeout=30000,
    user_data_dir="./my_profile",
    debug_port=9223,
    chrome_args=["--disable-web-security"]
)

with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

### 3. Runtime Parameters

Override any setting at runtime:

```python
with Browser(headless=True, timeout=60000) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

## Browser Configuration

### BrowserConfig Class

```python
from playwrightauthor import BrowserConfig

config = BrowserConfig(
    # Display
    headless=False,              # Show browser window
    viewport={"width": 1920, "height": 1080},  # Window size
    
    # Timing
    timeout=30000,               # Operation timeout (ms)
    navigation_timeout=30000,    # Navigation timeout (ms)
    
    # Chrome
    chrome_path=None,           # Custom Chrome path
    chrome_args=[],             # Additional Chrome flags
    user_data_dir=None,         # Profile directory
    debug_port=9222,            # Remote debugging port
    
    # Features
    ignore_https_errors=False,  # Skip SSL validation
    bypass_csp=False,           # Ignore Content Security Policy
    
    # Logging
    log_level="INFO",           # Log verbosity
    log_file=None,              # Log output file
)
```

### Common Chrome Arguments

```python
config = BrowserConfig(
    chrome_args=[
        "--disable-web-security",      # Skip CORS checks
        "--disable-features=VizDisplayCompositor",  # Fix rendering bugs
        "--disable-background-timer-throttling",    # Keep timers active
        "--disable-renderer-backgrounding",         # Prevent tab slowdown
        "--disable-backgrounding-occluded-windows", # Prevent window slowdown
        "--disable-blink-features=AutomationControlled",  # Hide bot detection
        "--no-sandbox",                 # Required in containers
        "--disable-dev-shm-usage",      # Use disk instead of memory
        "--disable-gpu",                # Skip GPU acceleration
        "--user-agent=Custom User Agent",  # Fake browser identity
    ]
)
```

## Environment Variables Reference

### Core Settings

| Variable | Type | Default | Description |
|----------|------|---------|-------------|
| `PLAYWRIGHTAUTHOR_HEADLESS` | bool | `True` | Show/hide browser window |
| `PLAYWRIGHTAUTHOR_TIMEOUT` | int | `30000` | Timeout in milliseconds |
| `PLAYWRIGHTAUTHOR_USER_DATA_DIR` | str | `~/.cache/playwrightauthor/profile` | Profile storage path |
| `PLAYWRIGHTAUTHOR_DEBUG_PORT` | int | `9222` | Chrome debugging port |

### Chrome Settings

| Variable | Type | Default | Description |
|----------|------|---------|-------------|
| `PLAYWRIGHTAUTHOR_CHROME_PATH` | str | `auto` | Chrome executable path |
| `PLAYWRIGHTAUTHOR_CHROME_ARGS` | str | `""` | Comma-separated flags |
| `PLAYWRIGHTAUTHOR_INSTALL_DIR` | str | `~/.cache/playwrightauthor/chrome` | Chrome install path |

### Logging Settings

| Variable | Type | Default | Description |
|----------|------|---------|-------------|
| `PLAYWRIGHTAUTHOR_LOG_LEVEL` | str | `INFO` | Log level (DEBUG, INFO, WARNING, ERROR) |
| `PLAYWRIGHTAUTHOR_LOG_FILE` | str | `None` | Log file path (stdout if unset) |
| `PLAYWRIGHTAUTHOR_VERBOSE` | bool | `False` | Enable detailed logging |

### Network Settings

| Variable | Type | Default | Description |
|----------|------|---------|-------------|
| `HTTP_PROXY` | str | `None` | HTTP proxy address |
| `HTTPS_PROXY` | str | `None` | HTTPS proxy address |
| `NO_PROXY` | str | `None` | Proxy bypass list |

## Configuration Examples

### Development Environment

```python
# dev_config.py
from playwrightauthor import BrowserConfig

DEV_CONFIG = BrowserConfig(
    headless=False,              # Visible browser for debugging
    timeout=60000,               # Generous timeouts
    log_level="DEBUG",           # Full logging
    chrome_args=[
        "--auto-open-devtools-for-tabs",  # Auto-open DevTools
        "--disable-web-security",         # Skip CORS for local testing
    ]
)
```

### Production Environment

```python
# prod_config.py
from playwrightauthor import BrowserConfig

PROD_CONFIG = BrowserConfig(
    headless=True,               # No GUI
    timeout=30000,               # Standard timeouts
    log_level="WARNING",         # Log only warnings and errors
    chrome_args=[
        "--no-sandbox",              # Required in containers
        "--disable-dev-shm-usage",   # Avoid memory issues
        "--disable-gpu",             # No GPU in headless mode
    ]
)
```

### Testing Environment

```python
# test_config.py
from playwrightauthor import BrowserConfig

TEST_CONFIG = BrowserConfig(
    headless=True,               # Headless for CI
    timeout=10000,               # Fast failure
    user_data_dir=None,          # Fresh profile per test
    chrome_args=[
        "--disable-extensions",      # No extensions
        "--disable-plugins",         # No plugins
        "--disable-images",          # Faster page loads
    ]
)
```

### Docker Environment

```python
# docker_config.py
from playwrightauthor import BrowserConfig

DOCKER_CONFIG = BrowserConfig(
    headless=True,
    chrome_args=[
        "--no-sandbox",                    # Required in containers
        "--disable-dev-shm-usage",         # Use /tmp instead of /dev/shm
        "--disable-gpu",                   # Skip GPU in containers
        "--disable-software-rasterizer",   # Disable software rendering
        "--remote-debugging-address=0.0.0.0",  # Allow external debugging
    ]
)
```

## Advanced Configuration

### Dynamic Configuration

```python
import os
from playwrightauthor import Browser, BrowserConfig

def get_config():
    """Load config based on environment"""
    if os.getenv("CI"):
        # CI/CD settings
        return BrowserConfig(
            headless=True,
            timeout=10000,
            chrome_args=["--no-sandbox", "--disable-dev-shm-usage"]
        )
    elif os.getenv("DEBUG"):
        # Debug settings
        return BrowserConfig(
            headless=False,
            timeout=60000,
            log_level="DEBUG"
        )
    else:
        # Default settings
        return BrowserConfig()

with Browser(config=get_config()) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

### Configuration Validation

```python
from playwrightauthor import BrowserConfig
from playwrightauthor.exceptions import ConfigurationError

def validate_config(config: BrowserConfig):
    """Sanity check configuration"""
    if config.timeout < 1000:
        raise ConfigurationError("Timeout must be at least 1000ms")
    
    if config.debug_port < 1024 or config.debug_port > 65535:
        raise ConfigurationError("Debug port must be between 1024-65535")
    
    return config

config = BrowserConfig(timeout=5000, debug_port=9222)
validated_config = validate_config(config)
```

### Profile Management

```python
import tempfile
from pathlib import Path
from playwrightauthor import Browser, BrowserConfig

def create_temp_profile():
    """Create isolated session profile"""
    temp_dir = tempfile.mkdtemp(prefix="playwright_profile_")
    return BrowserConfig(user_data_dir=temp_dir)

def create_named_profile(name: str):
    """Create persistent profile"""
    profile_dir = Path.home() / ".playwrightauthor" / "profiles" / name
    profile_dir.mkdir(parents=True, exist_ok=True)
    return BrowserConfig(user_data_dir=str(profile_dir))

# Isolated session
with Browser(config=create_temp_profile()) as browser:
    pass

# Persistent session
with Browser(config=create_named_profile("github_automation")) as browser:
    pass
```

## Configuration File Support

### YAML Configuration

```yaml
# playwrightauthor.yml
browser:
  headless: false
  timeout: 30000
  viewport:
    width: 1920
    height: 1080
  
chrome:
  debug_port: 9222
  args:
    - "--disable-web-security"
    - "--disable-features=VizDisplayCompositor"
  
logging:
  level: "INFO"
  file: "/var/log/playwright.log"
```

```python
import yaml
from playwrightauthor import Browser, BrowserConfig

def load_config_from_file(path: str) -> BrowserConfig:
    """Parse YAML config file"""
    with open(path, 'r') as f:
        data = yaml.safe_load(f)
    
    browser_config = data.get('browser', {})
    chrome_config = data.get('chrome', {})
    logging_config = data.get('logging', {})
    
    return BrowserConfig(
        headless=browser_config.get('headless', True),
        timeout=browser_config.get('timeout', 30000),
        viewport=browser_config.get('viewport'),
        debug_port=chrome_config.get('debug_port', 9222),
        chrome_args=chrome_config.get('args', []),
        log_level=logging_config.get('level', 'INFO'),
        log_file=logging_config.get('file'),
    )

config = load_config_from_file('playwrightauthor.yml')
with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

## Next Steps

- [Browser Management](browser-management.md) internals
- [Authentication](authentication.md) workflows
- [Advanced Features](advanced-features.md) for complex scenarios
- [Troubleshooting](troubleshooting.md) configuration issues
</document_content>
</document>

<document index="49">
<source>src_docs/md/contributing.md</source>
<document_content>
# Contributing

PlaywrightAuthor welcomes contributions. This guide covers setup, development workflow, coding standards, testing, and pull requests.

## Development Setup

### Prerequisites

- **Python 3.8+** (3.11+ recommended)
- **Git** for version control
- **uv** for dependency management
- **Chrome or Chromium** for testing

### Initial Setup

1. **Fork and Clone**:
```bash
# Fork the repository on GitHub first
git clone https://github.com/yourusername/playwrightauthor.git
cd playwrightauthor
```

2. **Set up Development Environment**:
```bash
# Install uv if not already installed
curl -LsSf https://astral.sh/uv/install.sh | sh

# Create virtual environment and install dependencies
uv venv --python 3.11
source .venv/bin/activate  # On Windows: .venv\Scripts\activate
uv sync --dev

# Install pre-commit hooks
pre-commit install
```

3. **Verify Installation**:
```bash
# Run tests to ensure everything works
python -m pytest

# Check code quality
python -m ruff check
python -m mypy src/

# Run a simple test
python -c "from playwrightauthor import Browser; print('Installation successful!')"
```

### Development Workflow

1. **Create Feature Branch**:
```bash
git checkout -b feature/your-feature-name
# or
git checkout -b fix/issue-description
```

2. **Make Changes**: Follow coding standards below

3. **Run Quality Checks**:
```bash
# Format and lint code
fd -e py -x uvx autoflake -i {}
fd -e py -x uvx pyupgrade --py312-plus {}
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}

# Type checking
python -m mypy src/

# Run tests
python -m pytest -v
```

4. **Commit Changes**:
```bash
git add .
git commit -m "feat: add new feature description"
# Use conventional commit format (see below)
```

5. **Push and Create PR**:
```bash
git push origin feature/your-feature-name
# Create pull request on GitHub
```

## Coding Standards

### Code Style

**Python Standards**:
- **PEP 8**: Formatting and naming conventions
- **PEP 20**: Keep code simple and explicit
- **PEP 257**: Clear, imperative docstrings
- **Type hints**: Use modern type hints (list, dict, | for unions)

**File Structure**:
- Every file must include a `this_file:` comment with relative path
- Use consistent imports and module organization
- Follow existing patterns in the codebase

### Example Code Style

```python
#!/usr/bin/env python3
# this_file: src/playwrightauthor/example.py

"""
Example module demonstrating coding standards.
"""

from pathlib import Path
from typing import Optional
from loguru import logger


class ExampleClass:
    """Example class with proper documentation and type hints."""
    
    def __init__(self, name: str, timeout: int = 30) -> None:
        """
        Initialize example class.
        
        Args:
            name: The name identifier
            timeout: Timeout in seconds (default: 30)
        """
        self.name = name
        self.timeout = timeout
        logger.debug(f"Created {self.__class__.__name__} with name={name}")
    
    def process_data(self, data: list[dict]) -> dict[str, any]:
        """
        Process input data and return results.
        
        Args:
            data: List of data dictionaries to process
            
        Returns:
            Dictionary containing processing results
            
        Raises:
            ValueError: If data is empty or invalid
        """
        if not data:
            raise ValueError("Data cannot be empty")
        
        results = {"processed": len(data), "errors": []}
        
        for item in data:
            try:
                self._process_item(item)
            except Exception as e:
                logger.warning(f"Failed to process item: {e}")
                results["errors"].append(str(e))
        
        return results
    
    def _process_item(self, item: dict) -> None:
        """Private method to process individual item."""
        pass
```

### Documentation Standards

**Docstring Format**:
```python
def function_name(param1: str, param2: int = 10) -> bool:
    """
    Brief one-line description of what the function does.
    
    Args:
        param1: Description of first parameter
        param2: Description of second parameter (default: 10)
    
    Returns:
        Description of return value
    
    Raises:
        ValueError: When parameter validation fails
        ConnectionError: When unable to connect to browser
    
    Example:
        >>> result = function_name("test", 20)
        >>> assert result is True
    """
```

**Code Comments**:
```python
# Use comments to explain WHY, not WHAT
# Good: Retry connection to handle temporary network issues
# Bad: Increment retry_count variable

def connect_with_retry(self, max_retries: int = 3) -> bool:
    """Connect to browser with retry logic."""
    for attempt in range(max_retries):
        try:
            return self._connect()
        except ConnectionError:
            # Exponential backoff to avoid overwhelming the server
            time.sleep(2 ** attempt)
    
    return False
```

## Testing

### Test Structure

Tests are organized in the `tests/` directory:

```
tests/
├── unit/
│   ├── test_browser.py
│   ├── test_config.py
│   └── test_finder.py
├── integration/
│   ├── test_browser_manager.py
│   └── test_auth.py
├── e2e/
│   └── test_full_workflow.py
└── conftest.py
```

### Writing Tests

**Unit Test Example**:
```python
# tests/unit/test_config.py
# this_file: tests/unit/test_config.py

import pytest
from playwrightauthor import BrowserConfig
from playwrightauthor.exceptions import ConfigurationError


class TestBrowserConfig:
    """Test cases for BrowserConfig class."""
    
    def test_default_config(self):
        """Test default configuration values."""
        config = BrowserConfig()
        
        assert config.headless is True
        assert config.timeout == 30000
        assert config.debug_port == 9222
    
    def test_custom_config(self):
        """Test custom configuration values."""
        config = BrowserConfig(
            headless=False,
            timeout=60000,
            debug_port=9223
        )
        
        assert config.headless is False
        assert config.timeout == 60000
        assert config.debug_port == 9223
    
    def test_invalid_timeout(self):
        """Test validation of invalid timeout."""
        with pytest.raises(ConfigurationError):
            BrowserConfig(timeout=-1000)
    
    def test_config_serialization(self):
        """Test configuration to/from dict conversion."""
        original = BrowserConfig(headless=False, timeout=45000)
        config_dict = original.to_dict()
        restored = BrowserConfig.from_dict(config_dict)
        
        assert restored.headless == original.headless
        assert restored.timeout == original.timeout
    
    @pytest.mark.parametrize("port,expected", [
        (9222, True),
        (80, False),
        (65536, False),
    ])
    def test_port_validation(self, port: int, expected: bool):
        """Test port validation with various values."""
        if expected:
            config = BrowserConfig(debug_port=port)
            assert config.debug_port == port
        else:
            with pytest.raises(ConfigurationError):
                BrowserConfig(debug_port=port)
```

**Integration Test Example**:
```python
# tests/integration/test_browser_manager.py
# this_file: tests/integration/test_browser_manager.py

import pytest
from playwrightauthor import Browser, BrowserConfig
from playwrightauthor.browser_manager import BrowserManager


class TestBrowserManager:
    """Integration tests for browser management."""
    
    def test_browser_lifecycle(self):
        """Test complete browser lifecycle."""
        config = BrowserConfig(headless=True)
        manager = BrowserManager(config)
        
        # Test browser startup
        chrome_path = manager.ensure_browser_available()
        assert chrome_path is not None
        
        # Test browser launch
        process = manager.launch_browser()
        assert process is not None
        assert process.poll() is None  # Process is running
        
        # Test connection
        browser = manager.connect_to_browser()
        assert browser is not None
        
        # Test browser usage
        page = browser.new_page()
        page.goto("data:text/html,<h1>Test</h1>")
        assert "Test" in page.content()
        
        # Test cleanup
        manager.cleanup()
    
    @pytest.mark.slow
    def test_chrome_download(self):
        """Test Chrome for Testing download (slow test)."""
        from playwrightauthor.browser.installer import ChromeInstaller
        
        installer = ChromeInstaller()
        chrome_path = installer.install_latest()
        
        assert chrome_path is not None
        assert Path(chrome_path).exists()
        assert Path(chrome_path).is_file()
```

### Test Fixtures

```python
# tests/conftest.py
# this_file: tests/conftest.py

import pytest
import tempfile
from pathlib import Path
from playwrightauthor import Browser, BrowserConfig


@pytest.fixture
def temp_profile():
    """Create temporary profile directory."""
    with tempfile.TemporaryDirectory() as temp_dir:
        yield Path(temp_dir)


@pytest.fixture
def test_config(temp_profile):
    """Create test configuration."""
    return BrowserConfig(
        headless=True,
        timeout=10000,
        user_data_dir=str(temp_profile)
    )


@pytest.fixture
def browser_instance(test_config):
    """Create browser instance for testing."""
    with Browser(config=test_config) as browser:
        yield browser


@pytest.fixture(scope="session")
def chrome_executable():
    """Ensure Chrome is available for tests."""
    from playwrightauthor.browser.finder import find_chrome
    
    try:
        return find_chrome()
    except Exception:
        from playwrightauthor.browser.installer import ChromeInstaller
        installer = ChromeInstaller()
        return installer.install_latest()
```

### Running Tests

```bash
# Run all tests
python -m pytest

# Run specific test categories
python -m pytest tests/unit/                    # Unit tests only
python -m pytest tests/integration/             # Integration tests only
python -m pytest -m "not slow"                  # Skip slow tests

# Run with coverage
python -m pytest --cov=src/playwrightauthor --cov-report=html

# Run specific test file
python -m pytest tests/unit/test_config.py -v

# Run specific test function
python -m pytest tests/unit/test_config.py::TestBrowserConfig::test_default_config -v
```

### Test Markers

```python
# Slow tests (network operations, downloads)
@pytest.mark.slow
def test_chrome_download():
    pass

# Tests requiring network access
@pytest.mark.network
def test_api_call():
    pass

# Tests requiring GUI (not in CI)
@pytest.mark.gui
def test_visual_features():
    pass

# Platform-specific tests
@pytest.mark.windows
@pytest.mark.macos
@pytest.mark.linux
def test_platform_feature():
    pass
```

## Documentation

### Documentation Structure

Documentation is built with MkDocs Material:

```
src_docs/
├── mkdocs.yml
└── md/
    ├── index.md
    ├── getting-started.md
    ├── basic-usage.md
    └── ...
```

### Building Documentation

```bash
# Install documentation dependencies
uv add --dev mkdocs mkdocs-material mkdocstrings[python]

# Serve documentation locally
cd src_docs
mkdocs serve

# Build documentation
mkdocs build

# Deploy to GitHub Pages
mkdocs gh-deploy
```

### Documentation Guidelines

**Writing Style**:
- Use clear, concise language
- Include practical examples
- Provide both simple and advanced usage patterns
- Cross-reference related topics

**Code Examples**:
```python
# ✅ Good: Complete, runnable example
from playwrightauthor import Browser

with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    title = page.title()
    print(f"Page title: {title}")

# ❌ Bad: Incomplete or unclear example
browser = Browser()
page.goto("example.com")
```

**Section Structure**:
```markdown
# Main Topic

Brief introduction explaining what this covers.

## Subsection

### Code Example
\```python
# Example code here
\```

### Explanation

Detailed explanation of the example.

### Common Issues

- Issue 1: Solution description
- Issue 2: Solution description

## Next Steps

- Link to [Related Topic](related.md)
- Check [Advanced Guide](advanced.md) for more
```

## Pull Request Process

### Before Submitting

**Checklist**:
- [ ] Code follows style guidelines
- [ ] Tests pass (`python -m pytest`)
- [ ] Type checking passes (`python -m mypy src/`)
- [ ] Linting passes (`python -m ruff check`)
- [ ] Documentation updated if needed
- [ ] `CHANGELOG.md` updated
- [ ] Commit messages follow conventional format

### Conventional Commits

Use conventional commit format:

```bash
# Feature additions
git commit -m "feat: add support for custom user agents"
git commit -m "feat(auth): implement GitHub OAuth integration"

# Bug fixes
git commit -m "fix: resolve Chrome download timeout on slow networks"
git commit -m "fix(browser): handle process cleanup on Windows"

# Documentation updates
git commit -m "docs: add troubleshooting guide for Docker"
git commit -m "docs(api): improve BrowserConfig examples"

# Refactoring
git commit -m "refactor: simplify browser connection logic"

# Performance improvements
git commit -m "perf: optimize Chrome process detection"

# Breaking changes
git commit -m "feat!: change default timeout from 30s to 60s"
```

### PR Template

When creating a pull request, include:

```markdown
## Description
Brief description of changes and motivation.

## Type of Change
- [ ] Bug fix (non-breaking change that fixes an issue)
- [ ] New feature (non-breaking change that adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to change)
- [ ] Documentation update

## Testing
- [ ] New tests added for new functionality
- [ ] All existing tests pass
- [ ] Manual testing performed

## Screenshots (if applicable)
Include screenshots for UI changes.

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-review of code completed
- [ ] Documentation updated
- [ ] Changes tested locally
```

### Code Review Process

**For Contributors**:
1. Address all feedback promptly
2. Keep discussions focused on the code
3. Be open to suggestions and improvements
4. Update PR based on review comments

**For Reviewers**:
1. Focus on code quality, not personal preferences
2. Provide constructive feedback with examples
3. Acknowledge good practices and improvements
4. Test changes locally when possible

## Release Process

### Version Management

PlaywrightAuthor uses semantic versioning (SemVer):

- **MAJOR** (X.0.0): Breaking changes
- **MINOR** (0.X.0): New features, backward compatible
- **PATCH** (0.0.X): Bug fixes, backward compatible

### Release Workflow

**For Maintainers**:

1. **Update Version**:
```bash
# Update version in pyproject.toml
# Update CHANGELOG.md with release notes
```

2. **Create Release**:
```bash
git tag v1.2.3
git push origin v1.2.3
```

3. **GitHub Actions** automatically:
   - Runs full test suite
   - Builds distributions
   - Publishes to PyPI
   - Creates GitHub release

## Community Guidelines

### Code of Conduct

- Be respectful and inclusive
- Welcome newcomers and help them learn
- Focus on constructive feedback
- Respect different perspectives and experiences

### Getting Help

- **GitHub Discussions**: General questions and ideas
- **GitHub Issues**: Bug reports and feature requests
- **Documentation**: Check existing docs first
- **Code**: Look at examples in the repository

### Reporting Issues

**Bug Reports**:
```markdown
## Description
Clear description of the bug.

## Steps to Reproduce
1. Step one
2. Step two
3. Expected vs actual behavior

## Environment
- OS: [e.g., macOS 13.0]
- Python: [e.g., 3.11.0]
- PlaywrightAuthor: [e.g., 1.0.0]
- Chrome: [e.g., 119.0.6045.105]

## Additional Context
Any other relevant information.
```

**Feature Requests**:
```markdown
## Feature Description
Clear description of the proposed feature.

## Use Case
Why is this feature needed? What problem does it solve?

## Proposed Solution
How do you envision this working?

## Alternatives Considered
What other solutions have you considered?
```

## Development Tips

### Debugging

```python
# Enable debug logging
import logging
logging.basicConfig(level=logging.DEBUG)

# Use verbose browser for visual debugging
from playwrightauthor import Browser, BrowserConfig

config = BrowserConfig(
    headless=False,
    chrome_args=["--auto-open-devtools-for-tabs"]
)

with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    page.pause()  # Opens Playwright Inspector
```

### Performance Testing

```python
# Simple performance benchmarking
import time
from playwrightauthor import Browser

def benchmark_operation():
    start = time.time()
    
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://example.com")
        # Operation to benchmark
    
    end = time.time()
    print(f"Operation took: {end - start:.2f} seconds")

benchmark_operation()
```

### Local Development

```bash
# Install in development mode
pip install -e .

# Run specific components
python -m playwrightauthor.cli status
python -m playwrightauthor.browser.finder

# Test with different Python versions
pyenv install 3.8.18 3.9.18 3.10.13 3.11.7
tox  # If tox.ini is configured
```

## Security

### Reporting Security Issues

**DO NOT** open public issues for security vulnerabilities.

Instead:
1. Email security@terragonlabs.com
2. Include detailed description
3. Provide reproduction steps if possible
4. Allow time for investigation before disclosure

### Security Best Practices

- Never commit secrets or credentials
- Use secure defaults in configuration
- Validate all user inputs
- Handle sensitive data carefully
- Follow principle of least privilege

## Thank You

Your contributions help make browser automation more accessible and reliable.

## Next Steps

- Review the [API Reference](api-reference.md) for implementation details
- Check [Troubleshooting](troubleshooting.md) for common development issues
- Join GitHub Discussions to connect with other contributors
</document_content>
</document>

<document index="50">
<source>src_docs/md/getting-started.md</source>
<document_content>
# Getting Started

## Installation

PlaywrightAuthor requires Python 3.8+ and is installed via pip:

```bash
pip install playwrightauthor
```

### Prerequisites

- **Python 3.8+** – For type hints and async support  
- **Chrome or Chromium** – Managed automatically by PlaywrightAuthor  
- **Network access** – To download Chrome for Testing if not found locally  

### System Requirements

| Platform | Requirements |
|----------|-------------|
| **Windows** | Windows 10+ (x64) |
| **macOS** | macOS 10.15+ (Intel or Apple Silicon) |
| **Linux** | Ubuntu 18.04+, CentOS 7+, or similar |

## Quick Start

### Your First Script

Create a basic automation script:

```python
# my_first_script.py
from playwrightauthor import Browser

def main():
    with Browser() as browser:
        page = browser.new_page()
        page.goto("https://example.com")
        title = page.title()
        print(f"Page title: {title}")

if __name__ == "__main__":
    main()
```

Run it:

```bash
python my_first_script.py
```

### What Happens Behind the Scenes

1. **Chrome Detection** – Checks for existing installations  
2. **Installation** – Downloads Chrome for Testing if needed (once)  
3. **Process Management** – Launches Chrome with remote debugging enabled  
4. **Connection** – Attaches Playwright to the browser  
5. **Authentication** – Uses a persistent profile for logged-in sessions  

### Async Version

Use this version if you're working with async code:

```python
import asyncio
from playwrightauthor import AsyncBrowser

async def main():
    async with AsyncBrowser() as browser:
        page = await browser.new_page()
        await page.goto("https://example.com")
        title = await page.title()
        print(f"Page title: {title}")

if __name__ == "__main__":
    asyncio.run(main())
```

## First Steps Checklist

- [ ] Install PlaywrightAuthor: `pip install playwrightauthor`  
- [ ] Run the example script  
- [ ] Confirm Chrome downloads and starts automatically  
- [ ] Navigate to a webpage successfully  
- [ ] Review the [Basic Usage](basic-usage.md) guide for more examples  

## Common First-Time Issues

### Permission Errors

On Linux/macOS, fix execution permissions for Chrome:

```bash
chmod +x ~/.cache/playwrightauthor/chrome/*/chrome
```

### Network Restrictions

If you're behind a proxy, configure environment variables:

```bash
export HTTP_PROXY=http://proxy.company.com:8080
export HTTPS_PROXY=http://proxy.company.com:8080
```

### Antivirus Software

Some antivirus tools may interfere with Chrome downloads. Add exceptions for:

- `~/.cache/playwrightauthor/` (Linux/macOS)  
- `%APPDATA%/playwrightauthor/` (Windows)  

## Next Steps

- [Basic Usage](basic-usage.md) – Core concepts and examples  
- [Configuration](configuration.md) – Settings and customization  
- [Authentication](authentication.md) – Login handling and sessions  
- [Advanced Features](advanced
</document_content>
</document>

<document index="51">
<source>src_docs/md/index.md</source>
<document_content>
# PlaywrightAuthor Documentation

PlaywrightAuthor is a convenience wrapper for Microsoft Playwright that automates browser setup and configuration.

## TL;DR

PlaywrightAuthor removes the tedious setup work from browser automation:

- **Installs and updates Chrome for Testing automatically**
- **Manages browser processes, including debug mode**
- **Persists user authentication across sessions**
- **Provides simple context managers for browser access**
- **Supports both sync and async operations**

```python
from playwrightauthor import Browser

# Simple synchronous usage
with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    # Browser is ready with authentication
```

## Documentation Chapters

### 1. [Getting Started](getting-started.md)
Installation, prerequisites, and your first script.

### 2. [Basic Usage](basic-usage.md)
Context managers and essential patterns.

### 3. [Configuration](configuration.md)
Settings and environment variables.

### 4. [Browser Management](browser-management.md)
Chrome installation and process handling.

### 5. [Authentication](authentication.md)
User profiles and session persistence.

### 6. [Advanced Features](advanced-features.md)
Async operations and performance tuning.

### 7. [Troubleshooting](troubleshooting.md)
Common issues and fixes.

### 8. [API Reference](api-reference.md)
Complete API documentation.

### 9. [Contributing](contributing.md)
Development setup and contribution guidelines.

## Quick Navigation

- **New to browser automation?** [Getting Started](getting-started.md)
- **Need authentication?** [Authentication](authentication.md)
- **Having issues?** [Troubleshooting](troubleshooting.md)
- **Looking for methods?** [API Reference](api-reference.md)
- **Want to contribute?** [Contributing](contributing.md)

## Key Features

- **Zero-config setup** - Works immediately after install
- **Authentication persistence** - No need to re-login every time
- **Cross-platform support** - Windows, macOS, Linux
- **Performance optimized** - Minimal overhead
- **Developer tools** - Logging and debugging included
</document_content>
</document>

<document index="52">
<source>src_docs/md/troubleshooting.md</source>
<document_content>
# Troubleshooting

This guide helps you diagnose and resolve common issues with PlaywrightAuthor. Problems are organized by category with practical solutions.

## Installation Issues

### Package Installation Problems

**Problem**: `pip install playwrightauthor` fails

**Solutions**:
```bash
# Update pip first
python -m pip install --upgrade pip

# Install with verbose output
pip install -v playwrightauthor

# Use alternative index
pip install -i https://pypi.org/simple/ playwrightauthor

# Install from source
pip install git+https://github.com/terragond/playwrightauthor.git
```

**Problem**: Import errors after installation

**Solutions**:
```python
# Verify installation
import sys
print(sys.path)

try:
    import playwrightauthor
    print(f"PlaywrightAuthor version: {playwrightauthor.__version__}")
except ImportError as e:
    print(f"Import error: {e}")

# Check dependencies
import playwright
print(f"Playwright version: {playwright.__version__}")
```

### Python Version Compatibility

**Problem**: PlaywrightAuthor doesn't work with your Python version

**Check Python version**:
```bash
python --version
# Requires 3.8 or higher
```

**Solutions**:
```bash
# Install compatible Python version
pyenv install 3.11
pyenv local 3.11

# Or use conda
conda create -n playwright python=3.11
conda activate playwright
pip install playwrightauthor
```

## Browser Download and Installation

### Chrome Download Failures

**Problem**: Chrome for Testing download fails

**Debugging**:
```python
from playwrightauthor.browser.installer import ChromeInstaller
import logging

# Enable debug logging
logging.basicConfig(level=logging.DEBUG)

installer = ChromeInstaller()
try:
    chrome_path = installer.install_latest()
    print(f"Chrome installed to: {chrome_path}")
except Exception as e:
    print(f"Download failed: {e}")
    # Check available versions
    versions = installer.get_available_versions()
    print(f"Available versions: {versions[:5]}")
```

**Solutions**:
```bash
# Manual Chrome installation
# Download from: https://googlechromelabs.github.io/chrome-for-testing/

# Set custom Chrome path
export PLAYWRIGHTAUTHOR_CHROME_PATH="/path/to/your/chrome"
```

**Problem**: Permission errors during download

**Solutions**:
```bash
# Linux/macOS: Fix permissions
chmod 755 ~/.cache/playwrightauthor/
chmod +x ~/.cache/playwrightauthor/chrome/*/chrome

# Windows: Run as administrator or change install directory
export PLAYWRIGHTAUTHOR_INSTALL_DIR="C:/Users/%USERNAME%/AppData/Local/PlaywrightAuthor"
```

### Network and Proxy Issues

**Problem**: Downloads fail behind corporate firewall

**Solutions**:
```bash
# Set proxy environment variables
export HTTP_PROXY=http://proxy.company.com:8080
export HTTPS_PROXY=http://proxy.company.com:8080
export NO_PROXY=localhost,127.0.0.1

# Or configure in Python
import os
os.environ['HTTP_PROXY'] = 'http://proxy.company.com:8080'
os.environ['HTTPS_PROXY'] = 'http://proxy.company.com:8080'
```

**Problem**: SSL certificate errors

**Solutions**:
```python
from playwrightauthor import BrowserConfig

# Disable SSL verification for downloads (security risk)
config = BrowserConfig(
    chrome_args=["--ignore-certificate-errors", "--ignore-ssl-errors"]
)
```

## Browser Launch Issues

### Port Conflicts

**Problem**: "Port 9222 already in use"

**Debugging**:
```python
from playwrightauthor.browser.process import get_chrome_processes

# Find what's using the port
processes = get_chrome_processes()
for proc in processes:
    print(f"PID: {proc.pid}, Command: {' '.join(proc.cmdline())}")
```

**Solutions**:
```python
from playwrightauthor import Browser, BrowserConfig

# Use different debug port
config = BrowserConfig(debug_port=9223)
with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")

# Or kill existing Chrome processes
from playwrightauthor.browser.process import kill_chrome_instances
kill_chrome_instances()
```

### Permission and Security Issues

**Problem**: Chrome won't start due to security restrictions

**Linux solutions**:
```bash
# Add Chrome to PATH
export PATH="/opt/google/chrome:$PATH"

# Fix sandbox issues
sudo sysctl kernel.unprivileged_userns_clone=1

# Or disable sandbox (less secure)
```

```python
config = BrowserConfig(
    chrome_args=["--no-sandbox", "--disable-setuid-sandbox"]
)
```

**Problem**: SELinux or AppArmor blocking Chrome

**Solutions**:
```bash
# Check SELinux status
sestatus

# Temporarily disable
sudo setenforce 0

# For AppArmor
sudo aa-complain /usr/bin/chromium-browser
```

### Docker and Container Issues

**Problem**: Chrome fails in Docker containers

**Solutions**:
```dockerfile
# Dockerfile additions
RUN apt-get update && apt-get install -y \
    wget \
    gnupg \
    ca-certificates \
    fonts-liberation \
    libasound2 \
    libatk-bridge2.0-0 \
    libdrm2 \
    libxcomposite1 \
    libxdamage1 \
    libxrandr2 \
    libgbm1 \
    libxkbcommon0 \
    libxss1
```

```python
# Docker-optimized configuration
config = BrowserConfig(
    headless=True,
    chrome_args=[
        "--no-sandbox",
        "--disable-dev-shm-usage",
        "--disable-gpu",
        "--disable-software-rasterizer",
        "--remote-debugging-address=0.0.0.0"
    ]
)
```

## Connection and Communication Issues

### WebSocket Connection Failures

**Problem**: "Failed to connect to Chrome"

**Debugging**:
```python
import requests

# Test Chrome debug port
port = 9222
try:
    response = requests.get(f"http://localhost:{port}/json/version", timeout=5)
    print(f"Chrome debug info: {response.json()}")
except Exception as e:
    print(f"Connection test failed: {e}")
```

**Solutions**:
```python
from playwrightauthor import Browser, BrowserConfig
import time

# Increase connection timeout
config = BrowserConfig(
    connect_timeout=30,
    connect_retries=5
)

# Retry connection
def connect_with_retry():
    for attempt in range(3):
        try:
            with Browser(config=config) as browser:
                return browser
        except Exception as e:
            print(f"Attempt {attempt + 1} failed: {e}")
            time.sleep(5)
    raise Exception("Failed to connect after retries")
```

### Browser Process Management

**Problem**: Chrome processes not terminating

**Debugging**:
```python
from playwrightauthor.browser.process import ChromeProcessManager
import psutil

manager = ChromeProcessManager()

# List Chrome processes
processes = manager.get_chrome_processes()
for proc in processes:
    try:
        print(f"PID: {proc.pid}, Status: {proc.status()}, Memory: {proc.memory_info().rss / 1024 / 1024:.1f}MB")
    except psutil.NoSuchProcess:
        print(f"Process {proc.pid} no longer exists")
```

**Solutions**:
```python
from playwrightauthor.browser.process import force_kill_chrome

# Force kill Chrome processes
force_kill_chrome()

# Or graceful shutdown
manager = ChromeProcessManager()
manager.shutdown_all_chrome(graceful=True, timeout=10)
```

## Authentication and Session Issues

### Session Not Persisting

**Problem**: Authentication doesn't persist between runs

**Debugging**:
```python
from pathlib import Path

# Check profile directory
profile_dir = Path.home() / ".cache" / "playwrightauthor" / "profile"
print(f"Profile directory: {profile_dir}")
print(f"Profile exists: {profile_dir.exists()}")

if profile_dir.exists():
    files = list(profile_dir.glob("**/*"))
    print(f"Profile files: {len(files)}")
```

**Solutions**:
```python
# Ensure profile directory is writable
import os
from pathlib import Path

profile_dir = Path.home() / ".playwrightauthor" / "profiles" / "main"
profile_dir.mkdir(parents=True, exist_ok=True)
os.chmod(profile_dir, 0o755)

config = BrowserConfig(user_data_dir=str(profile_dir))

with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://github.com/login")
    # Complete authentication
    input("Press Enter after logging in...")
    
    # Verify session
    cookies = page.context.cookies()
    print(f"Saved {len(cookies)} cookies")
```

### Cookie and Storage Issues

**Problem**: Cookies not being saved or loaded

**Debugging**:
```python
from playwrightauthor import Browser

with Browser() as browser:
    page = browser.new_page()
    page.goto("https://httpbin.org/cookies/set/test/value")
    
    # Check cookies
    cookies = page.context.cookies()
    print(f"Current cookies: {cookies}")
    
    # Test persistence
    page.goto("https://httpbin.org/cookies")
    response = page.text_content("body")
    print(f"Cookie response: {response}")
```

**Solutions**:
```python
# Manual cookie management
with Browser() as browser:
    context = browser.contexts[0]
    
    # Save cookies
    cookies = context.cookies()
    import json
    with open("cookies.json", "w") as f:
        json.dump(cookies, f)
    
    # Load cookies
    with open("cookies.json", "r") as f:
        saved_cookies = json.load(f)
    context.add_cookies(saved_cookies)
```

## Performance Issues

### Slow Browser Operations

**Problem**: Browser operations are slow

**Debugging**:
```python
import time
from playwrightauthor import Browser

with Browser() as browser:
    page = browser.new_page()
    
    start = time.time()
    page.goto("https://example.com")
    navigation_time = time.time() - start
    
    print(f"Navigation took: {navigation_time:.2f} seconds")
```

**Solutions**:
```python
# Optimize browser configuration
config = BrowserConfig(
    headless=True,
    chrome_args=[
        "--disable-images",
        "--disable-javascript",
        "--disable-plugins",
        "--disable-extensions",
        "--no-first-run",
        "--disable-default-apps"
    ]
)

# Optimize page loading
with Browser(config=config) as browser:
    page = browser.new_page()
    
    # Block unnecessary resources
    page.route("**/*.{png,jpg,jpeg,gif,svg}", lambda route: route.abort())
    page.route("**/*.{css}", lambda route: route.abort())
    
    page.goto("https://example.com", wait_until="domcontentloaded")
```

### Memory Issues

**Problem**: High memory usage

**Debugging**:
```python
import psutil
import os
from playwrightauthor import Browser

def get_memory_usage():
    process = psutil.Process(os.getpid())
    return process.memory_info().rss / 1024 / 1024

print(f"Initial memory: {get_memory_usage():.1f} MB")

with Browser() as browser:
    print(f"After browser creation: {get_memory_usage():.1f} MB")
    
    for i in range(10):
        page = browser.new_page()
        page.goto("https://example.com")
        page.close()
        print(f"After page {i+1}: {get_memory_usage():.1f} MB")
```

**Solutions**:
```python
# Proper resource cleanup
with Browser() as browser:
    for url in urls:
        page = browser.new_page()
        try:
            page.goto(url)
        finally:
            page.close()

# Limit concurrent pages
from playwrightauthor.utils import PagePool

pool = PagePool(max_pages=5)
with Browser() as browser:
    for url in urls:
        with pool.get_page(browser) as page:
            page.goto(url)
```

## Error Messages and Debugging

### Common Error Messages

**"TimeoutError: waiting for selector"**
```python
# Increase timeout
page.wait_for_selector("#element", timeout=60000)

# Use better selectors
page.wait_for_selector("text=Submit")
page.wait_for_selector("[data-testid='submit']")

# Check element exists
if page.query_selector("#element"):
    page.click("#element")
```

**"Browser has been closed"**
```python
# Check browser state
if browser.is_connected():
    page = browser.new_page()
```

**"Connection refused"**
```python
# Verify Chrome is running
from playwrightauthor.browser.process import is_chrome_debug_running

if not is_chrome_debug_running():
    print("Chrome debug server not running")
```

### Debug Logging

Enable logging:
```python
import logging
from playwrightauthor import Browser

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('playwright_debug.log'),
        logging.StreamHandler()
    ]
)

# Enable Playwright debug
import os
os.environ['DEBUG'] = 'pw:api,pw:browser'

with Browser() as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

### Visual Debugging

```python
from playwrightauthor import Browser, BrowserConfig

# Show browser for debugging
config = BrowserConfig(
    headless=False,
    chrome_args=["--auto-open-devtools-for-tabs"]
)

with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
    
    # Pause for inspection
    page.pause()
    
    # Take screenshots
    page.screenshot(path="step1.png")
    page.click("button")
    page.screenshot(path="step2.png")
```

## Platform-Specific Issues

### Windows Issues

**Problem**: Chrome fails to start

**Solutions**:
```python
# Use Windows Chrome path
config = BrowserConfig(
    chrome_path=r"C:\Program Files\Google\Chrome\Application\chrome.exe"
)

# Handle Windows path issues
import os
if os.name == 'nt':
    config.chrome_args.append("--disable-features=VizDisplayCompositor")
```

### macOS Issues

**Problem**: Permission denied

**Solutions**:
```bash
# Grant Chrome permissions
xattr -d com.apple.quarantine /Applications/Google\ Chrome.app

# Or install via Homebrew
brew install --cask google-chrome
```

### Linux Issues

**Problem**: Missing dependencies

**Solutions**:
```bash
# Install required packages
sudo apt-get update && sudo apt-get install -y \
    libnss3 \
    libatk-bridge2.0-0 \
    libdrm2 \
    libxcomposite1 \
    libxdamage1 \
    libxrandr2 \
    libgbm1 \
    libxss1 \
    libasound2

# For headless systems
sudo apt-get install -y xvfb
export DISPLAY=:99
Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
```

## Getting Help

### Diagnostic Information

```python
from playwrightauthor.diagnostics import collect_diagnostic_info

# Collect system info
info = collect_diagnostic_info()
print(info)
```

### Enable Debug Mode

```python
from playwrightauthor import Browser, BrowserConfig

config = BrowserConfig(
    log_level="DEBUG",
    verbose=True
)

with Browser(config=config) as browser:
    page = browser.new_page()
    page.goto("https://example.com")
```

### Creating Bug Reports

Include this information:
1. **System**: OS, Python version, PlaywrightAuthor version, Chrome version
2. **Configuration**: Browser config, environment variables, arguments
3. **Error**: Complete message, stack trace, debug logs
4. **Behavior**: Expected vs actual results, workarounds

```python
# Diagnostic script for bug reports
import sys
import platform
import playwrightauthor

print("=== System Information ===")
print(f"OS: {platform.system()} {platform.release()}")
print(f"Python: {sys.version}")
print(f"PlaywrightAuthor: {playwrightauthor.__version__}")

print("\n=== Chrome Information ===")
from playwrightauthor.browser.finder import find_chrome
try:
    chrome_path = find_chrome()
    print(f"Chrome path: {chrome_path}")
except Exception as e:
    print(f"Chrome not found: {e}")

print("\n=== Configuration ===")
import os
env_vars = [k for k in os.environ.keys() if k.startswith('PLAYWRIGHTAUTHOR_')]
for var in env_vars:
    print(f"{var}: {os.environ[var]}")
```

## Next Steps

- Review [API Reference](api-reference.md) for method documentation
- Check [Contributing](contributing.md) to report bugs
- Visit [GitHub Issues](https://github.com/terragond/playwrightauthor/issues) for known problems
- Join community discussions for support
</document_content>
</document>

<document index="53">
<source>src_docs/mkdocs.yml</source>
<document_content>
site_name: PlaywrightAuthor Documentation
site_description: Convenience package for Microsoft Playwright that handles browser automation setup
site_author: Terragon Labs
site_url: https://terragond.github.io/playwrightauthor/

repo_name: terragond/playwrightauthor
repo_url: https://github.com/terragond/playwrightauthor
edit_uri: edit/main/src_docs/md/

theme:
  name: material
  palette:
    # Palette toggle for light mode
    - scheme: default
      toggle:
        icon: material/brightness-7
        name: Switch to dark mode
    # Palette toggle for dark mode
    - scheme: slate
      toggle:
        icon: material/brightness-4
        name: Switch to light mode
  features:
    - navigation.tabs
    - navigation.sections
    - navigation.expand
    - navigation.path
    - navigation.top
    - search.highlight
    - search.suggest
    - content.code.copy
    - content.code.annotate

markdown_extensions:
  - pymdownx.highlight:
      anchor_linenums: true
  - pymdownx.inlinehilite
  - pymdownx.snippets
  - admonition
  - pymdownx.arithmatex:
      generic: true
  - footnotes
  - pymdownx.details
  - pymdownx.superfences
  - pymdownx.mark
  - attr_list
  - md_in_html

plugins:
  - search
  - mkdocstrings:
      handlers:
        python:
          paths: [../src]

docs_dir: md
site_dir: ../docs

nav:
  - Home: index.md
  - Getting Started: getting-started.md
  - Basic Usage: basic-usage.md
  - Configuration: configuration.md
  - Browser Management: browser-management.md
  - Authentication: authentication.md
  - Advanced Features: advanced-features.md
  - Troubleshooting: troubleshooting.md
  - API Reference: api-reference.md
  - Contributing: contributing.md

extra:
  social:
    - icon: fontawesome/brands/github
      link: https://github.com/terragond/playwrightauthor
</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_author.py
# Language: python

import pytest
from playwrightauthor import AsyncBrowser, Browser

def test_browser_smoke(()):
    """A basic smoke test to ensure the Browser class can be instantiated."""

def test_async_browser_smoke(()):
    """A basic smoke test to ensure the AsyncBrowser class can be instantiated."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_benchmark.py
# Language: python

import pytest
from playwrightauthor.browser_manager import ensure_browser

def test_benchmark_ensure_browser((benchmark)):
    """Benchmark the ensure_browser function."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_doctests.py
# Language: python

import doctest
import importlib
import sys
from pathlib import Path
import pytest
import playwrightauthor.author
import playwrightauthor.config
import playwrightauthor.cli
import playwrightauthor.repl.engine

def test_author_doctests(()):
    """Test doctests in author.py module."""

def test_config_doctests(()):
    """Test doctests in config.py module."""

def test_cli_doctests(()):
    """Test doctests in cli.py module."""

def test_repl_engine_doctests(()):
    """Test doctests in repl/engine.py module."""

def test_all_doctests_comprehensive(()):
    """ Comprehensive doctest runner for all modules...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_integration.py
# Language: python

import asyncio
import sys
import time
from pathlib import Path
from unittest.mock import patch
import pytest
from playwrightauthor import AsyncBrowser, Browser
from playwrightauthor.browser.finder import find_chrome_executable, get_chrome_version
from playwrightauthor.browser.process import get_chrome_process
from playwrightauthor.browser_manager import ensure_browser
from playwrightauthor.exceptions import BrowserManagerError
from playwrightauthor.utils.logger import configure
from playwrightauthor.utils.paths import install_dir

class TestBrowserIntegration:
    """Integration tests for synchronous Browser class."""
    def test_browser_cookies_persistence((self)):
        """Test that cookies persist across browser sessions."""

class TestAsyncBrowserIntegration:
    """Integration tests for asynchronous AsyncBrowser class."""
    def _create_and_navigate_page((self, browser, index)):
        """Helper to create and navigate a page."""

class TestBrowserManagerIntegration:
    """Integration tests for browser management functionality."""
    def test_ensure_browser_creates_paths((self, logger)):
        """Test that ensure_browser creates necessary directories."""
    def test_chrome_process_detection((self, logger)):
        """Test Chrome process detection functionality."""
    def test_chrome_version_detection((self, logger)):
        """Test Chrome version detection."""

class TestCrossPlatformIntegration:
    """Cross-platform integration tests."""
    def test_platform_specific_paths((self, logger)):
        """Test that platform-specific paths are correctly determined."""
    def test_chrome_finder_logging((self, logger, capsys)):
        """Test that Chrome finder provides useful logging."""

class TestEndToEndScenarios:
    """End-to-end integration scenarios."""
    def test_browser_restart_resilience((self)):
        """Test that browser can be restarted multiple times."""

class TestErrorHandlingIntegration:
    """Integration tests for error handling."""
    def test_browser_handles_network_errors((self)):
        """Test browser behavior with network errors."""

class TestPerformanceBenchmarks:
    """Performance benchmarks for the library."""

def logger(()):
    """Provide a test logger."""

def test_browser_basic_usage((self)):
    """Test basic Browser usage with page navigation."""

def test_browser_multiple_pages((self)):
    """Test managing multiple pages."""

def test_browser_cookies_persistence((self)):
    """Test that cookies persist across browser sessions."""

def test_async_browser_basic_usage((self)):
    """Test basic AsyncBrowser usage."""

def test_async_browser_concurrent_pages((self)):
    """Test concurrent page operations with AsyncBrowser."""

def _create_and_navigate_page((self, browser, index)):
    """Helper to create and navigate a page."""

def test_ensure_browser_creates_paths((self, logger)):
    """Test that ensure_browser creates necessary directories."""

def test_chrome_process_detection((self, logger)):
    """Test Chrome process detection functionality."""

def test_chrome_version_detection((self, logger)):
    """Test Chrome version detection."""

def test_platform_specific_paths((self, logger)):
    """Test that platform-specific paths are correctly determined."""

def test_chrome_finder_logging((self, logger, capsys)):
    """Test that Chrome finder provides useful logging."""

def test_full_workflow((self)):
    """Test complete workflow from browser setup to page automation."""

def test_browser_restart_resilience((self)):
    """Test that browser can be restarted multiple times."""

def test_browser_handles_network_errors((self)):
    """Test browser behavior with network errors."""

def test_browser_handles_missing_chrome((self, mock_find)):
    """Test behavior when Chrome is not found."""

def test_browser_startup_time((self, benchmark)):
    """Benchmark browser startup time."""

def start_browser(()):

def test_page_creation_time((self, benchmark)):
    """Benchmark page creation time."""

def create_page(()):


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_platform_specific.py
# Language: python

import os
import platform
import subprocess
import sys
import tempfile
from pathlib import Path
from unittest.mock import MagicMock, patch
import pytest
from playwrightauthor.browser.finder import (
    _get_linux_chrome_paths,
    _get_macos_chrome_paths,
    _get_windows_chrome_paths,
    find_chrome_executable,
    get_chrome_version,
)
from playwrightauthor.utils.logger import configure
from playwrightauthor.browser_manager import _DEBUGGING_PORT

class TestPlatformSpecificChromeFinding:
    """Test Chrome finding functionality on different platforms."""
    def setup_method((self)):
        """Set up test logger."""
    def test_find_chrome_executable_with_logger((self)):
        """Test find_chrome_executable with logging enabled."""
    def test_find_chrome_unsupported_platform((self)):
        """Test Chrome finding on unsupported platform."""

class TestPlatformSpecificPaths:
    """Test platform-specific path handling."""

class TestCrossplatformCompatibility:
    """Test cross-platform compatibility features."""
    def test_path_handling((self)):
        """Test that Path objects are used consistently."""
    def test_environment_variable_handling((self)):
        """Test environment variable handling across platforms."""
    def test_home_directory_expansion((self)):
        """Test home directory handling."""

class TestIntegrationPlatformSpecific:
    """Integration tests for platform-specific functionality."""
    def test_real_chrome_finding((self)):
        """Test finding Chrome on the actual system."""
    def test_browser_manager_integration((self)):
        """Test integration with browser_manager module."""

def setup_method((self)):
    """Set up test logger."""

def test_windows_chrome_paths((self)):
    """Test Windows Chrome path generation."""

def test_macos_chrome_paths((self)):
    """Test macOS Chrome path generation."""

def test_linux_chrome_paths((self)):
    """Test Linux Chrome path generation."""

def test_find_chrome_executable_with_logger((self)):
    """Test find_chrome_executable with logging enabled."""

def test_get_chrome_version_success((self, mock_run)):
    """Test successful Chrome version retrieval."""

def test_get_chrome_version_failure((self, mock_run)):
    """Test Chrome version retrieval failure."""

def test_get_chrome_version_timeout((self, mock_run)):
    """Test Chrome version retrieval timeout."""

def test_find_chrome_unsupported_platform((self)):
    """Test Chrome finding on unsupported platform."""

def test_executable_permissions_check((self)):
    """Test that executable permissions are checked on Unix systems."""

def mock_paths(()):

def test_windows_where_command((self)):
    """Test Windows 'where' command integration."""

def test_linux_which_command((self)):
    """Test Linux 'which' command integration."""

def test_path_handling((self)):
    """Test that Path objects are used consistently."""

def test_environment_variable_handling((self)):
    """Test environment variable handling across platforms."""

def test_home_directory_expansion((self)):
    """Test home directory handling."""

def test_real_chrome_finding((self)):
    """Test finding Chrome on the actual system."""

def test_browser_manager_integration((self)):
    """Test integration with browser_manager module."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_utils.py
# Language: python

import sys
from pathlib import Path
from unittest.mock import patch
from playwrightauthor.utils.logger import configure
from playwrightauthor.utils.paths import install_dir
from loguru import logger
from loguru import logger
from loguru import logger

class TestPaths:
    """Test suite for utils.paths module."""
    def test_install_dir_returns_path((self)):
        """Test that install_dir() returns a Path object."""
    def test_install_dir_contains_app_name((self)):
        """Test that install_dir() contains the application name."""
    def test_install_dir_contains_browser_subdir((self)):
        """Test that install_dir() includes 'browser' subdirectory."""
    def test_install_dir_is_absolute((self)):
        """Test that install_dir() returns an absolute path."""
    def test_install_dir_consistent((self)):
        """Test that multiple calls to install_dir() return the same path."""

class TestLogger:
    """Test suite for utils.logger module."""
    def setup_method((self)):
        """Set up test fixtures."""
    def teardown_method((self)):
        """Clean up after tests."""
    def test_configure_returns_logger((self)):
        """Test that configure() returns a logger object."""
    def test_configure_verbose_false((self)):
        """Test configure() with verbose=False sets INFO level."""
    def test_configure_verbose_true((self)):
        """Test configure() with verbose=True sets DEBUG level."""
    def test_configure_removes_existing_handlers((self)):
        """Test that configure() removes existing loguru handlers."""
    def test_configure_consistent_logger((self)):
        """Test that multiple calls to configure() return the same logger."""
    def test_configure_logging_levels((self)):
        """Test different logging levels work correctly."""

class TestUtilsIntegration:
    """Integration tests for utils modules."""
    def test_logger_can_log_to_install_dir_path((self)):
        """Test that logger can handle Path objects from install_dir()."""
    def test_paths_work_with_different_platforms((self)):
        """Test that paths work across different platform scenarios."""

def test_install_dir_returns_path((self)):
    """Test that install_dir() returns a Path object."""

def test_install_dir_contains_app_name((self)):
    """Test that install_dir() contains the application name."""

def test_install_dir_contains_browser_subdir((self)):
    """Test that install_dir() includes 'browser' subdirectory."""

def test_install_dir_is_absolute((self)):
    """Test that install_dir() returns an absolute path."""

def test_install_dir_consistent((self)):
    """Test that multiple calls to install_dir() return the same path."""

def test_install_dir_with_custom_cache_dir((self, mock_cache_dir)):
    """Test install_dir() with a custom cache directory."""

def setup_method((self)):
    """Set up test fixtures."""

def teardown_method((self)):
    """Clean up after tests."""

def test_configure_returns_logger((self)):
    """Test that configure() returns a logger object."""

def test_configure_verbose_false((self)):
    """Test configure() with verbose=False sets INFO level."""

def test_configure_verbose_true((self)):
    """Test configure() with verbose=True sets DEBUG level."""

def test_configure_removes_existing_handlers((self)):
    """Test that configure() removes existing loguru handlers."""

def test_configure_consistent_logger((self)):
    """Test that multiple calls to configure() return the same logger."""

def test_configure_logging_levels((self)):
    """Test different logging levels work correctly."""

def test_logger_can_log_to_install_dir_path((self)):
    """Test that logger can handle Path objects from install_dir()."""

def test_paths_work_with_different_platforms((self)):
    """Test that paths work across different platform scenarios."""


</documents>