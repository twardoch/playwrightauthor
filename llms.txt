Project Structure:
üìÅ playwrightauthor
‚îú‚îÄ‚îÄ üìÅ .github
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ workflows
‚îÇ       ‚îî‚îÄ‚îÄ üìÑ ci.yml
‚îú‚îÄ‚îÄ üìÅ old
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ google_docs_scraper_simple.py
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ playwrightauthor.md
‚îú‚îÄ‚îÄ üìÅ src
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ playwrightauthor
‚îÇ       ‚îú‚îÄ‚îÄ üìÅ browser
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ finder.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ installer.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ launcher.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ process.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÅ templates
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ onboarding.html
‚îÇ       ‚îú‚îÄ‚îÄ üìÅ utils
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ logger.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ paths.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÑ __main__.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÑ author.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÑ browser_manager.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÑ cli.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÑ config.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÑ exceptions.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÑ lazy_imports.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÑ onboarding.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÑ state_manager.py
‚îÇ       ‚îî‚îÄ‚îÄ üìÑ typing.py
‚îú‚îÄ‚îÄ üìÅ tests
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ test_author.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ test_benchmark.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ test_integration.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ test_platform_specific.py
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ test_utils.py
‚îú‚îÄ‚îÄ üìÑ .gitignore
‚îú‚îÄ‚îÄ üìÑ AGENTS.md
‚îú‚îÄ‚îÄ üìÑ CHANGELOG.md
‚îú‚îÄ‚îÄ üìÑ CLAUDE.md
‚îú‚îÄ‚îÄ üìÑ GEMINI.md
‚îú‚îÄ‚îÄ üìÑ LICENSE
‚îú‚îÄ‚îÄ üìÑ PLAN.md
‚îú‚îÄ‚îÄ üìÑ publish.sh
‚îú‚îÄ‚îÄ üìÑ pyproject.toml
‚îú‚îÄ‚îÄ üìÑ README.md
‚îú‚îÄ‚îÄ üìÑ TODO.md
‚îî‚îÄ‚îÄ üìÑ WORK.md


<documents>
<document index="1">
<source>.cursorrules</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

PlaywrightAuthor is a convenience package for Microsoft Playwright that handles browser automation setup. It automatically manages Chrome for Testing installation, authentication with user profiles, and provides ready-to-use Browser objects through simple context managers.

## 2. Key Architecture

**Core Design Pattern**: The library follows a context manager pattern with `Browser()` and `AsyncBrowser()` classes that return authenticated Playwright browser objects.

**Main Components** (planned structure):
- `playwrightauthor/author.py` - Core Browser/AsyncBrowser classes (main API)
- `playwrightauthor/browser_manager.py` - Chrome installation/process management 
- `playwrightauthor/onboarding.py` - User guidance for authentication
- `playwrightauthor/cli.py` - Fire-powered CLI interface
- `playwrightauthor/utils/` - Logger and cross-platform path utilities

**Current State**: The project is in early development. The main implementation exists as a legacy scraper in `old/google_docs_scraper_simple.py` that demonstrates the core concept of connecting to an existing Chrome debug session.

## 3. Development Commands

### 3.1. Environment Setup
```bash
# Initial setup with uv
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add playwright rich fire loguru platformdirs requests psutil
```

### 3.2. Code Quality Pipeline
After any Python changes, run:
```bash
fd -e py -x uvx autoflake -i {}; \
fd -e py -x uvx pyupgrade --py312-plus {}; \
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
python -m pytest
```

### 3.3. Testing
- Run tests: `python -m pytest`
- Tests are located in `tests/` directory
- Current tests may be integration tests requiring live Chrome instance

### 3.4. CLI Usage
Once implemented:
```bash
python -m playwrightauthor status  # Check browser status
```

## 4. Code Standards

- **File headers**: Every Python file should include a `this_file:` comment with the relative path
- **Dependencies**: Use uv script headers with `# /// script` blocks
- **Type hints**: Use modern Python type hints (list, dict, | for unions)
- **Logging**: Use loguru with verbose flag support
- **CLI**: Use Fire for command-line interfaces with Rich for output

## 5. Browser Management Strategy

The core technical challenge is reliably managing Chrome for Testing:

1. **Detection**: Check if Chrome is running with `--remote-debugging-port=9222`
2. **Installation**: Prefer `npx puppeteer browsers install`, fallback to LKGV JSON downloads
3. **Process Management**: Kill non-debug instances, launch with persistent user-data-dir
4. **Connection**: Use Playwright's `connect_over_cdp()` to attach to debug session

## 6. Project Workflow

The project follows a documentation-driven development approach:
1. Read `WORK.md` and `PLAN.md` before making changes
2. Update documentation files after implementation
3. Use "Wait, but" reflection methodology for code review
4. Maintain minimal, self-contained commits

## 7. Dependencies

Core runtime dependencies:
- `playwright` - Browser automation
- `rich` - Terminal output formatting  
- `fire` - CLI generation
- `loguru` - Logging
- `platformdirs` - Cross-platform paths
- `requests` - HTTP client for downloads
- `psutil` - Process management

# Software Development Rules

## 8. Pre-Work Preparation

### 8.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 8.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 9. General Coding Principles

### 9.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 9.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 10. Tool Usage (When Available)

### 10.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 11. File Management

### 11.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 12. Python-Specific Guidelines

### 12.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 12.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 12.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 12.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 13. Post-Work Activities

### 13.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 13.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 14. Work Methodology

### 14.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 14.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 15. Special Commands

### 15.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 15.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 15.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 16. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 17. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate


</document_content>
</document>

<document index="2">
<source>.github/workflows/ci.yml</source>
<document_content>
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  UV_CACHE_DIR: /tmp/.uv-cache

jobs:
  test:
    name: Test on ${{ matrix.os }} (Python ${{ matrix.python-version }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ["3.12"]
        include:
          # Test on older macOS with x64 architecture
          - os: macos-13
            python-version: "3.12"

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for git-based versioning

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install uv
      uses: astral-sh/setup-uv@v4
      with:
        enable-cache: true
        cache-dependency-glob: |
          **/pyproject.toml
          **/requirements*.txt

    - name: Cache uv dependencies
      uses: actions/cache@v4
      with:
        path: ${{ env.UV_CACHE_DIR }}
        key: uv-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/pyproject.toml') }}
        restore-keys: |
          uv-${{ runner.os }}-${{ matrix.python-version }}-

    - name: Install dependencies
      run: |
        uv venv
        uv pip install -e ".[dev]"
        uv pip install pytest pytest-cov pytest-timeout pytest-xdist

    - name: Install Playwright browsers
      run: |
        uv run playwright install chromium
        uv run playwright install-deps chromium

    - name: Run linting
      run: |
        uv run ruff check src tests
        uv run ruff format --check src tests

    - name: Run type checking
      if: matrix.os == 'ubuntu-latest'  # Only run on one platform to save time
      run: |
        uv pip install mypy types-requests
        uv run mypy src --ignore-missing-imports

    - name: Run tests with coverage
      run: |
        uv run pytest tests/ -v --cov=src/playwrightauthor --cov-report=xml --cov-report=term --timeout=120
      env:
        PYTHONPATH: ${{ github.workspace }}/src

    - name: Test Chrome finding functionality
      run: |
        uv run python -c "from playwrightauthor.browser.finder import find_chrome_executable; from playwrightauthor.utils.logger import configure; logger = configure(True); path = find_chrome_executable(logger); print(f'Chrome found: {path}')"

    - name: Upload coverage to Codecov
      if: matrix.os == 'ubuntu-latest' && matrix.python-version == '3.12'
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

  integration-test:
    name: Integration Test on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Install uv
      uses: astral-sh/setup-uv@v4
      with:
        enable-cache: true

    - name: Install package
      run: |
        uv venv
        uv pip install -e .

    - name: Test CLI commands
      run: |
        uv run playwrightauthor --help
        uv run playwrightauthor status --verbose

    - name: Test browser installation
      run: |
        uv run python -m playwrightauthor.browser_manager --verbose
      continue-on-error: true  # Browser might already be installed

  build:
    name: Build distribution
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build hatch hatchling hatch-vcs

    - name: Build package
      run: python -m build

    - name: Check package
      run: |
        pip install twine
        twine check dist/*

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: dist
        path: dist/

  release:
    name: Release
    needs: [test, integration-test, build]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - uses: actions/checkout@v4

    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        name: dist
        path: dist/

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        files: dist/*
        generate_release_notes: true
        draft: false
        prerelease: ${{ contains(github.ref, 'rc') || contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}

    - name: Publish to PyPI
      if: "!contains(github.ref, 'rc') && !contains(github.ref, 'beta') && !contains(github.ref, 'alpha')"
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
      run: |
        pip install twine
        twine upload dist/*

</document_content>
</document>

<document index="3">
<source>.gitignore</source>
<document_content>

__marimo__/
__pycache__/
__pypackages__/
.abstra/
.cache
.coverage
.coverage.*
.cursorignore
.cursorindexingignore
.dmypy.json
.DS_Store
.eggs/
.env
.envrc
.hypothesis/
.installed.cfg
.ipynb_checkpoints
.mypy_cache/
.nox/
.pdm-build/
.pdm-python
.pixi
.pybuilder/
.pypirc
.pyre/
.pytest_cache/
.Python
.pytype/
.ropeproject
.ruff_cache/
.scrapy
.spyderproject
.spyproject
.tox/
.venv
.webassets-cache
*.cover
*.egg
*.egg-info/
*.log
*.manifest
*.mo
*.pot
*.py.cover
*.py[codz]
*.sage.py
*.so
*.spec
*$py.class
/site
uv.lock
build/
celerybeat-schedule
celerybeat.pid
cover/
coverage.xml
cython_debug/
db.sqlite3
db.sqlite3-journal
develop-eggs/
dist/
dmypy.json
docs/_build/
downloads/
eggs/
env.bak/
env/
ENV/
htmlcov/
instance/
ipython_config.py
lib/
lib64/
local_settings.py
MANIFEST
marimo/_lsp/
marimo/_static/
nosetests.xml
parts/
pip-delete-this-directory.txt
pip-log.txt
profile_default/
sdist/
share/python-wheels/
src/playwrightauthor/_version.py
target/
var/
venv.bak/
venv/
wheels/
</document_content>
</document>

<document index="4">
<source>AGENTS.md</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

PlaywrightAuthor is a convenience package for Microsoft Playwright that handles browser automation setup. It automatically manages Chrome for Testing installation, authentication with user profiles, and provides ready-to-use Browser objects through simple context managers.

## 2. Key Architecture

**Core Design Pattern**: The library follows a context manager pattern with `Browser()` and `AsyncBrowser()` classes that return authenticated Playwright browser objects.

**Main Components** (planned structure):
- `playwrightauthor/author.py` - Core Browser/AsyncBrowser classes (main API)
- `playwrightauthor/browser_manager.py` - Chrome installation/process management 
- `playwrightauthor/onboarding.py` - User guidance for authentication
- `playwrightauthor/cli.py` - Fire-powered CLI interface
- `playwrightauthor/utils/` - Logger and cross-platform path utilities

**Current State**: The project is in early development. The main implementation exists as a legacy scraper in `old/google_docs_scraper_simple.py` that demonstrates the core concept of connecting to an existing Chrome debug session.

## 3. Development Commands

### 3.1. Environment Setup
```bash
# Initial setup with uv
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add playwright rich fire loguru platformdirs requests psutil
```

### 3.2. Code Quality Pipeline
After any Python changes, run:
```bash
fd -e py -x uvx autoflake -i {}; \
fd -e py -x uvx pyupgrade --py312-plus {}; \
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
python -m pytest
```

### 3.3. Testing
- Run tests: `python -m pytest`
- Tests are located in `tests/` directory
- Current tests may be integration tests requiring live Chrome instance

### 3.4. CLI Usage
Once implemented:
```bash
python -m playwrightauthor status  # Check browser status
```

## 4. Code Standards

- **File headers**: Every Python file should include a `this_file:` comment with the relative path
- **Dependencies**: Use uv script headers with `# /// script` blocks
- **Type hints**: Use modern Python type hints (list, dict, | for unions)
- **Logging**: Use loguru with verbose flag support
- **CLI**: Use Fire for command-line interfaces with Rich for output

## 5. Browser Management Strategy

The core technical challenge is reliably managing Chrome for Testing:

1. **Detection**: Check if Chrome is running with `--remote-debugging-port=9222`
2. **Installation**: Prefer `npx puppeteer browsers install`, fallback to LKGV JSON downloads
3. **Process Management**: Kill non-debug instances, launch with persistent user-data-dir
4. **Connection**: Use Playwright's `connect_over_cdp()` to attach to debug session

## 6. Project Workflow

The project follows a documentation-driven development approach:
1. Read `WORK.md` and `PLAN.md` before making changes
2. Update documentation files after implementation
3. Use "Wait, but" reflection methodology for code review
4. Maintain minimal, self-contained commits

## 7. Dependencies

Core runtime dependencies:
- `playwright` - Browser automation
- `rich` - Terminal output formatting  
- `fire` - CLI generation
- `loguru` - Logging
- `platformdirs` - Cross-platform paths
- `requests` - HTTP client for downloads
- `psutil` - Process management

# Software Development Rules

## 8. Pre-Work Preparation

### 8.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 8.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 9. General Coding Principles

### 9.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 9.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 10. Tool Usage (When Available)

### 10.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 11. File Management

### 11.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 12. Python-Specific Guidelines

### 12.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 12.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 12.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 12.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 13. Post-Work Activities

### 13.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 13.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 14. Work Methodology

### 14.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 14.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 15. Special Commands

### 15.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 15.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 15.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 16. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 17. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate


</document_content>
</document>

<document index="5">
<source>CHANGELOG.md</source>
<document_content>
# Changelog

All notable changes to this project will be documented in this file.

## [Unreleased]

### Added

#### Phase 1: Robustness and Error Handling ‚úÖ
- **Enhanced Exception System**: Added specialized exception classes (`BrowserInstallationError`, `BrowserLaunchError`, `ProcessKillError`, `NetworkError`, `TimeoutError`)
- **Retry Mechanisms**: Implemented configurable retry logic for network requests and browser operations
- **Process Management**: Enhanced process killing with graceful termination ‚Üí force kill fallback
- **Launch Verification**: Added `wait_for_process_start()` to ensure Chrome debug port availability
- **Download Progress**: Real-time progress reporting with SHA256 integrity checking
- **Smart Login Detection**: Detects authentication via cookies, localStorage, and sessionStorage
- **Enhanced Onboarding UI**: Professional step-by-step interface with animated status indicators
- **Comprehensive Utils Tests**: 17 new test cases for paths and logging modules

#### Phase 2: Cross-Platform Compatibility ‚úÖ
- **Enhanced Chrome Finder**: Platform-specific Chrome discovery with 20+ locations per platform
  - Windows: 32/64-bit support, registry lookup, user installations
  - Linux: Snap, Flatpak, distribution-specific paths
  - macOS: ARM64/x64 support, Homebrew, user applications
- **CI/CD Pipeline**: GitHub Actions workflow for multi-platform testing
  - Matrix testing on Ubuntu, Windows, macOS (latest + macOS-13)
  - Automated linting, type checking, and coverage reporting
  - Build and release automation with PyPI publishing
- **Platform-Specific Tests**: 15+ test cases with mock system calls
- **Integration Tests**: 25+ comprehensive tests covering all major scenarios
- **Chrome Version Detection**: `get_chrome_version()` function for compatibility checks

### Changed

- **Project Structure**: Migrated to modern `src/` layout
- **Build System**: Switched from setuptools to hatch + hatch-vcs for git-tagged versioning
- **Error Handling**: All operations now have proper timeout and retry logic
- **Browser Management**: Refactored into separate modules (finder, installer, launcher, process)
- **Logging**: Enhanced debug logging throughout with detailed path checking

### Fixed

- **Process Management**: Fixed unreliable process killing across platforms
- **Network Operations**: Added proper timeout handling for all HTTP requests
- **Path Detection**: Fixed Chrome executable finding on all platforms
- **Error Messages**: Improved user-facing error messages with actionable guidance

### Technical Improvements

- **Code Quality**: Configured ruff for linting and formatting
- **Type Safety**: Added type hints throughout the codebase
- **Test Coverage**: Significantly improved with unit, integration, and platform tests
- **Performance**: Optimized Chrome discovery with lazy path generation
- **Documentation**: Updated all file path references for new structure

## [0.1.0] - 2025-08-03

### Added

- Initial implementation of the `playwrightauthor` library.
- `Browser` and `AsyncBrowser` context managers to provide authenticated Playwright browser instances.
- `browser_manager.py` to handle the automatic installation and launching of Chrome for Testing.
- `cli.py` with a `status` command to check the browser's state.
- `onboarding.py` and `templates/onboarding.html` for first-time user guidance.
- Utility modules for logging (`logger.py`) and path management (`paths.py`).
- `pyproject.toml` for project metadata and dependency management.
- Basic smoke tests for the `Browser` and `AsyncBrowser` classes.
- Comprehensive `PLAN.md` and `TODO.md` for development tracking.

</document_content>
</document>

<document index="6">
<source>CLAUDE.md</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

PlaywrightAuthor is a convenience package for Microsoft Playwright that handles browser automation setup. It automatically manages Chrome for Testing installation, authentication with user profiles, and provides ready-to-use Browser objects through simple context managers.

## 2. Key Architecture

**Core Design Pattern**: The library follows a context manager pattern with `Browser()` and `AsyncBrowser()` classes that return authenticated Playwright browser objects.

**Main Components** (planned structure):
- `playwrightauthor/author.py` - Core Browser/AsyncBrowser classes (main API)
- `playwrightauthor/browser_manager.py` - Chrome installation/process management 
- `playwrightauthor/onboarding.py` - User guidance for authentication
- `playwrightauthor/cli.py` - Fire-powered CLI interface
- `playwrightauthor/utils/` - Logger and cross-platform path utilities

**Current State**: The project is in early development. The main implementation exists as a legacy scraper in `old/google_docs_scraper_simple.py` that demonstrates the core concept of connecting to an existing Chrome debug session.

## 3. Development Commands

### 3.1. Environment Setup
```bash
# Initial setup with uv
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add playwright rich fire loguru platformdirs requests psutil
```

### 3.2. Code Quality Pipeline
After any Python changes, run:
```bash
fd -e py -x uvx autoflake -i {}; \
fd -e py -x uvx pyupgrade --py312-plus {}; \
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
python -m pytest
```

### 3.3. Testing
- Run tests: `python -m pytest`
- Tests are located in `tests/` directory
- Current tests may be integration tests requiring live Chrome instance

### 3.4. CLI Usage
Once implemented:
```bash
python -m playwrightauthor status  # Check browser status
```

## 4. Code Standards

- **File headers**: Every Python file should include a `this_file:` comment with the relative path
- **Dependencies**: Use uv script headers with `# /// script` blocks
- **Type hints**: Use modern Python type hints (list, dict, | for unions)
- **Logging**: Use loguru with verbose flag support
- **CLI**: Use Fire for command-line interfaces with Rich for output

## 5. Browser Management Strategy

The core technical challenge is reliably managing Chrome for Testing:

1. **Detection**: Check if Chrome is running with `--remote-debugging-port=9222`
2. **Installation**: Prefer `npx puppeteer browsers install`, fallback to LKGV JSON downloads
3. **Process Management**: Kill non-debug instances, launch with persistent user-data-dir
4. **Connection**: Use Playwright's `connect_over_cdp()` to attach to debug session

## 6. Project Workflow

The project follows a documentation-driven development approach:
1. Read `WORK.md` and `PLAN.md` before making changes
2. Update documentation files after implementation
3. Use "Wait, but" reflection methodology for code review
4. Maintain minimal, self-contained commits

## 7. Dependencies

Core runtime dependencies:
- `playwright` - Browser automation
- `rich` - Terminal output formatting  
- `fire` - CLI generation
- `loguru` - Logging
- `platformdirs` - Cross-platform paths
- `requests` - HTTP client for downloads
- `psutil` - Process management

# Software Development Rules

## 8. Pre-Work Preparation

### 8.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 8.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 9. General Coding Principles

### 9.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 9.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 10. Tool Usage (When Available)

### 10.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 11. File Management

### 11.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 12. Python-Specific Guidelines

### 12.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 12.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 12.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 12.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 13. Post-Work Activities

### 13.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 13.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 14. Work Methodology

### 14.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 14.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 15. Special Commands

### 15.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 15.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 15.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 16. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 17. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate


</document_content>
</document>

<document index="7">
<source>GEMINI.md</source>
<document_content>
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 1. Project Overview

PlaywrightAuthor is a convenience package for Microsoft Playwright that handles browser automation setup. It automatically manages Chrome for Testing installation, authentication with user profiles, and provides ready-to-use Browser objects through simple context managers.

## 2. Key Architecture

**Core Design Pattern**: The library follows a context manager pattern with `Browser()` and `AsyncBrowser()` classes that return authenticated Playwright browser objects.

**Main Components** (planned structure):
- `playwrightauthor/author.py` - Core Browser/AsyncBrowser classes (main API)
- `playwrightauthor/browser_manager.py` - Chrome installation/process management 
- `playwrightauthor/onboarding.py` - User guidance for authentication
- `playwrightauthor/cli.py` - Fire-powered CLI interface
- `playwrightauthor/utils/` - Logger and cross-platform path utilities

**Current State**: The project is in early development. The main implementation exists as a legacy scraper in `old/google_docs_scraper_simple.py` that demonstrates the core concept of connecting to an existing Chrome debug session.

## 3. Development Commands

### 3.1. Environment Setup
```bash
# Initial setup with uv
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
uv add playwright rich fire loguru platformdirs requests psutil
```

### 3.2. Code Quality Pipeline
After any Python changes, run:
```bash
fd -e py -x uvx autoflake -i {}; \
fd -e py -x uvx pyupgrade --py312-plus {}; \
fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
python -m pytest
```

### 3.3. Testing
- Run tests: `python -m pytest`
- Tests are located in `tests/` directory
- Current tests may be integration tests requiring live Chrome instance

### 3.4. CLI Usage
Once implemented:
```bash
python -m playwrightauthor status  # Check browser status
```

## 4. Code Standards

- **File headers**: Every Python file should include a `this_file:` comment with the relative path
- **Dependencies**: Use uv script headers with `# /// script` blocks
- **Type hints**: Use modern Python type hints (list, dict, | for unions)
- **Logging**: Use loguru with verbose flag support
- **CLI**: Use Fire for command-line interfaces with Rich for output

## 5. Browser Management Strategy

The core technical challenge is reliably managing Chrome for Testing:

1. **Detection**: Check if Chrome is running with `--remote-debugging-port=9222`
2. **Installation**: Prefer `npx puppeteer browsers install`, fallback to LKGV JSON downloads
3. **Process Management**: Kill non-debug instances, launch with persistent user-data-dir
4. **Connection**: Use Playwright's `connect_over_cdp()` to attach to debug session

## 6. Project Workflow

The project follows a documentation-driven development approach:
1. Read `WORK.md` and `PLAN.md` before making changes
2. Update documentation files after implementation
3. Use "Wait, but" reflection methodology for code review
4. Maintain minimal, self-contained commits

## 7. Dependencies

Core runtime dependencies:
- `playwright` - Browser automation
- `rich` - Terminal output formatting  
- `fire` - CLI generation
- `loguru` - Logging
- `platformdirs` - Cross-platform paths
- `requests` - HTTP client for downloads
- `psutil` - Process management

# Software Development Rules

## 8. Pre-Work Preparation

### 8.1. Before Starting Any Work
- **ALWAYS** read `WORK.md` in the main project folder for work progress
- Read `README.md` to understand the project
- STEP BACK and THINK HEAVILY STEP BY STEP about the task
- Consider alternatives and carefully choose the best option
- Check for existing solutions in the codebase before starting

### 8.2. Project Documentation to Maintain
- `README.md` - purpose and functionality
- `CHANGELOG.md` - past change release notes (accumulative)
- `PLAN.md` - detailed future goals, clear plan that discusses specifics
- `TODO.md` - flat simplified itemized `- [ ]`-prefixed representation of `PLAN.md`
- `WORK.md` - work progress updates

## 9. General Coding Principles

### 9.1. Core Development Approach
- Iterate gradually, avoiding major changes
- Focus on minimal viable increments and ship early
- Minimize confirmations and checks
- Preserve existing code/structure unless necessary
- Check often the coherence of the code you're writing with the rest of the code
- Analyze code line-by-line

### 9.2. Code Quality Standards
- Use constants over magic numbers
- Write explanatory docstrings/comments that explain what and WHY
- Explain where and how the code is used/referred to elsewhere
- Handle failures gracefully with retries, fallbacks, user guidance
- Address edge cases, validate assumptions, catch errors early
- Let the computer do the work, minimize user decisions
- Reduce cognitive load, beautify code
- Modularize repeated logic into concise, single-purpose functions
- Favor flat over nested structures

## 10. Tool Usage (When Available)

### 10.1. Additional Tools
- If we need a new Python project, run `curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich; uv sync`
- Use `tree` CLI app if available to verify file locations
- Check existing code with `.venv` folder to scan and consult dependency source code
- Run `DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"` to get a condensed snapshot of the codebase into `llms.txt`

## 11. File Management

### 11.1. File Path Tracking
- **MANDATORY**: In every source file, maintain a `this_file` record showing the path relative to project root
- Place `this_file` record near the top:
- As a comment after shebangs in code files
- In YAML frontmatter for Markdown files
- Update paths when moving files
- Omit leading `./`
- Check `this_file` to confirm you're editing the right file

## 12. Python-Specific Guidelines

### 12.1. PEP Standards
- PEP 8: Use consistent formatting and naming, clear descriptive names
- PEP 20: Keep code simple and explicit, prioritize readability over cleverness
- PEP 257: Write clear, imperative docstrings
- Use type hints in their simplest form (list, dict, | for unions)

### 12.2. Modern Python Practices
- Use f-strings and structural pattern matching where appropriate
- Write modern code with `pathlib`
- ALWAYS add "verbose" mode loguru-based logging & debug-log
- Use `uv add` 
- Use `uv pip install` instead of `pip install`
- Prefix Python CLI tools with `python -m` (e.g., `python -m pytest`)

### 12.3. CLI Scripts Setup
For CLI Python scripts, use `fire` & `rich`, and start with:
```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

### 12.4. Post-Edit Python Commands
```bash
fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;
```

## 13. Post-Work Activities

### 13.1. Critical Reflection
- After completing a step, say "Wait, but" and do additional careful critical reasoning
- Go back, think & reflect, revise & improve what you've done
- Don't invent functionality freely
- Stick to the goal of "minimal viable next version"

### 13.2. Documentation Updates
- Update `WORK.md` with what you've done and what needs to be done next
- Document all changes in `CHANGELOG.md`
- Update `TODO.md` and `PLAN.md` accordingly

## 14. Work Methodology

### 14.1. Virtual Team Approach
Be creative, diligent, critical, relentless & funny! Lead two experts:
- **"Ideot"** - for creative, unorthodox ideas
- **"Critin"** - to critique flawed thinking and moderate for balanced discussions

Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

### 14.2. Continuous Work Mode
- Treat all items in `PLAN.md` and `TODO.md` as one huge TASK
- Work on implementing the next item
- Review, reflect, refine, revise your implementation
- Periodically check off completed issues
- Continue to the next item without interruption

## 15. Special Commands

### 15.1. `/plan` Command - Transform Requirements into Detailed Plans

When I say "/plan [requirement]", you must:

1. **DECONSTRUCT** the requirement:
- Extract core intent, key features, and objectives
- Identify technical requirements and constraints
- Map what's explicitly stated vs. what's implied
- Determine success criteria

2. **DIAGNOSE** the project needs:
- Audit for missing specifications
- Check technical feasibility
- Assess complexity and dependencies
- Identify potential challenges

3. **RESEARCH** additional material: 
- Repeatedly call the `perplexity_ask` and request up-to-date information or additional remote context
- Repeatedly call the `context7` tool and request up-to-date software package documentation
- Repeatedly call the `codex` tool and request additional reasoning, summarization of files and second opinion

4. **DEVELOP** the plan structure:
- Break down into logical phases/milestones
- Create hierarchical task decomposition
- Assign priorities and dependencies
- Add implementation details and technical specs
- Include edge cases and error handling
- Define testing and validation steps

5. **DELIVER** to `PLAN.md`:
- Write a comprehensive, detailed plan with:
 - Project overview and objectives
 - Technical architecture decisions
 - Phase-by-phase breakdown
 - Specific implementation steps
 - Testing and validation criteria
 - Future considerations
- Simultaneously create/update `TODO.md` with the flat itemized `- [ ]` representation

**Plan Optimization Techniques:**
- **Task Decomposition:** Break complex requirements into atomic, actionable tasks
- **Dependency Mapping:** Identify and document task dependencies
- **Risk Assessment:** Include potential blockers and mitigation strategies
- **Progressive Enhancement:** Start with MVP, then layer improvements
- **Technical Specifications:** Include specific technologies, patterns, and approaches

### 15.2. `/report` Command

1. Read all `./TODO.md` and `./PLAN.md` files
2. Analyze recent changes
3. Document all changes in `./CHANGELOG.md`
4. Remove completed items from `./TODO.md` and `./PLAN.md`
5. Ensure `./PLAN.md` contains detailed, clear plans with specifics
6. Ensure `./TODO.md` is a flat simplified itemized representation

### 15.3. `/work` Command

1. Read all `./TODO.md` and `./PLAN.md` files and reflect
2. Write down the immediate items in this iteration into `./WORK.md`
3. Work on these items
4. Think, contemplate, research, reflect, refine, revise
5. Be careful, curious, vigilant, energetic
6. Verify your changes and think aloud
7. Consult, research, reflect
8. Periodically remove completed items from `./WORK.md`
9. Tick off completed items from `./TODO.md` and `./PLAN.md`
10. Update `./WORK.md` with improvement tasks
11. Execute `/report`
12. Continue to the next item

## 16. Additional Guidelines

- Ask before extending/refactoring existing code that may add complexity or break things
- Work tirelessly without constant updates when in continuous work mode
- Only notify when you've completed all `PLAN.md` and `TODO.md` items

## 17. Command Summary

- `/plan [requirement]` - Transform vague requirements into detailed `PLAN.md` and `TODO.md`
- `/report` - Update documentation and clean up completed tasks
- `/work` - Enter continuous work mode to implement plans
- You may use these commands autonomously when appropriate


</document_content>
</document>

<document index="8">
<source>LICENSE</source>
<document_content>
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

</document_content>
</document>

<document index="9">
<source>PLAN.md</source>
<document_content>
# Plan for Improvements

This document outlines the development phases for `PlaywrightAuthor`, focusing on making the library more robust, cross-platform, elegant, performant, and user-friendly.

## Phase 1: Robustness and Error Handling ‚úÖ COMPLETED

This phase focused on making the library more resilient to failure.

### Completed:
- ‚úÖ Enhanced error handling with specialized exception classes
- ‚úÖ Implemented retry mechanisms for all network requests
- ‚úÖ Added configurable timeouts to subprocess operations
- ‚úÖ Improved cross-platform process killing logic
- ‚úÖ Smart login detection via cookies and browser storage
- ‚úÖ Enhanced onboarding UI with step-by-step instructions
- ‚úÖ Comprehensive unit tests for utils modules

## Phase 2: Cross-Platform Compatibility ‚úÖ COMPLETED

This phase ensured the library works seamlessly on Windows, macOS, and Linux.

### Completed:
- ‚úÖ GitHub Actions CI/CD pipeline for multi-platform testing
- ‚úÖ Enhanced Chrome finder supporting 20+ locations per platform
- ‚úÖ Platform-specific bug fixes and optimizations
- ‚úÖ Comprehensive integration and platform-specific tests

## Phase 3: Elegance and Performance (IN PROGRESS)

This phase will focus on improving the design and performance of the library.

### 1. Architecture Refactoring

**Objective**: Improve code organization and maintainability.

- **Extract Browser State Management**:
  - Create `state_manager.py` to handle browser state persistence
  - Implement state serialization/deserialization
  - Add state migration for version compatibility

- **Separate Configuration Management**:
  - Create `config.py` for centralized configuration
  - Support environment variables and config files
  - Add configuration validation and defaults

- **Plugin Architecture**:
  - Design plugin system for extensibility
  - Create base plugin class with lifecycle hooks
  - Implement example plugins (proxy, headers, etc.)

### 2. Performance Optimization

**Objective**: Reduce startup time and resource usage.

- **Lazy Loading**:
  - Defer Playwright imports until needed
  - Implement lazy browser initialization
  - Cache Chrome executable location

- **Connection Pooling**:
  - Implement CDP connection pooling
  - Reuse browser contexts when possible
  - Add connection health checks

- **Parallel Operations**:
  - Enable concurrent page operations
  - Implement async batch operations
  - Add rate limiting for resource protection

### 3. Advanced Features

**Objective**: Add power-user features while maintaining simplicity.

- **Browser Profiles**:
  - Support multiple named profiles
  - Profile import/export functionality
  - Profile encryption for sensitive data

- **Session Management**:
  - Save/restore complete browser sessions
  - Session sharing between instances
  - Automatic session rotation

- **Advanced Authentication**:
  - OAuth flow automation
  - 2FA/MFA support helpers
  - Credential vault integration

## Phase 4: User Experience & Documentation (PLANNED)

This phase will focus on making the library delightful to use.

### 1. Enhanced CLI

**Objective**: Provide a powerful yet intuitive command-line interface.

- **Interactive Mode**:
  - REPL for browser interaction
  - Tab completion for commands
  - Command history and suggestions

- **Management Commands**:
  - `playwrightauthor profile` - Manage browser profiles
  - `playwrightauthor clear-cache` - Clear browser data
  - `playwrightauthor diagnose` - Troubleshooting helper
  - `playwrightauthor update` - Update Chrome for Testing

- **Output Formatting**:
  - Structured output (JSON, YAML)
  - Progress bars for long operations
  - Color-coded status messages

### 2. Comprehensive Documentation

**Objective**: Make the library accessible to all skill levels.

- **Getting Started Guide**:
  - Quick start tutorial
  - Common use cases with examples
  - Video walkthroughs

- **API Reference**:
  - Complete API documentation
  - Type annotations documentation
  - Interactive examples

- **Cookbook**:
  - Authentication recipes
  - Web scraping patterns
  - Testing strategies
  - Performance tips

- **Troubleshooting Guide**:
  - Common issues and solutions
  - Debug mode documentation
  - FAQ section

### 3. Developer Experience

**Objective**: Make contributing and extending the library easy.

- **Development Tools**:
  - Pre-commit hooks setup
  - Development container config
  - VS Code extension recommendations

- **Examples Repository**:
  - Real-world usage examples
  - Integration examples
  - Performance benchmarks

- **Community Building**:
  - Contributing guidelines
  - Code of conduct
  - Discord/Slack community

## Phase 5: Future Considerations (VISION)

### 1. Cloud Integration
- Remote browser support
- Distributed browser pools
- Cloud storage for profiles

### 2. AI Integration
- Smart element selection
- Automatic form filling
- Visual regression detection

### 3. Enterprise Features
- LDAP/AD integration
- Audit logging
- Compliance tools

### 4. Ecosystem
- Official plugins marketplace
- Third-party integrations
- Partner certifications

</document_content>
</document>

<document index="10">
<source>README.md</source>
<document_content>
# PlaywrightAuthor

*Your personal, authenticated browser for Playwright, ready in one line of code.*

PlaywrightAuthor is a convenience package for **Microsoft Playwright**. It handles the tedious parts of browser automation: finding and launching a **Chrome for Testing** instance, keeping it authenticated with your user profile, and connecting Playwright to it. All you need to do is instantiate a class, and you get a ready-to-use `Browser` object. This lets you focus on writing your automation script, not on the boilerplate.

The core idea is to let you do this:

```python
from playwrightauthor import Browser

with Browser() as browser:
    # you get a standard Playwright browser object
    # that is already connected to a logged-in browser
    page = browser.new_page()
    page.goto("https://github.com/me")
    print(f"Welcome, {page.locator('.user-profile-name').inner_text()}!")
```

---

## Contents

* [Features](#features)
* [Quick‚Äëstart](#quick-start)
* [Developer workflow](#developer-workflow)
* [Package layout](#package-layout) ‚Äì **file tree, code snippet, explanation & rationale for every file**
* [Contributing](#contributing)
* [License](#license)

---

## Features

| ‚úîÔ∏é                                                                                                                                                                   | Capability |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| Automatically discovers or installs a suitable **Chrome¬†for‚ÄØTesting** build via the *last‚Äëknown‚Äëgood‚Äëversions* JSON, falling back to `npx puppeteer` when possible.  |            |
| Launches Chrome with `--remote-debugging-port` (killing any non‚Äëdebug instance first) and shows a friendly onboarding HTML if the user still needs to log in.        |            |
| Provides simple `Browser()` and `AsyncBrowser()` classes that return a ready-to-use, authenticated Playwright browser object.                                        |            |
| Fire‚Äëpowered CLI (`python -m playwrightauthor ...`) with rich‚Äêcolour output and `--verbose` flag wiring straight into **loguru**.                                    |            |
| 100‚ÄØ%¬†type‚Äëhinted, PEP‚ÄØ8‚Äëcompliant, flat, self‚Äëdocumenting codebase; every source has a `this_file:` tracker line.                                                   |            |
| Batteries included: pytest suite, Ruff/pyupgrade/autoflake hooks, uv‚Äëbased reproducible environments.                                                                |            |

---

## Quick start

```bash
# ‚ûÄ create & sync env
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv --python 3.12
uv init
# Add playwrightauthor and its dependencies
uv add playwright rich fire loguru platformdirs requests psutil

# ‚ûÅ run your script
# (create a file like 'myscript.py' with the code below)
python myscript.py
```

Example `myscript.py`:
```python
from playwrightauthor import Browser, AsyncBrowser
import asyncio

# Synchronous API
print("--- Running Sync Example ---")
with Browser(verbose=True) as browser:
    page = browser.new_page()
    page.goto("https://github.com")
    print(f"Page title: {page.title()}")

# Asynchronous API
async def main():
    print("\n--- Running Async Example ---")
    async with AsyncBrowser(verbose=True) as browser:
        page = await browser.new_page()
        await page.goto("https://duckduckgo.com")
        print(f"Page title: {await page.title()}")

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Command-Line Interface

PlaywrightAuthor comes with a command-line interface for managing the browser installation.

### `status`

Checks the status of the browser and launches it if it's not running.

```bash
python -m playwrightauthor status
```

### `clear-cache`

Removes the browser installation directory, including the browser itself and user data.

```bash
python -m playwrightauthor clear-cache
```

---

## Developer workflow

1. **Read** `WORK.md` & `PLAN.md` before touching code.

2. **Iterate** in minimal, self‚Äëcontained commits.

3. After Python changes run:

   ```bash
   fd -e py -x uvx autoflake -i {}; \
   fd -e py -x uvx pyupgrade --py312-plus {}; \
   fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; \
   fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; \
   python -m pytest
   ```

4. Update `CHANGELOG.md`, tick items in `TODO.md`, push.

5. Always finish a work session with **‚ÄúWait, but‚Äù** ‚Üí reflect ‚Üí refine ‚Üí push again.

---

## Package layout

> Below is the *envisioned* file tree.
> Each entry shows (a) **code snippet** ‚Äì only the essential lines,
> (b) **explanation** ‚Äì what it does,
> (c) **rationale** ‚Äì why it belongs.

```
.
‚îú‚îÄ‚îÄ playwrightauthor/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ __main__.py
‚îÇ   ‚îú‚îÄ‚îÄ cli.py
‚îÇ   ‚îú‚îÄ‚îÄ author.py
‚îÇ   ‚îú‚îÄ‚îÄ browser_manager.py
‚îÇ   ‚îú‚îÄ‚îÄ onboarding.py
‚îÇ   ‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ onboarding.html
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ paths.py
‚îÇ   ‚îî‚îÄ‚îÄ typing.py
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ test_author.py
‚îú‚îÄ‚îÄ README.md          ‚Üê *‚Üê this file*
‚îú‚îÄ‚îÄ PLAN.md
‚îú‚îÄ‚îÄ TODO.md
‚îú‚îÄ‚îÄ WORK.md
‚îî‚îÄ‚îÄ CHANGELOG.md
```

### `playwrightauthor/__init__.py`

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = []
# ///
# this_file: playwrightauthor/__init__.py

"""Public re‚Äëexports for library consumers."""
from .author import Browser, AsyncBrowser

__all__ = ["Browser", "AsyncBrowser"]
```

*Explanation* ‚Äì Presents a tiny, stable API surface.
*Rationale* ‚Äì Hides internal churn; semver‚Äëcompatible.

---


### `playwrightauthor/__main__.py`

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["fire"]
# ///
# this_file: playwrightauthor/__main__.py

""`python -m playwrightauthor` entry‚Äëpoint."""
from .cli import main

if __name__ == "__main__":
    main()
```

*Explanation* ‚Äì Delegates to the Fire CLI.
*Rationale* ‚Äì Keeps `__init__` import‚Äëonly; avoids side‚Äëeffects.

---


### `playwrightauthor/cli.py`

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["fire", "rich"]
# ///
# this_file: playwrightauthor/cli.py

"""Fire‚Äëpowered command‚Äëline interface for utility tasks."""
from rich.console import Console
from .browser_manager import ensure_browser

def status(verbose: bool = False) -> None:
    """Checks browser status and launches it if not running."""
    console = Console()
    console.print("Checking browser status...")
    browser_path, data_dir = ensure_browser(verbose=verbose)
    console.print(f"[green]Browser is ready.[/green]")
    console.print(f"  - Path: {browser_path}")
    console.print(f"  - User Data: {data_dir}")

def main() -> None:
    import fire
    fire.Fire({"status": status})
```

*Explanation* ‚Äì Offers utility commands like `status`.
*Rationale* ‚Äì Provides a simple way to manage the browser without writing a script.

---


### `playwrightauthor/author.py`

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["playwright"]
# ///
# this_file: playwrightauthor/author.py

"""The core Browser and AsyncBrowser classes."""
from playwright.sync_api import sync_playwright, Playwright, Browser as PlaywrightBrowser
from playwright.async_api import async_playwright, AsyncPlaywright, Browser as AsyncPlaywrightBrowser
from .browser_manager import ensure_browser

class Browser:
    """A sync context manager for an authenticated Playwright Browser."""
    def __init__(self, verbose: bool = False):
        self.verbose = verbose

    def __enter__(self) -> PlaywrightBrowser:
        # 1. Ensure browser is running and get debug port
        # 2. playwright.chromium.connect_over_cdp()
        # 3. Return browser object
        ...

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Disconnect
        ...

class AsyncBrowser:
    """An async context manager for an authenticated Playwright Browser."""
    def __init__(self, verbose: bool = False):
        self.verbose = verbose

    async def __aenter__(self) -> AsyncPlaywrightBrowser:
        ...

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        ...
```

*Explanation* ‚Äì The main entry point for the library.
*Rationale* ‚Äì Provides a simple, Pythonic `with` statement syntax for browser management.

---


### `playwrightauthor/browser_manager.py`

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["requests", "platformdirs", "rich", "psutil"]
# ///
# this_file: playwrightauthor/browser_manager.py

"""
Ensure a Chrome¬†for¬†Testing build is present & running in debug mode.

Algorithm:
1. Try to connect to localhost:9222.
2. If Chrome is running *without* --remote-debugging-port ‚áí kill & restart.
3. If Chrome isn't installed:
   3a. Prefer `npx puppeteer browsers install`.
   3b. Else download the matching archive from LKGV JSON.
4. Launch Chrome with a persistent user‚Äëdata‚Äëdir.
"""
import os, subprocess, json, sys, platform, shutil, tempfile
from pathlib import Path
from rich.console import Console
from .utils.paths import install_dir

_LKGV_URL = "https://googlechromelabs.github.io/chrome-for-testing/last-known-good-versions-with-downloads.json"

def ensure_browser(verbose: bool = False):
    console = Console()
    ...
```

*Explanation* ‚Äì Central authority for ‚Äúis Chrome available?‚Äù.
*Rationale* ‚Äì Encapsulates the complex, platform-specific logic of managing the browser binary and its process.

---


### `playwrightauthor/onboarding.py`

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["playwright"]
# ///
# this_file: playwrightauthor/onboarding.py

"""Serve a local HTML page instructing the user to log in."""
from pathlib import Path
from playwright.async_api import Browser

def show(browser: Browser) -> None:
    html = Path(__file__).parent.parent / "templates" / "onboarding.html"
    page = browser.new_page()
    page.set_content(html.read_text("utf-8"), wait_until="domcontentloaded")
```

*Explanation* ‚Äì Visual cue when manual steps are needed.
*Rationale* ‚Äì Human‚Äëfriendly recovery path builds trust.

---


### `playwrightauthor/templates/onboarding.html`

```html
<!-- this_file: playwrightauthor/templates/onboarding.html -->
<!DOCTYPE html>
<html>
  <body>
    <h1>One small step‚Ä¶</h1>
    <p>Please <strong>log into any websites you need</strong> in this browser window.<br>
       This session will be saved for future runs.<br><br>
       You can close this tab and return to the terminal when you‚Äôre done!</p>
  </body>
</html>
```

*Explanation* ‚Äì Tiny static asset for user guidance.
*Rationale* ‚Äì Kept under `templates/` to avoid clutter.

---


### `playwrightauthor/utils/logger.py`

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["loguru"]
# ///
# this_file: playwrightauthor/utils/logger.py

"""Project‚Äëwide Loguru configuration."""
from loguru import logger

def configure(verbose: bool = False):
    logger.remove()
    level = "DEBUG" if verbose else "INFO"
    logger.add(lambda m: print(m, end=""), level=level)
    return logger
```

*Explanation* ‚Äì Single point of logging policy.
*Rationale* ‚Äì Avoids duplicating ‚Äúverbose‚Äù handling everywhere.

---


### `playwrightauthor/utils/paths.py`

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["platformdirs"]
# ///
# this_file: playwrightauthor/utils/paths.py

"""Cross‚Äëplatform install locations."""
from platformdirs import user_cache_dir
from pathlib import Path

def install_dir() -> Path:
    return Path(user_cache_dir("playwrightauthor", roaming=True)) / "browser"
```

*Explanation* ‚Äì Abstracts OS differences.
*Rationale* ‚Äì Ensures browser data is stored in a conventional, user-specific location.

---


### `tests/test_author.py`

```python
# this_file: tests/test_author.py
import pytest
from playwrightauthor import Browser

@pytest.mark.skip("requires live Chrome and user interaction")
def test_browser_smoke():
    """A basic smoke test to ensure the Browser class can be instantiated."""
    try:
        with Browser() as browser:
            assert browser is not None
            assert len(browser.contexts) > 0
    except Exception as e:
        # This test is expected to fail in a headless CI environment
        # without a display server or a running Chrome instance.
        # We just check that it doesn't raise an unexpected error.
        pass
```

*Explanation* ‚Äì Smoke test for the core `Browser` class.
*Rationale* ‚Äì Keeps CI fast but ensures the main library entry point is importable and structurally sound.

---

## Troubleshooting

### `BrowserManagerError: Could not find Chrome executable...`

This error means that `playwrightauthor` could not find a Chrome executable on your system. You can either install Chrome for Testing using the `npx puppeteer browsers install chrome` command, or install Google Chrome and ensure it is in a common system location.

### `playwright._impl._api_types.Error: Target page, context or browser has been closed`

This error usually means that the browser was closed while your script was running. This can happen if you manually close the browser window, or if the browser crashes. If you are running into this issue, you can try running your script with the `--verbose` flag to get more information.

---

## Contributing

Pull‚Äërequests are welcome! Please follow the **General Coding Principles** in the main `README.md`, keep every file‚Äôs `this_file` header accurate, and end each session with a short *‚ÄúWait, but‚Äù* reflection in your PR description.

---

## License

MIT ‚Äì *see* `LICENSE`.

---

Wait, but‚Ä¶

**Reflection & tiny refinements**

* Refocused the entire project from a specific scraper to a general-purpose Playwright convenience library.
* The core API is now class-based (`Browser`, `AsyncBrowser`) for a more Pythonic feel.
* Updated the file layout (`author.py`) and CLI (`status` command) to match the new scope.
* Generalized the onboarding HTML to be site-agnostic.
* Ensured all snippets and explanations align with the new vision of providing a zero-setup, authenticated browser.

(End of iteration ‚Äì ready for review.)
</document_content>
</document>

<document index="11">
<source>TODO.md</source>
<document_content>
## Phase 1: Robustness and Error Handling ‚úÖ
- [x] Refine `browser_manager.py` error handling.
- [x] Implement retry mechanism for network requests in `browser_manager.py`.
- [x] Add timeout to `subprocess.Popen` in `browser_manager.py`.
- [x] Improve process-killing logic in `browser_manager.py`.
- [x] Implement login detection in `onboarding.py`.
- [x] Improve instructions in `onboarding.html`.
- [x] Add unit tests for `utils/`.

## Phase 2: Cross-Platform Compatibility ‚úÖ
- [x] Add comprehensive integration tests.
- [x] Set up CI/CD pipeline for multi-platform testing.
- [x] Test and fix platform-specific bugs.
- [x] Refine `_find_chrome_executable` for all platforms.

## Phase 3: Elegance and Performance

### Architecture Refactoring
- [ ] Extract Browser State Management - Create state_manager.py
- [ ] Extract Browser State Management - Implement state serialization/deserialization
- [ ] Extract Browser State Management - Add state migration for version compatibility
- [ ] Separate Configuration Management - Create config.py
- [ ] Separate Configuration Management - Support environment variables and config files
- [ ] Separate Configuration Management - Add configuration validation and defaults
- [ ] Plugin Architecture - Design plugin system for extensibility
- [ ] Plugin Architecture - Create base plugin class with lifecycle hooks
- [ ] Plugin Architecture - Implement example plugins

### Performance Optimization
- [ ] Performance - Implement lazy loading for Playwright imports
- [ ] Performance - Implement lazy browser initialization
- [ ] Performance - Cache Chrome executable location
- [ ] Performance - Implement CDP connection pooling
- [ ] Performance - Add connection health checks

### Advanced Features
- [ ] Advanced Features - Support multiple named browser profiles
- [ ] Advanced Features - Profile import/export functionality
- [ ] Advanced Features - OAuth flow automation
- [ ] Benchmark the library to identify performance bottlenecks

## Phase 4: User-Friendliness
- [ ] Add more CLI commands (e.g., `clear-cache`).
- [ ] Improve CLI help messages and error reporting.
- [ ] Update `README.md` with more detailed instructions and examples.
- [ ] Improve API documentation.
- [ ] Add a troubleshooting section to the documentation.

</document_content>
</document>

<document index="12">
<source>WORK.md</source>
<document_content>
# Work Progress

## Phase 1: Robustness and Error Handling - COMPLETED ‚úÖ

### Completed Tasks

- [x] Reorganize project structure to src/ layout
- [x] Update pyproject.toml to use hatch and hatch-vcs  
- [x] Fix hatch configuration warning in pyproject.toml
- [x] Refine browser_manager.py error handling
- [x] Implement retry mechanism for network requests
- [x] Add timeout to subprocess.Popen calls
- [x] Improve process-killing logic across platforms
- [x] Implement login detection in onboarding.py
- [x] Improve instructions in onboarding.html template
- [x] Add comprehensive unit tests for utils/ modules

### Major Improvements Made

#### 1. Enhanced Error Handling & Exception System
- Added specific exception classes: `BrowserInstallationError`, `BrowserLaunchError`, `ProcessKillError`, `NetworkError`, `TimeoutError`
- Comprehensive error propagation with proper exception chaining
- Graceful error recovery with meaningful user messages

#### 2. Robust Browser Management
- **Process Management**: Enhanced `kill_chrome_process()` with graceful termination ‚Üí force kill fallback
- **Launch Verification**: `wait_for_process_start()` ensures Chrome debug port is actually available
- **Retry Logic**: `launch_chrome_with_retry()` handles transient launch failures
- **Timeout Protection**: All subprocess operations now have configurable timeouts

#### 3. Network Operations Resilience
- **Download Progress**: Real-time progress reporting for Chrome downloads
- **Integrity Checking**: SHA256 validation of downloaded files
- **LKGV Data Validation**: Robust JSON schema validation
- **Retry Mechanism**: Configurable retry attempts with exponential backoff
- **Partial Cleanup**: Automatic cleanup of failed downloads

#### 4. Enhanced Onboarding Experience
- **Smart Login Detection**: Detects authentication cookies, localStorage, sessionStorage
- **Progressive Monitoring**: Real-time activity monitoring every 5 seconds
- **Improved UI**: Professional, step-by-step onboarding interface
- **Visual Feedback**: Animated status indicators and keyboard shortcuts
- **Retry Support**: `show_with_retry()` for error resilience

#### 5. Build System Modernization
- **Source Layout**: Moved to `src/playwrightauthor/` structure
- **Hatch + hatch-vcs**: Git-tagged semantic versioning
- **UV Integration**: Modern Python dependency management
- **Ruff Configuration**: Comprehensive linting and formatting rules

#### 6. Testing Infrastructure
- **Comprehensive Utils Tests**: 17 new test cases covering paths and logging
- **Mock Testing**: Proper isolation with unittest.mock
- **Integration Tests**: Cross-module functionality validation
- **Error Case Coverage**: Tests for edge cases and error conditions

## Phase 2: Cross-Platform Compatibility - IN PROGRESS üöß

### Completed Tasks

- [x] Enhanced Chrome executable finding for all platforms
  - Windows: Added support for 32/64-bit, user installs, registry lookup
  - Linux: Added snap, flatpak, distribution-specific paths  
  - macOS: Added ARM64/x64 support, Homebrew paths, user applications
- [x] Created comprehensive GitHub Actions CI/CD workflow
  - Multi-platform testing matrix (Ubuntu, Windows, macOS + macOS-13)
  - Automated linting, type checking, and coverage reporting
  - Integration tests for CLI and browser installation
  - Build and release automation with PyPI publishing
- [x] Added platform-specific tests
  - 15 new test cases covering platform-specific functionality
  - Mock testing for system commands (where, which)
  - Executable permission verification on Unix systems
  - Cross-platform path handling validation

### Major Improvements Made

#### 1. Enhanced Chrome Finder
- **Platform Detection**: Automatic architecture detection (ARM64 vs x64 on macOS)
- **Comprehensive Search**: Generates 20+ potential Chrome locations per platform
- **System Integration**: Uses native OS commands (where/which) as fallback
- **Debug Logging**: Detailed logging of all checked paths for troubleshooting
- **Version Detection**: `get_chrome_version()` function for compatibility checks

#### 2. Robust CI/CD Pipeline
- **Matrix Testing**: Tests on Ubuntu, Windows, macOS (latest + older x64)
- **Dependency Caching**: UV cache for faster builds
- **Quality Gates**: Linting, formatting, type checking before tests
- **Coverage Tracking**: Integration with Codecov for coverage reports
- **Release Automation**: Auto-publish to PyPI on version tags

#### 3. Platform-Specific Testing
- **OS-Specific Tests**: Separate test suites for each platform
- **Mock System Calls**: Safe testing without requiring Chrome installation
- **Permission Testing**: Verifies executable permission checks on Unix
- **Integration Tests**: End-to-end testing of Chrome finding functionality

### Next Steps

Phase 2 is now substantially complete. The library has robust cross-platform support with comprehensive testing. Ready to move to:

**Phase 3: Elegance and Performance**
- Refactor browser_manager.py into smaller modules
- Optimize browser launch performance
- Benchmark the library

### Technical Achievements

- **100% Platform Coverage**: Windows, Linux, macOS (including ARM64)
- **Automated Testing**: Full CI/CD pipeline with multi-platform support
- **Enhanced Debugging**: Comprehensive logging for troubleshooting
- **Future-Proof**: Architecture supports easy addition of new Chrome locations

Wait, but additional reflection: The cross-platform improvements are comprehensive, but real-world testing on actual diverse systems would be valuable. The CI/CD pipeline is solid but could benefit from additional integration test scenarios. The Chrome finder is much more robust but may need updates as Chrome installation patterns evolve.

Overall, Phase 2 objectives have been successfully completed with significant improvements to cross-platform compatibility and testing infrastructure.
</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/old/google_docs_scraper_simple.py
# Language: python

import asyncio
import fire
from loguru import logger
from playwright.async_api import async_playwright
from rich.console import Console
from rich.pretty import pprint
import traceback

def scrape_google_docs((
    debug_port: int = 9222, verbose: bool = False
)) -> list[str]:
    """Connect to existing Chrome and scrape Google Docs titles from existing tabs."""

def main((debug_port: int = 9222, verbose: bool = False)) -> None:
    """ Scrape Google Docs titles using existing Chrome tabs...."""


<document index="13">
<source>old/playwrightauthor.md</source>
<document_content>
> ‚è∫ Perfect! It worked. The initial proof-of-concept demonstrated that we can connect to an existing Chrome instance and automate it.

Now, let's build this into a general-purpose Python package called `playwrightauthor`.

The goal is to create an easy-to-use library that allows developers to get a ready-to-use, authenticated Playwright `Browser` object with minimal effort. The user should be able to write simple, expressive code like this:

```python
from playwrightauthor import Browser

with Browser() as browser:
    # ... do Playwright stuff here ...
```

Behind the scenes, the package will handle all the complex setup:

1.  **Browser Management:**
    *   Check if a compatible **Chrome for Testing** is installed. If not, automatically download and install it. The primary method should be `npx puppeteer browsers install`, with a fallback to parsing the official JSON feeds.
    *   The browser should be stored in a user-specific, cross-platform cache directory (using `platformdirs`).
    *   Launch the browser with the `--remote-debugging-port` enabled. If a non-debugging instance is already running, it should be terminated and restarted correctly.

2.  **Authentication & Onboarding:**
    *   The browser must use a persistent user data directory to maintain login sessions across runs.
    *   On the very first run, or if the browser loses its authenticated state, the library should open a friendly HTML splash screen. This page will instruct the user to log into any necessary websites in that browser window.

3.  **Playwright Integration:**
    *   The core of the package will be the `Browser` and `AsyncBrowser` classes.
    *   These classes, when instantiated (ideally in a `with` statement), will perform the connection to the running browser instance via its remote debugging port (`playwright.chromium.connect_over_cdp`).
    *   They will return a fully functional Playwright `Browser` object that the user can immediately start working with.

4.  **User Experience:**
    *   The entire process should feel magical. The user shouldn't need to know about debugging ports, browser paths, or user data directories.
    *   Provide a simple CLI for basic status checks (e.g., `python -m playwrightauthor status`).

This approach transforms the initial scraper concept into a powerful, reusable tool that simplifies the most common and frustrating part of browser automation: setup and authentication.
</document_content>
</document>

<document index="14">
<source>publish.sh</source>
<document_content>
#!/usr/bin/env bash
llms . "*.txt"
uvx hatch clean
gitnextver .
uvx hatch build
uvx hatch publish

</document_content>
</document>

<document index="15">
<source>pyproject.toml</source>
<document_content>
[build-system]
requires = ["hatchling", "hatch-vcs"]
build-backend = "hatchling.build"

[project]
name = "playwrightauthor"
dynamic = ["version"]
authors = [
    { name = "Adam Twardoch", email = "adam+github@twardoch.com" },
]
description = "Your personal, authenticated browser for Playwright, ready in one line of code."
readme = "README.md"
requires-python = ">=3.12"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]
dependencies = [
    "playwright",
    "rich",
    "fire",
    "loguru",
    "platformdirs",
    "requests",
    "psutil",
]

[project.urls]
"Homepage" = "https://github.com/twardoch/playwrightauthor"
"Bug Tracker" = "https://github.com/twardoch/playwrightauthor/issues"

[project.scripts]
playwrightauthor = "playwrightauthor.cli:main"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "guess-next-dev"
write_to = "src/playwrightauthor/_version.py"

[tool.hatch.build.targets.wheel]
packages = ["src/playwrightauthor"]

[tool.uv]
dev-dependencies = [
    "pytest",
    "ruff",
    "mypy",
]

[tool.ruff]
target-version = "py312"
line-length = 88
extend-exclude = ["_version.py"]

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "B",  # flake8-bugbear
    "C4", # flake8-comprehensions
    "UP", # pyupgrade
]
ignore = [
    "E501", # line too long, handled by formatter
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"

[tool.ruff.lint.isort]
known-first-party = ["playwrightauthor"]

</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/__init__.py
# Language: python

from .author import AsyncBrowser, Browser


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/__main__.py
# Language: python

from .cli import main


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/author.py
# Language: python

from datetime import datetime
from typing import TYPE_CHECKING
from .browser_manager import ensure_browser
from .config import get_config
from .lazy_imports import get_async_playwright, get_sync_playwright
from .state_manager import get_state_manager
from .utils.logger import configure as configure_logger
from playwright.async_api import Browser as AsyncPlaywrightBrowser
from playwright.async_api import Playwright as AsyncPlaywright
from playwright.sync_api import Browser as PlaywrightBrowser
from playwright.sync_api import Playwright

class Browser:
    """ A sync context manager for an authenticated Playwright Browser...."""
    def __init__((self, verbose: bool = False, profile: str = "default")):
    def __enter__((self)) -> PlaywrightBrowser:
    def __exit__((self, exc_type, exc_val, exc_tb)):
    def _get_timestamp((self)) -> str:
        """Get current timestamp in ISO format."""

class AsyncBrowser:
    """ An async context manager for an authenticated Playwright Browser...."""
    def __init__((self, verbose: bool = False, profile: str = "default")):
    def __aenter__((self)) -> AsyncPlaywrightBrowser:
    def __aexit__((self, exc_type, exc_val, exc_tb)):

def __init__((self, verbose: bool = False, profile: str = "default")):

def __enter__((self)) -> PlaywrightBrowser:

def __exit__((self, exc_type, exc_val, exc_tb)):

def _get_timestamp((self)) -> str:
    """Get current timestamp in ISO format."""

def __init__((self, verbose: bool = False, profile: str = "default")):

def __aenter__((self)) -> AsyncPlaywrightBrowser:

def __aexit__((self, exc_type, exc_val, exc_tb)):


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser/__init__.py
# Language: python



# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser/finder.py
# Language: python

import os
import platform
import subprocess
import sys
from pathlib import Path
from typing import Generator
from ..utils.paths import install_dir
from ..state_manager import get_state_manager
from ..state_manager import get_state_manager

def _get_windows_chrome_paths(()) -> Generator[Path, None, None]:
    """Generate possible Chrome paths on Windows."""

def _get_linux_chrome_paths(()) -> Generator[Path, None, None]:
    """Generate possible Chrome paths on Linux."""

def _get_macos_chrome_paths(()) -> Generator[Path, None, None]:
    """Generate possible Chrome paths on macOS."""

def find_chrome_executable((logger=None, use_cache: bool = True)) -> Path | None:
    """ Find the Chrome or Chromium executable on the system...."""

def get_chrome_version((chrome_path: Path, logger=None)) -> str | None:
    """ Get the version of Chrome at the given path...."""

def _cache_chrome_path((path: Path, logger=None)) -> None:
    """Cache the Chrome executable path for future use."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser/installer.py
# Language: python

import hashlib
import json
import platform
import shutil
import time
from pathlib import Path
import requests
from ..exceptions import BrowserInstallationError, NetworkError
from ..utils.paths import install_dir

def _get_platform_key(()) -> str:
    """Determine the platform key for Chrome for Testing downloads."""

def _validate_lkgv_data((data: dict)) -> None:
    """Validate the structure of LKGV JSON data."""

def _fetch_lkgv_data((logger, timeout: int = 30)) -> dict:
    """ Fetch and validate LKGV data from Chrome for Testing API...."""

def _download_with_progress((
    url: str, dest_path: Path, logger, timeout: int = 300
)) -> None:
    """ Download a file with progress reporting and integrity checks...."""

def _extract_archive((archive_path: Path, extract_path: Path, logger)) -> None:
    """ Extract downloaded archive with error handling...."""

def install_from_lkgv((logger, max_retries: int = 3, retry_delay: int = 5)) -> None:
    """ Download and extract Chrome for Testing from the LKGV JSON...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser/launcher.py
# Language: python

import subprocess
import time
from pathlib import Path
from ..exceptions import BrowserLaunchError, TimeoutError
from .process import wait_for_process_start

def launch_chrome((
    browser_path: Path, data_dir: Path, port: int, logger, timeout: int = 30
)):
    """ Launch Chrome executable as a detached process with verification...."""

def launch_chrome_with_retry((
    browser_path: Path,
    data_dir: Path,
    port: int,
    logger,
    max_retries: int = 3,
    retry_delay: int = 2,
)) -> None:
    """ Launch Chrome with retry logic...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser/process.py
# Language: python

import time
import psutil
from ..exceptions import ProcessKillError, TimeoutError

def get_chrome_process((port: int | None = None)) -> psutil.Process | None:
    """Find a running Chrome process, optionally filtered by debug port."""

def kill_chrome_process((proc: psutil.Process, timeout: int = 10, logger=None)) -> None:
    """ Kill a Chrome process gracefully with fallback to force kill...."""

def wait_for_process_start((
    port: int, timeout: int = 30, check_interval: float = 0.5
)) -> psutil.Process:
    """ Wait for a Chrome process with debug port to start...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/browser_manager.py
# Language: python

import time
from rich.console import Console
from .browser.finder import find_chrome_executable
from .browser.installer import install_from_lkgv
from .browser.launcher import launch_chrome_with_retry
from .browser.process import get_chrome_process, kill_chrome_process
from .config import get_config
from .exceptions import (
    BrowserInstallationError,
    BrowserLaunchError,
    BrowserManagerError,
    NetworkError,
    ProcessKillError,
)
from .exceptions import TimeoutError as PATimeoutError
from .state_manager import get_state_manager
from .utils.logger import configure as configure_logger
from .utils.paths import install_dir

def ensure_browser((verbose: bool = False, max_retries: int | None = None, profile: str = "default")) -> tuple[str, str]:
    """ Ensures a Chrome for Testing instance is running with remote debugging...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/cli.py
# Language: python

import shutil
import fire
from rich.console import Console
from .browser_manager import ensure_browser
from .exceptions import BrowserManagerError
from .utils.logger import configure as configure_logger
from .utils.paths import install_dir

class Cli:
    """CLI for PlaywrightAuthor."""
    def status((self, verbose: bool = False)):
        """Checks browser status and launches it if not running."""
    def clear_cache((self)):
        """ Removes the browser installation directory, including the browser itself and user data...."""

def status((self, verbose: bool = False)):
    """Checks browser status and launches it if not running."""

def clear_cache((self)):
    """ Removes the browser installation directory, including the browser itself and user data...."""

def main(()) -> None:


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/config.py
# Language: python

import json
import os
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any
from loguru import logger
from .utils.paths import config_dir

class BrowserConfig:
    """Configuration for browser behavior."""

class NetworkConfig:
    """Configuration for network operations."""

class PathsConfig:
    """Configuration for file paths."""

class LoggingConfig:
    """Configuration for logging."""

class PlaywrightAuthorConfig:
    """Main configuration class for PlaywrightAuthor."""

class ConfigManager:
    """Manages configuration loading and validation."""
    def __init__((self, config_path: Path | None = None)):
        """Initialize the configuration manager."""
    def _default_config_path((self)) -> Path:
        """Get the default configuration file path."""
    def load((self)) -> PlaywrightAuthorConfig:
        """Load configuration from all sources."""
    def save((self, config: PlaywrightAuthorConfig | None = None)) -> None:
        """Save configuration to file."""
    def _load_from_file((self, config: PlaywrightAuthorConfig)) -> None:
        """Load configuration from file."""
    def _load_from_env((self, config: PlaywrightAuthorConfig)) -> None:
        """Load configuration from environment variables."""
    def _validate((self, config: PlaywrightAuthorConfig)) -> None:
        """Validate configuration values."""
    def _to_dict((self, config: PlaywrightAuthorConfig)) -> dict[str, Any]:
        """Convert configuration to dictionary."""

def __init__((self, config_path: Path | None = None)):
    """Initialize the configuration manager."""

def _default_config_path((self)) -> Path:
    """Get the default configuration file path."""

def load((self)) -> PlaywrightAuthorConfig:
    """Load configuration from all sources."""

def save((self, config: PlaywrightAuthorConfig | None = None)) -> None:
    """Save configuration to file."""

def _load_from_file((self, config: PlaywrightAuthorConfig)) -> None:
    """Load configuration from file."""

def _load_from_env((self, config: PlaywrightAuthorConfig)) -> None:
    """Load configuration from environment variables."""

def _validate((self, config: PlaywrightAuthorConfig)) -> None:
    """Validate configuration values."""

def _to_dict((self, config: PlaywrightAuthorConfig)) -> dict[str, Any]:
    """Convert configuration to dictionary."""

def get_config((config_path: Path | None = None)) -> PlaywrightAuthorConfig:
    """Get the global configuration."""

def save_config((config: PlaywrightAuthorConfig)) -> None:
    """Save configuration to file."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/exceptions.py
# Language: python

class PlaywrightAuthorError(E, x, c, e, p, t, i, o, n):
    """Base exception for all PlaywrightAuthor errors."""

class BrowserManagerError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """Raised for errors related to browser management."""

class BrowserInstallationError(B, r, o, w, s, e, r, M, a, n, a, g, e, r, E, r, r, o, r):
    """Raised when browser installation fails."""

class BrowserLaunchError(B, r, o, w, s, e, r, M, a, n, a, g, e, r, E, r, r, o, r):
    """Raised when browser launch fails."""

class ProcessKillError(B, r, o, w, s, e, r, M, a, n, a, g, e, r, E, r, r, o, r):
    """Raised when process termination fails."""

class NetworkError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """Raised for network-related errors."""

class TimeoutError(P, l, a, y, w, r, i, g, h, t, A, u, t, h, o, r, E, r, r, o, r):
    """Raised when operations exceed timeout."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/lazy_imports.py
# Language: python

import importlib
import sys
from typing import TYPE_CHECKING, Any
from loguru import logger
from playwright.async_api import async_playwright
from playwright.sync_api import sync_playwright
from playwright.sync_api import sync_playwright
from playwright.async_api import async_playwright
import psutil
import requests

class LazyModule:
    """A lazy module that imports on first attribute access."""
    def __init__((self, module_name: str)):
        """Initialize the lazy module."""
    def _load((self)) -> Any:
        """Load the module if not already loaded."""
    def __getattr__((self, name: str)) -> Any:
        """Get attribute from the loaded module."""
    def __dir__((self)) -> list[str]:
        """List attributes of the loaded module."""

class LazyPlaywright:
    """Lazy loader for Playwright with both sync and async APIs."""
    def __init__((self)):
        """Initialize the lazy Playwright loader."""
    def sync_playwright((self)):
        """Get the sync_playwright context manager."""
    def async_playwright((self)):
        """Get the async_playwright context manager."""

def __init__((self, module_name: str)):
    """Initialize the lazy module."""

def _load((self)) -> Any:
    """Load the module if not already loaded."""

def __getattr__((self, name: str)) -> Any:
    """Get attribute from the loaded module."""

def __dir__((self)) -> list[str]:
    """List attributes of the loaded module."""

def __init__((self)):
    """Initialize the lazy Playwright loader."""

def sync_api((self)):
    """Get the synchronous Playwright API."""

def async_api((self)):
    """Get the asynchronous Playwright API."""

def sync_playwright((self)):
    """Get the sync_playwright context manager."""

def async_playwright((self)):
    """Get the async_playwright context manager."""

def get_sync_playwright(()):
    """Get the sync_playwright context manager lazily."""

def get_async_playwright(()):
    """Get the async_playwright context manager lazily."""

def get_sync_api(()):
    """Get the synchronous Playwright API module lazily."""

def get_async_api(()):
    """Get the asynchronous Playwright API module lazily."""

def get_psutil(()):
    """Get psutil module lazily."""

def get_requests(()):
    """Get requests module lazily."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/onboarding.py
# Language: python

import asyncio
from pathlib import Path
from playwright.async_api import Browser as AsyncBrowser
from playwright.async_api import Page

def _detect_login_activity((page: Page, logger)) -> bool:
    """ Detect if the user has performed login activities...."""

def _wait_for_user_action((page: Page, logger, timeout: int = 300)) -> str:
    """ Wait for user to either navigate away or perform login activities...."""

def show((browser: AsyncBrowser, logger, timeout: int = 300)) -> None:
    """ Shows the onboarding page and waits for user authentication or navigation...."""

def show_with_retry((
    browser: AsyncBrowser, logger, max_retries: int = 2, timeout: int = 300
)) -> None:
    """ Show onboarding with retry logic for error resilience...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/state_manager.py
# Language: python

import json
import os
from datetime import datetime
from pathlib import Path
from typing import Any, TypedDict
from loguru import logger
from .exceptions import BrowserManagerError
from .utils.paths import data_dir

class BrowserState(T, y, p, e, d, D, i, c, t, ,,  , t, o, t, a, l, =, F, a, l, s, e):
    """Type definition for browser state data."""

class StateManager:
    """Manages browser state persistence and migration."""
    def __init__((self, state_dir: Path | None = None)):
        """Initialize the state manager."""
    def _ensure_state_dir((self)) -> None:
        """Ensure the state directory exists."""
    def load_state((self)) -> BrowserState:
        """Load browser state from disk."""
    def save_state((self, state: BrowserState)) -> None:
        """Save browser state to disk."""
    def get_chrome_path((self)) -> Path | None:
        """Get the cached Chrome executable path."""
    def set_chrome_path((self, path: Path)) -> None:
        """Cache the Chrome executable path."""
    def get_profile((self, name: str = "default")) -> dict[str, Any]:
        """Get a browser profile by name."""
    def set_profile((self, name: str, profile_data: dict[str, Any])) -> None:
        """Save a browser profile."""
    def list_profiles((self)) -> list[str]:
        """List all available profile names."""
    def delete_profile((self, name: str)) -> None:
        """Delete a browser profile."""
    def clear_state((self)) -> None:
        """Clear all saved state."""
    def _default_state((self)) -> BrowserState:
        """Create a default browser state."""
    def _default_profile((self)) -> dict[str, Any]:
        """Create a default profile."""
    def _migrate_state((self, state: dict[str, Any])) -> BrowserState:
        """Migrate state to the current version."""

def __init__((self, state_dir: Path | None = None)):
    """Initialize the state manager."""

def _ensure_state_dir((self)) -> None:
    """Ensure the state directory exists."""

def load_state((self)) -> BrowserState:
    """Load browser state from disk."""

def save_state((self, state: BrowserState)) -> None:
    """Save browser state to disk."""

def get_chrome_path((self)) -> Path | None:
    """Get the cached Chrome executable path."""

def set_chrome_path((self, path: Path)) -> None:
    """Cache the Chrome executable path."""

def get_profile((self, name: str = "default")) -> dict[str, Any]:
    """Get a browser profile by name."""

def set_profile((self, name: str, profile_data: dict[str, Any])) -> None:
    """Save a browser profile."""

def list_profiles((self)) -> list[str]:
    """List all available profile names."""

def delete_profile((self, name: str)) -> None:
    """Delete a browser profile."""

def clear_state((self)) -> None:
    """Clear all saved state."""

def _default_state((self)) -> BrowserState:
    """Create a default browser state."""

def _default_profile((self)) -> dict[str, Any]:
    """Create a default profile."""

def _migrate_state((self, state: dict[str, Any])) -> BrowserState:
    """Migrate state to the current version."""

def get_state_manager((state_dir: Path | None = None)) -> StateManager:
    """Get the global StateManager instance."""


<document index="16">
<source>src/playwrightauthor/templates/onboarding.html</source>
<document_content>
<!-- this_file: src/playwrightauthor/templates/onboarding.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PlaywrightAuthor Onboarding</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 700px;
            margin: 40px auto;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 28px;
            color: #111;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 16px;
            color: #666;
            margin-bottom: 30px;
        }
        
        .step {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 4px solid #007aff;
        }
        
        .step-number {
            background: #007aff;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            margin-right: 12px;
        }
        
        .step-title {
            font-weight: 600;
            color: #111;
            margin-bottom: 8px;
        }
        
        .step-description {
            color: #555;
            margin-bottom: 0;
        }
        
        .tips {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .tips-title {
            font-weight: 600;
            color: #1565c0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .tips-title::before {
            content: "üí°";
            margin-right: 8px;
        }
        
        .tip-list {
            margin: 0;
            padding-left: 20px;
        }
        
        .tip-list li {
            margin-bottom: 8px;
            color: #1565c0;
        }
        
        .status {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
        }
        
        .status-text {
            color: #856404;
            font-weight: 500;
            margin: 0;
        }
        
        strong {
            color: #007aff;
        }
        
        .keyboard-shortcut {
            background: #f1f3f4;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 14px;
        }
        
        @media (max-width: 600px) {
            body {
                margin: 20px auto;
                padding: 20px;
            }
            
            h1 {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé≠ PlaywrightAuthor Setup</h1>
        <p class="subtitle">Your personal, authenticated browser is almost ready!</p>
    </div>
    
    <div class="step">
        <div class="step-title">
            <span class="step-number">1</span>
            Open a new tab or navigate to a website
        </div>
        <p class="step-description">
            Use <span class="keyboard-shortcut">Ctrl+T</span> (or <span class="keyboard-shortcut">Cmd+T</span> on Mac) to open a new tab, 
            or type a URL in the address bar above.
        </p>
    </div>
    
    <div class="step">
        <div class="step-title">
            <span class="step-number">2</span>
            Log into any websites you need
        </div>
        <p class="step-description">
            Sign in to Google, GitHub, social media, or any other services you'll be automating. 
            Your login sessions will be preserved for future use.
        </p>
    </div>
    
    <div class="step">
        <div class="step-title">
            <span class="step-number">3</span>
            That's it!
        </div>
        <p class="step-description">
            Once you navigate away from this page or log into any service, 
            PlaywrightAuthor will automatically detect the activity and your browser will be ready to use.
        </p>
    </div>
    
    <div class="tips">
        <div class="tips-title">Pro Tips</div>
        <ul class="tip-list">
            <li>You can log into multiple services at once - open several tabs!</li>
            <li>Your browser data is stored locally and securely on your machine</li>
            <li>You won't need to do this setup again unless you clear your browser data</li>
            <li>Close this tab anytime if you don't need to log into anything right now</li>
        </ul>
    </div>
    
    <div class="status">
        <p class="status-text">
            ‚è≥ Waiting for you to navigate away from this page or complete a login...
        </p>
    </div>
    
    <script>
        // Add some interactivity to show the page is responsive
        document.addEventListener('DOMContentLoaded', function() {
            const status = document.querySelector('.status-text');
            let dots = 0;
            
            setInterval(function() {
                dots = (dots + 1) % 4;
                const dotString = '.'.repeat(dots);
                status.textContent = `‚è≥ Waiting for you to navigate away from this page or complete a login${dotString}`;
            }, 500);
        });
        
        // Detect when user starts typing in address bar or opens new tab
        window.addEventListener('beforeunload', function() {
            console.log('PlaywrightAuthor: User is navigating away from onboarding page');
        });
    </script>
</body>
</html>
</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/typing.py
# Language: python



# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/utils/logger.py
# Language: python

from loguru import logger

def configure((verbose: bool = False)):


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/src/playwrightauthor/utils/paths.py
# Language: python

from pathlib import Path
from platformdirs import user_cache_dir, user_config_dir, user_data_dir

def install_dir(()) -> Path:
    """Get the directory for browser installations."""

def data_dir(()) -> Path:
    """Get the directory for persistent data storage."""

def config_dir(()) -> Path:
    """Get the directory for configuration files."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_author.py
# Language: python

import pytest
from playwrightauthor import AsyncBrowser, Browser

def test_browser_smoke(()):
    """A basic smoke test to ensure the Browser class can be instantiated."""

def test_async_browser_smoke(()):
    """A basic smoke test to ensure the AsyncBrowser class can be instantiated."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_benchmark.py
# Language: python

import pytest
from playwrightauthor.browser_manager import ensure_browser

def test_benchmark_ensure_browser((benchmark)):
    """Benchmark the ensure_browser function."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_integration.py
# Language: python

import asyncio
import os
import platform
import sys
import time
from pathlib import Path
from unittest.mock import MagicMock, patch
import pytest
from playwrightauthor import AsyncBrowser, Browser
from playwrightauthor.browser.finder import find_chrome_executable, get_chrome_version
from playwrightauthor.browser.process import get_chrome_process
from playwrightauthor.browser_manager import ensure_browser
from playwrightauthor.exceptions import BrowserManagerError
from playwrightauthor.utils.logger import configure
from playwrightauthor.utils.paths import install_dir

class TestBrowserIntegration:
    """Integration tests for synchronous Browser class."""
    def test_browser_cookies_persistence((self)):
        """Test that cookies persist across browser sessions."""

class TestAsyncBrowserIntegration:
    """Integration tests for asynchronous AsyncBrowser class."""
    def _create_and_navigate_page((self, browser, index)):
        """Helper to create and navigate a page."""

class TestBrowserManagerIntegration:
    """Integration tests for browser management functionality."""
    def test_ensure_browser_creates_paths((self, logger)):
        """Test that ensure_browser creates necessary directories."""
    def test_chrome_process_detection((self, logger)):
        """Test Chrome process detection functionality."""
    def test_chrome_version_detection((self, logger)):
        """Test Chrome version detection."""

class TestCrossPlatformIntegration:
    """Cross-platform integration tests."""
    def test_platform_specific_paths((self, logger)):
        """Test that platform-specific paths are correctly determined."""
    def test_chrome_finder_logging((self, logger, capsys)):
        """Test that Chrome finder provides useful logging."""

class TestEndToEndScenarios:
    """End-to-end integration scenarios."""
    def test_browser_restart_resilience((self)):
        """Test that browser can be restarted multiple times."""

class TestErrorHandlingIntegration:
    """Integration tests for error handling."""
    def test_browser_handles_network_errors((self)):
        """Test browser behavior with network errors."""

class TestPerformanceBenchmarks:
    """Performance benchmarks for the library."""

def logger(()):
    """Provide a test logger."""

def test_browser_basic_usage((self)):
    """Test basic Browser usage with page navigation."""

def test_browser_multiple_pages((self)):
    """Test managing multiple pages."""

def test_browser_cookies_persistence((self)):
    """Test that cookies persist across browser sessions."""

def test_async_browser_basic_usage((self)):
    """Test basic AsyncBrowser usage."""

def test_async_browser_concurrent_pages((self)):
    """Test concurrent page operations with AsyncBrowser."""

def _create_and_navigate_page((self, browser, index)):
    """Helper to create and navigate a page."""

def test_ensure_browser_creates_paths((self, logger)):
    """Test that ensure_browser creates necessary directories."""

def test_chrome_process_detection((self, logger)):
    """Test Chrome process detection functionality."""

def test_chrome_version_detection((self, logger)):
    """Test Chrome version detection."""

def test_platform_specific_paths((self, logger)):
    """Test that platform-specific paths are correctly determined."""

def test_chrome_finder_logging((self, logger, capsys)):
    """Test that Chrome finder provides useful logging."""

def test_full_workflow((self)):
    """Test complete workflow from browser setup to page automation."""

def test_browser_restart_resilience((self)):
    """Test that browser can be restarted multiple times."""

def test_browser_handles_network_errors((self)):
    """Test browser behavior with network errors."""

def test_browser_handles_missing_chrome((self, mock_find)):
    """Test behavior when Chrome is not found."""

def test_browser_startup_time((self, benchmark)):
    """Benchmark browser startup time."""

def start_browser(()):

def test_page_creation_time((self, benchmark)):
    """Benchmark page creation time."""

def create_page(()):


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_platform_specific.py
# Language: python

import os
import platform
import subprocess
import sys
import tempfile
from pathlib import Path
from unittest.mock import MagicMock, patch
import pytest
from playwrightauthor.browser.finder import (
    _get_linux_chrome_paths,
    _get_macos_chrome_paths,
    _get_windows_chrome_paths,
    find_chrome_executable,
    get_chrome_version,
)
from playwrightauthor.utils.logger import configure
from playwrightauthor.browser_manager import _DEBUGGING_PORT

class TestPlatformSpecificChromeFinding:
    """Test Chrome finding functionality on different platforms."""
    def setup_method((self)):
        """Set up test logger."""
    def test_find_chrome_executable_with_logger((self)):
        """Test find_chrome_executable with logging enabled."""
    def test_find_chrome_unsupported_platform((self)):
        """Test Chrome finding on unsupported platform."""

class TestPlatformSpecificPaths:
    """Test platform-specific path handling."""

class TestCrossplatformCompatibility:
    """Test cross-platform compatibility features."""
    def test_path_handling((self)):
        """Test that Path objects are used consistently."""
    def test_environment_variable_handling((self)):
        """Test environment variable handling across platforms."""
    def test_home_directory_expansion((self)):
        """Test home directory handling."""

class TestIntegrationPlatformSpecific:
    """Integration tests for platform-specific functionality."""
    def test_real_chrome_finding((self)):
        """Test finding Chrome on the actual system."""
    def test_browser_manager_integration((self)):
        """Test integration with browser_manager module."""

def setup_method((self)):
    """Set up test logger."""

def test_windows_chrome_paths((self)):
    """Test Windows Chrome path generation."""

def test_macos_chrome_paths((self)):
    """Test macOS Chrome path generation."""

def test_linux_chrome_paths((self)):
    """Test Linux Chrome path generation."""

def test_find_chrome_executable_with_logger((self)):
    """Test find_chrome_executable with logging enabled."""

def test_get_chrome_version_success((self, mock_run)):
    """Test successful Chrome version retrieval."""

def test_get_chrome_version_failure((self, mock_run)):
    """Test Chrome version retrieval failure."""

def test_get_chrome_version_timeout((self, mock_run)):
    """Test Chrome version retrieval timeout."""

def test_find_chrome_unsupported_platform((self)):
    """Test Chrome finding on unsupported platform."""

def test_executable_permissions_check((self)):
    """Test that executable permissions are checked on Unix systems."""

def mock_paths(()):

def test_windows_where_command((self)):
    """Test Windows 'where' command integration."""

def test_linux_which_command((self)):
    """Test Linux 'which' command integration."""

def test_path_handling((self)):
    """Test that Path objects are used consistently."""

def test_environment_variable_handling((self)):
    """Test environment variable handling across platforms."""

def test_home_directory_expansion((self)):
    """Test home directory handling."""

def test_real_chrome_finding((self)):
    """Test finding Chrome on the actual system."""

def test_browser_manager_integration((self)):
    """Test integration with browser_manager module."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/playwrightauthor/tests/test_utils.py
# Language: python

import sys
from pathlib import Path
from unittest.mock import patch
from playwrightauthor.utils.logger import configure
from playwrightauthor.utils.paths import install_dir
from loguru import logger
from loguru import logger
from loguru import logger

class TestPaths:
    """Test suite for utils.paths module."""
    def test_install_dir_returns_path((self)):
        """Test that install_dir() returns a Path object."""
    def test_install_dir_contains_app_name((self)):
        """Test that install_dir() contains the application name."""
    def test_install_dir_contains_browser_subdir((self)):
        """Test that install_dir() includes 'browser' subdirectory."""
    def test_install_dir_is_absolute((self)):
        """Test that install_dir() returns an absolute path."""
    def test_install_dir_consistent((self)):
        """Test that multiple calls to install_dir() return the same path."""

class TestLogger:
    """Test suite for utils.logger module."""
    def setup_method((self)):
        """Set up test fixtures."""
    def teardown_method((self)):
        """Clean up after tests."""
    def test_configure_returns_logger((self)):
        """Test that configure() returns a logger object."""
    def test_configure_verbose_false((self)):
        """Test configure() with verbose=False sets INFO level."""
    def test_configure_verbose_true((self)):
        """Test configure() with verbose=True sets DEBUG level."""
    def test_configure_removes_existing_handlers((self)):
        """Test that configure() removes existing loguru handlers."""
    def test_configure_consistent_logger((self)):
        """Test that multiple calls to configure() return the same logger."""
    def test_configure_logging_levels((self)):
        """Test different logging levels work correctly."""

class TestUtilsIntegration:
    """Integration tests for utils modules."""
    def test_logger_can_log_to_install_dir_path((self)):
        """Test that logger can handle Path objects from install_dir()."""
    def test_paths_work_with_different_platforms((self)):
        """Test that paths work across different platform scenarios."""

def test_install_dir_returns_path((self)):
    """Test that install_dir() returns a Path object."""

def test_install_dir_contains_app_name((self)):
    """Test that install_dir() contains the application name."""

def test_install_dir_contains_browser_subdir((self)):
    """Test that install_dir() includes 'browser' subdirectory."""

def test_install_dir_is_absolute((self)):
    """Test that install_dir() returns an absolute path."""

def test_install_dir_consistent((self)):
    """Test that multiple calls to install_dir() return the same path."""

def test_install_dir_with_custom_cache_dir((self, mock_cache_dir)):
    """Test install_dir() with a custom cache directory."""

def setup_method((self)):
    """Set up test fixtures."""

def teardown_method((self)):
    """Clean up after tests."""

def test_configure_returns_logger((self)):
    """Test that configure() returns a logger object."""

def test_configure_verbose_false((self)):
    """Test configure() with verbose=False sets INFO level."""

def test_configure_verbose_true((self)):
    """Test configure() with verbose=True sets DEBUG level."""

def test_configure_removes_existing_handlers((self)):
    """Test that configure() removes existing loguru handlers."""

def test_configure_consistent_logger((self)):
    """Test that multiple calls to configure() return the same logger."""

def test_configure_logging_levels((self)):
    """Test different logging levels work correctly."""

def test_logger_can_log_to_install_dir_path((self)):
    """Test that logger can handle Path objects from install_dir()."""

def test_paths_work_with_different_platforms((self)):
    """Test that paths work across different platform scenarios."""


</documents>